[{"number":"5287","reopenOn":null,"comments":[{"date":"2017-04-16T23:48:26Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=h1) Report\n> Merging [#5287](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/434d1f420d98e90f19e313db569eb4bb972a5ab8?src=pr&el=desc) will **decrease** coverage by `0.02%`.\n> The diff coverage is `100%`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287\/graphs\/tree.svg?token=WtCc2hTjM2&src=pr&height=150&width=650)](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree)\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5287      +\/-   ##\n============================================\n- Coverage     96.05%   96.03%   -0.03%     \n- Complexity     5748     5755       +7     \n============================================\n  Files           628      628              \n  Lines         41077    41085       +8     \n  Branches       5699     5703       +4     \n============================================\n- Hits          39455    39454       -1     \n- Misses          648      650       +2     \n- Partials        974      981       +7\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...rnal\/operators\/flowable\/FlowableFlatMapSingle.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRmxhdE1hcFNpbmdsZS5qYXZh) | `97.82% <100%> (+2.22%)` | `2 <0> (ø)` | :arrow_down: |\n| [...ernal\/operators\/flowable\/FlowableFlatMapMaybe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRmxhdE1hcE1heWJlLmphdmE=) | `96.13% <100%> (+2.1%)` | `2 <0> (ø)` | :arrow_down: |\n| [...a\/io\/reactivex\/processors\/SerializedProcessor.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcHJvY2Vzc29ycy9TZXJpYWxpemVkUHJvY2Vzc29yLmphdmE=) | `91.48% <0%> (-6.39%)` | `27% <0%> (-1%)` | |\n| [...\/operators\/completable\/CompletableConcatArray.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0QXJyYXkuamF2YQ==) | `93.75% <0%> (-6.25%)` | `2% <0%> (ø)` | |\n| [...ava\/io\/reactivex\/processors\/BehaviorProcessor.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcHJvY2Vzc29ycy9CZWhhdmlvclByb2Nlc3Nvci5qYXZh) | `87.61% <0%> (-4.87%)` | `61% <0%> (ø)` | |\n| [...ternal\/operators\/flowable\/FlowableSampleTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlU2FtcGxlVGltZWQuamF2YQ==) | `91.17% <0%> (-4.42%)` | `3% <0%> (ø)` | |\n| [...erators\/completable\/CompletableConcatIterable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0SXRlcmFibGUuamF2YQ==) | `95.91% <0%> (-4.09%)` | `2% <0%> (ø)` | |\n| [...rnal\/operators\/completable\/CompletableTimeout.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlVGltZW91dC5qYXZh) | `94% <0%> (-4%)` | `2% <0%> (ø)` | |\n| [...vex\/internal\/operators\/single\/SingleTakeUntil.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS9TaW5nbGVUYWtlVW50aWwuamF2YQ==) | `91.8% <0%> (-3.28%)` | `2% <0%> (ø)` | |\n| [...ernal\/operators\/flowable\/FlowableFromIterable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRnJvbUl0ZXJhYmxlLmphdmE=) | `90.9% <0%> (-3.21%)` | `5% <0%> (ø)` | |\n| ... and [42 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=footer). Last update [434d1f4...6430cb2](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5287?src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments).\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-04-17T10:40:42Z","description":"This PR fixes `Flowable.flatMapMaybe` and `Flowable.flatMapSingle` not replenishing from the upstream when they complete\/error per inner source.","id":"222040353","title":"2.x: fix Flowable.flatMapMaybe\/Single maxConcurrency not requesting more","opened_on":"2017-04-16T23:34:29Z","closed_by":"akarnokd"},{"number":"5285","reopenOn":null,"comments":[{"date":"2017-04-15T12:52:27Z","author":"akarnokd","text":"PR welcome."},{"date":"2017-04-15T20:30:09Z","author":"akarnokd","text":"Closing via #5286 "}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-04-15T20:30:09Z","description":" - [x] `ConnectableObservable` talks about `Flowable` and `Subscriber`, remnants of copy-paste\r\n - [x] `FlowableFlattenIterable` `it.next()` is not checked for `null`\r\n - [x] `Maybe` links to `Subscriber`","id":"221946396","title":"2.x: minor mistakes to be fixed","opened_on":"2017-04-15T12:46:21Z","closed_by":"akarnokd"},{"number":"5281","reopenOn":null,"comments":[{"date":"2017-04-12T11:45:36Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=h1) Report\n> Merging [#5281](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/8a78c74d847886e9d42601fe5cd462d231c7ff35?src=pr&el=desc) will **decrease** coverage by `0.1%`.\n> The diff coverage is `100%`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281\/graphs\/tree.svg?height=150&width=650&token=WtCc2hTjM2&src=pr)](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree)\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5281      +\/-   ##\n============================================\n- Coverage     96.12%   96.01%   -0.11%     \n+ Complexity     5755     5745      -10     \n============================================\n  Files           628      628              \n  Lines         41079    41077       -2     \n  Branches       5699     5699              \n============================================\n- Hits          39486    39441      -45     \n- Misses          631      653      +22     \n- Partials        962      983      +21\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...in\/java\/io\/reactivex\/subjects\/BehaviorSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvQmVoYXZpb3JTdWJqZWN0LmphdmE=) | `84.89% <100%> (+0.95%)` | `56 <5> (+1)` | :arrow_up: |\n| [...ava\/io\/reactivex\/processors\/BehaviorProcessor.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcHJvY2Vzc29ycy9CZWhhdmlvclByb2Nlc3Nvci5qYXZh) | `87.61% <100%> (-0.06%)` | `61 <5> (ø)` | |\n| [...al\/operators\/observable\/ObservableSampleTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVNhbXBsZVRpbWVkLmphdmE=) | `88.33% <0%> (-10%)` | `3% <0%> (ø)` | |\n| [...a\/io\/reactivex\/internal\/util\/QueueDrainHelper.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvdXRpbC9RdWV1ZURyYWluSGVscGVyLmphdmE=) | `58.86% <0%> (-5.68%)` | `31% <0%> (-4%)` | |\n| [...reactivex\/internal\/operators\/single\/SingleAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS9TaW5nbGVBbWIuamF2YQ==) | `96.36% <0%> (-3.64%)` | `9% <0%> (-1%)` | |\n| [...internal\/operators\/completable\/CompletableAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQW1iLmphdmE=) | `94.91% <0%> (-3.39%)` | `10% <0%> (-1%)` | |\n| [...ernal\/operators\/flowable\/FlowableFromIterable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRnJvbUl0ZXJhYmxlLmphdmE=) | `91.97% <0%> (-3.21%)` | `5% <0%> (ø)` | |\n| [...x\/internal\/operators\/maybe\/MaybeSwitchIfEmpty.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlU3dpdGNoSWZFbXB0eS5qYXZh) | `97.22% <0%> (-2.78%)` | `2% <0%> (ø)` | |\n| [...rnal\/operators\/flowable\/FlowableTakeLastTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlVGFrZUxhc3RUaW1lZC5qYXZh) | `96.29% <0%> (-2.78%)` | `2% <0%> (ø)` | |\n| [...activex\/internal\/observers\/QueueDrainObserver.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb2JzZXJ2ZXJzL1F1ZXVlRHJhaW5PYnNlcnZlci5qYXZh) | `61.53% <0%> (-2.57%)` | `12% <0%> (-1%)` | |\n| ... and [36 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=footer). Last update [8a78c74...fa780f4](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5281?src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."},{"date":"2017-04-12T13:24:39Z","author":"akarnokd","text":"No need for that."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-04-12T13:24:43Z","description":"This PR fixes the race condition in `BehaviorProcessor` and `BehaviorSubject` when `onComplete()` or `onError()` is called concurrently with `subscribe` and the consumer throws a `NullPointerException` instead of relaying the terminal event.\r\n\r\nThe fix involves having a separate `terminalEvent` atomic field, CAS-ing in the actual or marker `Throwable` and reading that field in `subscribe`.","id":"221232968","title":"2.x: BehaviorProcessor & Subject terminate-subscribe race","opened_on":"2017-04-12T11:31:08Z","closed_by":"akarnokd"},{"number":"5280","reopenOn":null,"comments":[{"date":"2017-04-12T11:34:23Z","author":"akarnokd","text":"Nice catch! See #5281 for the fix."},{"date":"2017-04-12T13:25:02Z","author":"akarnokd","text":"Closing via #5821."}],"opened_by":"davidschreiber","reopen":false,"closed_on":"2017-04-12T13:25:02Z","description":"RxJava 2.0.8\r\n\r\nSetting the terminal event of the `BehaviorProcessor` and replaying it to late subscribers is not an atomic action, and causes a `NullPointerException` in certain racy situations.\r\n\r\nThe root cause seems to be the non-atomicity of marking the processor terminated, and setting the terminal event, inside the `BehaviorProcessor#terminate` method, [here](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/2.x\/src\/main\/java\/io\/reactivex\/processors\/BehaviorProcessor.java#L411).\r\n\r\nFollowing is a minimal example which helps reproducing the race condition.\r\n\r\n```\r\npackage com.example;\r\n\r\nimport io.reactivex.processors.BehaviorProcessor;\r\nimport io.reactivex.subscribers.TestSubscriber;\r\n\r\npublic class BehaviorProcessorRaceExample {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i <= 100000; i++) {\r\n            final TestSubscriber<Object> s = TestSubscriber.create();\r\n            final BehaviorProcessor<Boolean> bp = BehaviorProcessor.create();\r\n\r\n            final Thread t1 = new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    bp.onComplete();\r\n                }\r\n            });\r\n\r\n            final Thread t2 = new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    bp.subscribe(s);\r\n                }\r\n            });\r\n\r\n            t1.setDaemon(true);\r\n            t2.setDaemon(true);\r\n\r\n            t1.start();\r\n            t2.start();\r\n        }\r\n    }\r\n}\r\n``` \r\n\r\nRunning this will result in exceptions like this.\r\n\r\n```\r\nException in thread \"Thread-1279\" java.lang.NullPointerException\r\n\tat io.reactivex.internal.util.NotificationLite.getError(NotificationLite.java:189)\r\n\tat io.reactivex.processors.BehaviorProcessor.subscribeActual(BehaviorProcessor.java:162)\r\n\tat io.reactivex.Flowable.subscribe(Flowable.java:12970)\r\n\tat com.example.BehaviorProcessorRaceExample$2.run(BehaviorProcessorRaceExample.java:24)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n```\r\n","id":"221202303","title":"2.x NullPointerException while subscribing to BehaviorProcessor","opened_on":"2017-04-12T09:25:17Z","closed_by":"akarnokd"},{"number":"5277","reopenOn":null,"comments":[{"date":"2017-04-10T12:39:26Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=h1) Report\n> Merging [#5277](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/80d9b909e9df856b34f60438235e74f0daa49a96?src=pr&el=desc) will **increase** coverage by `0.08%`.\n> The diff coverage is `100%`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277\/graphs\/tree.svg?width=650&height=150&src=pr&token=WtCc2hTjM2)](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree)\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5277      +\/-   ##\n============================================\n+ Coverage     96.02%   96.11%   +0.08%     \n- Complexity     5752     5754       +2     \n============================================\n  Files           628      628              \n  Lines         41077    41079       +2     \n  Branches       5699     5699              \n============================================\n+ Hits          39445    39482      +37     \n+ Misses          658      627      -31     \n+ Partials        974      970       -4\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...x\/internal\/observers\/BiConsumerSingleObserver.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb2JzZXJ2ZXJzL0JpQ29uc3VtZXJTaW5nbGVPYnNlcnZlci5qYXZh) | `100% <100%> (ø)` | `7 <2> (ø)` | :arrow_down: |\n| [...nternal\/operators\/observable\/ObservableCreate.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUNyZWF0ZS5qYXZh) | `91.96% <0%> (-7.15%)` | `2% <0%> (ø)` | |\n| [...\/operators\/completable\/CompletableConcatArray.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0QXJyYXkuamF2YQ==) | `93.75% <0%> (-6.25%)` | `2% <0%> (ø)` | |\n| [...reactivex\/internal\/operators\/maybe\/MaybeUsing.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlVXNpbmcuamF2YQ==) | `95.95% <0%> (-4.05%)` | `4% <0%> (ø)` | |\n| [...nternal\/operators\/parallel\/ParallelSortedJoin.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL3BhcmFsbGVsL1BhcmFsbGVsU29ydGVkSm9pbi5qYXZh) | `91.3% <0%> (-3.63%)` | `2% <0%> (ø)` | |\n| [...al\/operators\/observable\/ObservableSampleTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVNhbXBsZVRpbWVkLmphdmE=) | `93.33% <0%> (-3.34%)` | `3% <0%> (ø)` | |\n| [...rnal\/operators\/flowable\/FlowableFlatMapSingle.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRmxhdE1hcFNpbmdsZS5qYXZh) | `93.4% <0%> (-2.75%)` | `2% <0%> (ø)` | |\n| [...rnal\/operators\/flowable\/FlowableSequenceEqual.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlU2VxdWVuY2VFcXVhbC5qYXZh) | `96.34% <0%> (-2.44%)` | `2% <0%> (ø)` | |\n| [...\/internal\/operators\/maybe\/MaybeTakeUntilMaybe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlVGFrZVVudGlsTWF5YmUuamF2YQ==) | `97.95% <0%> (-2.05%)` | `2% <0%> (ø)` | |\n| [...activex\/internal\/disposables\/DisposableHelper.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvZGlzcG9zYWJsZXMvRGlzcG9zYWJsZUhlbHBlci5qYXZh) | `98.14% <0%> (-1.86%)` | `27% <0%> (-1%)` | |\n| ... and [38 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=footer). Last update [80d9b90...445d93c](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5277?src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-04-10T12:44:37Z","description":"Fixes the `Single.subscribe(BiConsumer)` to report `isDisposed` when terminating.\r\n\r\nReported in #5276.","id":"220627686","title":"2.x: Single.subscribe(BiConsumer) consistent isDisposed","opened_on":"2017-04-10T12:24:18Z","closed_by":"akarnokd"},{"number":"5276","reopenOn":null,"comments":[{"date":"2017-04-10T12:24:28Z","author":"akarnokd","text":"Thanks for reporting. This is indeed an inconsistency with other methods. See #5277 for the fix."},{"date":"2017-04-10T12:44:53Z","author":"akarnokd","text":"Closing via #5277."}],"opened_by":"qwert2603","reopen":false,"closed_on":"2017-04-10T12:44:53Z","description":"I noticed that ```Disposable``` returned from ```Single::subscribe(final BiConsumer<? super T, ? super Throwable> onCallback)``` returns ```false``` from ```Disposable::isDisposed``` even after ```onCallback``` was called. Version of RxJava is 2.0.8. Code sample:\r\n````\r\nimport io.reactivex.Single\r\nimport io.reactivex.disposables.Disposable\r\nimport io.reactivex.schedulers.Schedulers\r\n\r\nfun main(args: Array<String>) {\r\n\r\n    var disposable: Disposable? = null\r\n    disposable = Single.just(34)\r\n            .subscribeOn(Schedulers.computation())\r\n            .observeOn(Schedulers.io())\r\n            .subscribe { item, throwable ->\r\n                println(\"1 ${disposable?.isDisposed}\")\r\n            }\r\n\r\n    println(\"2 ${disposable?.isDisposed}\")\r\n    Thread.sleep(1000)\r\n    println(\"3 ${disposable?.isDisposed}\")\r\n\r\n}\r\n\r\n````\r\n\r\nOutput is:\r\n````\r\n2 false\r\n1 false\r\n3 false\r\n````","id":"220605685","title":"Single's Disposable is not disposing.","opened_on":"2017-04-10T10:45:52Z","closed_by":"akarnokd"},{"number":"5256","reopenOn":null,"comments":[{"date":"2017-04-01T17:52:13Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=h1) Report\n> Merging [#5256](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/ba5edc9bf28cc9cc4abab492dbf1daecf34c74f7?src=pr&el=desc) will **increase** coverage by `0.04%`.\n> The diff coverage is `66.66%`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256\/graphs\/tree.svg?src=pr&token=WtCc2hTjM2&width=650&height=150)](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree)\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5256      +\/-   ##\n============================================\n+ Coverage     95.95%   95.99%   +0.04%     \n+ Complexity     5750     5746       -4     \n============================================\n  Files           628      628              \n  Lines         41075    41077       +2     \n  Branches       5698     5699       +1     \n============================================\n+ Hits          39414    39433      +19     \n+ Misses          664      657       -7     \n+ Partials        997      987      -10\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...al\/operators\/flowable\/FlowableFlattenIterable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRmxhdHRlbkl0ZXJhYmxlLmphdmE=) | `97.24% <66.66%> (+0.02%)` | `4 <0> (ø)` | :arrow_down: |\n| [...rnal\/subscriptions\/ArrayCompositeSubscription.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaXB0aW9ucy9BcnJheUNvbXBvc2l0ZVN1YnNjcmlwdGlvbi5qYXZh) | `93.33% <0%> (-6.67%)` | `17% <0%> (-1%)` | |\n| [...\/operators\/completable\/CompletableConcatArray.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0QXJyYXkuamF2YQ==) | `93.75% <0%> (-6.25%)` | `2% <0%> (ø)` | |\n| [...rnal\/subscribers\/SinglePostCompleteSubscriber.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaWJlcnMvU2luZ2xlUG9zdENvbXBsZXRlU3Vic2NyaWJlci5qYXZh) | `94.87% <0%> (-5.13%)` | `14% <0%> (-1%)` | |\n| [...rnal\/subscriptions\/DeferredScalarSubscription.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaXB0aW9ucy9EZWZlcnJlZFNjYWxhclN1YnNjcmlwdGlvbi5qYXZh) | `93.84% <0%> (-4.62%)` | `27% <0%> (-1%)` | |\n| [...ternal\/operators\/observable\/ObservablePublish.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVB1Ymxpc2guamF2YQ==) | `91.22% <0%> (-4.39%)` | `9% <0%> (-1%)` | |\n| [...reactivex\/internal\/operators\/single\/SingleAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS9TaW5nbGVBbWIuamF2YQ==) | `96.36% <0%> (-3.64%)` | `9% <0%> (-1%)` | |\n| [...\/io\/reactivex\/internal\/schedulers\/IoScheduler.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc2NoZWR1bGVycy9Jb1NjaGVkdWxlci5qYXZh) | `89.13% <0%> (-3.27%)` | `9% <0%> (ø)` | |\n| [...va\/io\/reactivex\/internal\/queue\/SpscArrayQueue.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvcXVldWUvU3BzY0FycmF5UXVldWUuamF2YQ==) | `97.61% <0%> (-2.39%)` | `22% <0%> (-1%)` | |\n| [...main\/java\/io\/reactivex\/subjects\/SingleSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvU2luZ2xlU3ViamVjdC5qYXZh) | `95.23% <0%> (-2.39%)` | `38% <0%> (-1%)` | |\n| ... and [39 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=footer). Last update [ba5edc9...cd6b13f](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5256?src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-04-01T18:00:20Z","description":"The wrong logical expression in the `isEmpty()` method made `flatMapIterable` complete earlier, even if data was available in the current iterable.\r\n\r\nSomewhat related: https:\/\/github.com\/reactor\/reactor-core\/issues\/508 (different logical bug in the same method).","id":"218711055","title":"2.x: fix flatMapIterable appearing to be empty when fused","opened_on":"2017-04-01T17:38:56Z","closed_by":"akarnokd"},{"number":"5247","reopenOn":null,"comments":[{"date":"2017-03-31T11:16:04Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=h1) Report\n> Merging [#5247](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/7c95808f077537428f2ae80fffd15e2848a2de31?src=pr&el=desc) will **decrease** coverage by `0.04%`.\n> The diff coverage is `100%`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247\/graphs\/tree.svg?width=650&token=WtCc2hTjM2&height=150&src=pr)](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree)\n\n```diff\n@@             Coverage Diff             @@\n##                2.x   #5247      +\/-   ##\n===========================================\n- Coverage     96.04%     96%   -0.05%     \n- Complexity     5749    5750       +1     \n===========================================\n  Files           628     628              \n  Lines         41073   41075       +2     \n  Branches       5697    5698       +1     \n===========================================\n- Hits          39450   39434      -16     \n- Misses          636     659      +23     \n+ Partials        987     982       -5\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...ex\/internal\/operators\/flowable\/FlowableToList.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlVG9MaXN0LmphdmE=) | `96.77% <100%> (+0.22%)` | `2 <0> (ø)` | :arrow_down: |\n| [...rnal\/subscriptions\/ArrayCompositeSubscription.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaXB0aW9ucy9BcnJheUNvbXBvc2l0ZVN1YnNjcmlwdGlvbi5qYXZh) | `93.33% <0%> (-6.67%)` | `17% <0%> (-1%)` | |\n| [...vex\/internal\/operators\/single\/SingleTakeUntil.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS9TaW5nbGVUYWtlVW50aWwuamF2YQ==) | `86.88% <0%> (-6.56%)` | `2% <0%> (ø)` | |\n| [...\/java\/io\/reactivex\/subjects\/SerializedSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvU2VyaWFsaXplZFN1YmplY3QuamF2YQ==) | `89.47% <0%> (-6.32%)` | `26% <0%> (-1%)` | |\n| [...in\/java\/io\/reactivex\/subjects\/BehaviorSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvQmVoYXZpb3JTdWJqZWN0LmphdmE=) | `84.97% <0%> (-5.7%)` | `56% <0%> (ø)` | |\n| [...rnal\/subscriptions\/DeferredScalarSubscription.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaXB0aW9ucy9EZWZlcnJlZFNjYWxhclN1YnNjcmlwdGlvbi5qYXZh) | `93.84% <0%> (-4.62%)` | `27% <0%> (-1%)` | |\n| [...erators\/completable\/CompletableConcatIterable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0SXRlcmFibGUuamF2YQ==) | `95.91% <0%> (-4.09%)` | `2% <0%> (ø)` | |\n| [...rnal\/operators\/completable\/CompletableTimeout.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlVGltZW91dC5qYXZh) | `94% <0%> (-4%)` | `2% <0%> (ø)` | |\n| [...ava\/io\/reactivex\/processors\/BehaviorProcessor.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcHJvY2Vzc29ycy9CZWhhdmlvclByb2Nlc3Nvci5qYXZh) | `88.54% <0%> (-3.97%)` | `62% <0%> (+1%)` | |\n| [...vex\/internal\/operators\/flowable\/FlowableTimer.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlVGltZXIuamF2YQ==) | `92.85% <0%> (-3.58%)` | `2% <0%> (ø)` | |\n| ... and [42 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=footer). Last update [7c95808...affef41](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5247?src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-03-31T11:16:01Z","description":"This PR fixes the `NullPointerException` that can happen because `cancel` nulls out the value and `onNext` simply dereferences that value in `FlowableToList`.\r\n\r\nReported in #5246 .","id":"218469792","title":"2.x: fix Flowable.toList() onNext\/cancel race","opened_on":"2017-03-31T11:01:49Z","closed_by":"akarnokd"},{"number":"5246","reopenOn":null,"comments":[{"date":"2017-03-31T08:17:59Z","author":"akarnokd","text":"What version are you using? Could you share some code?"},{"date":"2017-03-31T09:32:25Z","author":"dvasko","text":"version 2.0.6\r\nthis is one of the examples\r\n```\r\n        Flowable<List<Team>> networkTask = Network.getUiClient().getTeams()\r\n                .onErrorReturn(throwable -> new ArrayList<>())\r\n                .concatMap(Flowable::fromIterable)\r\n                .filter(team -> isValid(team))\r\n                .toList().toFlowable();\r\n```\r\n"},{"date":"2017-03-31T09:46:09Z","author":"akarnokd","text":"I'd guess `Network.getUiClient().getTeams()` is a custom `Publisher` of some sorts because that particular exception can only happen if there is an `onNext` after an `onComplete` or `onError`. It would  be great if you could write a standalone unit test that reproduces the problem."},{"date":"2017-03-31T10:38:53Z","author":"dvasko","text":"Behind ```Network.getUiClient().getTeams()``` and every other network call is Retrofit, beside that we have few database calls wraped in ```Flowable.fromCallable(db::getTeams);``` and no other custom ```Publisher```.\r\nWe see bug happening in production but we can't reproduce it and stacktrace don't give to much informations from where is coming from (Network API have ~50 endpoints).\r\nOnly thing that we know is that bug is affecting really small number of sessions."},{"date":"2017-03-31T10:48:39Z","author":"akarnokd","text":"There is a small race window between an `onNext()` and a `cancel()` that could cause this. I'll post a fix for this."},{"date":"2017-03-31T17:33:29Z","author":"akarnokd","text":"Closing via #5247."}],"opened_by":"dvasko","reopen":false,"closed_on":"2017-03-31T17:33:29Z","description":"Notices few of this crashes, is there any way to find from where they are coming?\r\n```\r\nFatal Exception: java.lang.NullPointerException: Attempt to invoke interface method 'boolean java.util.Collection.add(java.lang.Object)' on a null object reference\r\n       at io.reactivex.internal.operators.flowable.FlowableToList$ToListSubscriber.onNext(FlowableToList.java:71)\r\n       at io.reactivex.internal.operators.flowable.FlowableFilter$FilterSubscriber.tryOnNext(FlowableFilter.java:73)\r\n       at io.reactivex.internal.operators.flowable.FlowableFilter$FilterSubscriber.onNext(FlowableFilter.java:51)\r\n       at io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapImmediate.innerNext(FlowableConcatMap.java:215)\r\n       at io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapInner.onNext(FlowableConcatMap.java:592)\r\n       at io.reactivex.internal.operators.flowable.FlowableFromIterable$IteratorSubscription.fastPath(FlowableFromIterable.java:181)\r\n       at io.reactivex.internal.operators.flowable.FlowableFromIterable$BaseRangeSubscription.request(FlowableFromIterable.java:123)\r\n       at io.reactivex.internal.subscriptions.SubscriptionArbiter.setSubscription(SubscriptionArbiter.java:96)\r\n       at io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapInner.onSubscribe(FlowableConcatMap.java:585)\r\n       at io.reactivex.internal.operators.flowable.FlowableFromIterable.subscribe(FlowableFromIterable.java:69)\r\n       at io.reactivex.internal.operators.flowable.FlowableFromIterable.subscribeActual(FlowableFromIterable.java:47)\r\n       at io.reactivex.Flowable.subscribe(Flowable.java:12901)\r\n       at io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapImmediate.drain(FlowableConcatMap.java:343)\r\n       at io.reactivex.internal.operators.flowable.FlowableConcatMap$BaseConcatMapSubscriber.onNext(FlowableConcatMap.java:158)\r\n       at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.onNext(FlowableSubscribeOn.java:97)\r\n       at io.reactivex.internal.subscriptions.DeferredScalarSubscription.complete(DeferredScalarSubscription.java:133)\r\n       at io.reactivex.internal.operators.flowable.FlowableFromCallable.subscribeActual(FlowableFromCallable.java:44)\r\n       at io.reactivex.Flowable.subscribe(Flowable.java:12901)\r\n       at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.run(FlowableSubscribeOn.java:82)\r\n       at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)\r\n       at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)\r\n       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272)\r\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\n       at java.lang.Thread.run(Thread.java:761)\r\n```","id":"218427651","title":"2.x: NullPointerException in FlowableToList$ToListSubscriber.onNext","opened_on":"2017-03-31T08:07:37Z","closed_by":"akarnokd"},{"number":"5240","reopenOn":null,"comments":[{"date":"2017-03-27T19:27:28Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=h1) Report\n> Merging [#5240](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/851de4154895d899577ce69b13585c26eb96cf84?src=pr&el=desc) will **increase** coverage by `0.02%`.\n> The diff coverage is `100%`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240\/graphs\/tree.svg?width=650&height=150&src=pr&token=WtCc2hTjM2)](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree)\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5240      +\/-   ##\n============================================\n+ Coverage     96.12%   96.15%   +0.02%     \n- Complexity     5757     5758       +1     \n============================================\n  Files           628      628              \n  Lines         41074    41073       -1     \n  Branches       5697     5697              \n============================================\n+ Hits          39484    39495      +11     \n+ Misses          630      616      -14     \n- Partials        960      962       +2\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...\/io\/reactivex\/observers\/ResourceMaybeObserver.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvb2JzZXJ2ZXJzL1Jlc291cmNlTWF5YmVPYnNlcnZlci5qYXZh) | `100% <ø> (ø)` | `8 <0> (ø)` | :arrow_down: |\n| [...io\/reactivex\/observers\/ResourceSingleObserver.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvb2JzZXJ2ZXJzL1Jlc291cmNlU2luZ2xlT2JzZXJ2ZXIuamF2YQ==) | `100% <ø> (ø)` | `8 <0> (ø)` | :arrow_down: |\n| [...activex\/observers\/ResourceCompletableObserver.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvb2JzZXJ2ZXJzL1Jlc291cmNlQ29tcGxldGFibGVPYnNlcnZlci5qYXZh) | `100% <ø> (ø)` | `8 <0> (ø)` | :arrow_down: |\n| [...ava\/io\/reactivex\/observers\/DisposableObserver.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvb2JzZXJ2ZXJzL0Rpc3Bvc2FibGVPYnNlcnZlci5qYXZh) | `100% <ø> (ø)` | `7 <0> (ø)` | :arrow_down: |\n| [...nternal\/observers\/CallbackCompletableObserver.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb2JzZXJ2ZXJzL0NhbGxiYWNrQ29tcGxldGFibGVPYnNlcnZlci5qYXZh) | `100% <100%> (ø)` | `9 <0> (ø)` | :arrow_down: |\n| [...vex\/internal\/operators\/single\/SingleTakeUntil.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS9TaW5nbGVUYWtlVW50aWwuamF2YQ==) | `86.88% <0%> (-8.2%)` | `2% <0%> (ø)` | |\n| [...l\/operators\/observable\/ObservableFlatMapMaybe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXBNYXliZS5qYXZh) | `91.5% <0%> (-5.23%)` | `2% <0%> (ø)` | |\n| [...ternal\/operators\/observable\/ObservablePublish.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVB1Ymxpc2guamF2YQ==) | `92.1% <0%> (-3.51%)` | `10% <0%> (ø)` | |\n| [...internal\/operators\/completable\/CompletableAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQW1iLmphdmE=) | `94.91% <0%> (-3.39%)` | `10% <0%> (-1%)` | |\n| [...activex\/internal\/subscribers\/FutureSubscriber.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaWJlcnMvRnV0dXJlU3Vic2NyaWJlci5qYXZh) | `96.82% <0%> (-3.18%)` | `32% <0%> (-1%)` | |\n| ... and [42 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=footer). Last update [851de41...256674b](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5240?src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-03-27T19:37:01Z","description":"This PR contains the fix for incorrect call of the `onError` handler within `CallbackCompletableObserver.onComplete()` reported in [5099](https:\/\/github.com\/ReactiveX\/RxJava\/issues\/5099#issuecomment-289544756) as well as wording fixes to the `ResourceX` javadoc.","id":"217345133","title":"2.x: fix CallbackCompletableObserver calling onError, ResourceX wording","opened_on":"2017-03-27T19:09:43Z","closed_by":"akarnokd"},{"number":"5225","reopenOn":null,"comments":[{"date":"2017-03-24T17:21:57Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=h1) Report\n> Merging [#5225](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=desc) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/1d7edee0a60cbf185157555483db430e1afd6702?src=pr&el=desc) will **decrease** coverage by `0.1%`.\n> The diff coverage is `100%`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225\/graphs\/tree.svg?height=150&width=650&token=WtCc2hTjM2&src=pr)](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree)\n\n```diff\n@@            Coverage Diff             @@\n##               1.x   #5225      +\/-   ##\n==========================================\n- Coverage     84.5%   84.4%   -0.11%     \n+ Complexity    2886    2883       -3     \n==========================================\n  Files          290     290              \n  Lines        18123   18124       +1     \n  Branches      2479    2479              \n==========================================\n- Hits         15315   15297      -18     \n- Misses        1943    1963      +20     \n+ Partials       865     864       -1\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [src\/main\/java\/rx\/Completable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9Db21wbGV0YWJsZS5qYXZh) | `83.37% <100%> (+0.02%)` | `103 <0> (ø)` | :arrow_down: |\n| [...\/java\/rx\/internal\/util\/unsafe\/MpscLinkedQueue.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC91dGlsL3Vuc2FmZS9NcHNjTGlua2VkUXVldWUuamF2YQ==) | `75.75% <0%> (-12.13%)` | `9% <0%> (-1%)` | |\n| [...\/rx\/internal\/operators\/OperatorWindowWithTime.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JXaW5kb3dXaXRoVGltZS5qYXZh) | `42.04% <0%> (-6.44%)` | `3% <0%> (ø)` | |\n| [...internal\/subscriptions\/SequentialSubscription.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9zdWJzY3JpcHRpb25zL1NlcXVlbnRpYWxTdWJzY3JpcHRpb24uamF2YQ==) | `46.55% <0%> (-3.45%)` | `14% <0%> (-1%)` | |\n| [...\/java\/rx\/internal\/operators\/BackpressureUtils.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvQmFja3ByZXNzdXJlVXRpbHMuamF2YQ==) | `68.18% <0%> (-2.28%)` | `27% <0%> (-1%)` | |\n| [src\/main\/java\/rx\/observers\/SerializedObserver.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9vYnNlcnZlcnMvU2VyaWFsaXplZE9ic2VydmVyLmphdmE=) | `98.91% <0%> (-1.09%)` | `19% <0%> (-1%)` | |\n| [...n\/java\/rx\/subjects\/SubjectSubscriptionManager.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9zdWJqZWN0cy9TdWJqZWN0U3Vic2NyaXB0aW9uTWFuYWdlci5qYXZh) | `80.71% <0%> (-0.72%)` | `15% <0%> (ø)` | |\n| [...\/rx\/internal\/schedulers\/CachedThreadScheduler.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9zY2hlZHVsZXJzL0NhY2hlZFRocmVhZFNjaGVkdWxlci5qYXZh) | `90.29% <0%> (+0.97%)` | `6% <0%> (ø)` | :arrow_down: |\n| [...a\/rx\/internal\/operators\/BufferUntilSubscriber.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvQnVmZmVyVW50aWxTdWJzY3JpYmVyLmphdmE=) | `73.01% <0%> (+1.58%)` | `12% <0%> (+1%)` | :arrow_up: |\n| [...n\/java\/rx\/internal\/operators\/CachedObservable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvQ2FjaGVkT2JzZXJ2YWJsZS5qYXZh) | `85.32% <0%> (+1.63%)` | `6% <0%> (ø)` | :arrow_down: |\n| ... and [1 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=footer). Last update [1d7edee...51bd12a](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5225?src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-03-24T19:39:32Z","description":"The `Completable.onErrorResumeNext` did not properly propagate the downstream `unsubscribe()` call to upstream.\r\n\r\nReported in #5224.","id":"216849066","title":"1.x: fix Completable.onErrorResumeNext unsubscribe not propagated","opened_on":"2017-03-24T17:08:03Z","closed_by":"akarnokd"},{"number":"5224","reopenOn":null,"comments":[{"date":"2017-03-25T16:35:29Z","author":"akarnokd","text":"Closing via #5225."}],"opened_by":"4xes","reopen":false,"closed_on":"2017-03-27T07:34:08Z","description":"I have completable that contains `merge` or `andThen`. \r\nThen I add `onErrorResumeNext` into sequence. In this case, If we unsubscribe the whole `subscription` when `com1` is not completed yet then `com2` won't be unsubscribed.\r\n\r\nCode sample:\r\n```java\r\n        Completable com1 = Completable\r\n                .fromAction(() -> {\r\n                    try {\r\n                        Thread.sleep(3000);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    Log.d(TAG, \"c1\");\r\n                })\r\n                .doOnSubscribe(s1 -> Log.d(TAG, \"com1 subscribe\"))\r\n                .doOnUnsubscribe(() -> Log.d(TAG, \"com1 unsubscribe\"));\r\n\r\n        Completable com2 = Completable\r\n                .fromAction(() -> {\r\n                    try {\r\n                        Thread.sleep(6000);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    Log.d(TAG, \"c2\");\r\n                })\r\n                .doOnSubscribe(s2 -> Log.d(TAG, \"com2 subscribe\"))\r\n                .doOnUnsubscribe(() -> Log.d(TAG, \"com2 unsubscribe\"));\r\n\r\n        Subscription subscription =\r\n                Completable.merge(\r\n                        com1,\r\n                        com2\r\n                )\r\n                        .subscribeOn(Schedulers.from(Executors.newSingleThreadExecutor()))\r\n                        .onErrorResumeNext(throwable ->\r\n                                Completable\r\n                                        .fromAction(() -> Log.d(TAG, \"error happened\"))\r\n                        )\r\n                        .doOnSubscribe(s -> Log.d(TAG, \"subscribe\"))\r\n                        .doOnUnsubscribe(() -> Log.d(TAG, \"unsubscribe\"))\r\n                        .subscribe(\r\n                                () -> Log.d(TAG, \"onComplete \"),\r\n                                throwable -> Log.d(TAG, \"onError \" + throwable)\r\n                        );\r\n\r\n        Completable\r\n                .fromAction(() -> {\r\n                    subscription.unsubscribe();\r\n                    Log.d(TAG,\"whole subscription unsubscribe\");\r\n                })\r\n                .delay(2, TimeUnit.SECONDS)\r\n                .subscribe();\r\n```\r\nResult:\r\n```\r\nD: subscribe\r\nD: com1 subscribe\r\nD: whole subscription unsubscribe\r\nD: c1\r\nD: com2 subscribe\r\nD: c2\r\nD: onComplete \r\n```\r\n\r\nCase without operator `onErrorResumeNext` :\r\n```\r\nD: subscribe\r\nD: com1 subscribe\r\nD: unsubscribe\r\nD: com1 unsubscribe\r\nD: whole subscription unsubscribe\r\nD: c1\r\n```","id":"216828494","title":"1.2.9: Completable not unsubscribe with onErrorResumeNext","opened_on":"2017-03-24T15:54:07Z","closed_by":"akarnokd"},{"number":"5213","reopenOn":null,"comments":[{"date":"2017-03-22T12:43:00Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5213?src=pr&el=h1) Report\n> Merging [#5213](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5213?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/cd91a9f712db77e09dfc3147ba9b9eaaefb525fb?src=pr&el=desc) will **increase** coverage by `0.09%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5213      +\/-   ##\n============================================\n+ Coverage     96.02%   96.12%   +0.09%     \n- Complexity     5680     5690      +10     \n============================================\n  Files           621      621              \n  Lines         40611    40617       +6     \n  Branches       5632     5636       +4     \n============================================\n+ Hits          38998    39042      +44     \n+ Misses          643      623      -20     \n+ Partials        970      952      -18\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5213?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...ternal\/operators\/flowable\/FlowableWindowTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/cd91a9f712db77e09dfc3147ba9b9eaaefb525fb...158cb0d97bd44133124353de5bf68f3a25207b94?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlV2luZG93VGltZWQuamF2YQ==) | `84.68% <100%> (+1.01%)` | `4 <0> (ø)` | :arrow_down: |\n| [...al\/operators\/observable\/ObservableWindowTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/cd91a9f712db77e09dfc3147ba9b9eaaefb525fb...158cb0d97bd44133124353de5bf68f3a25207b94?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVdpbmRvd1RpbWVkLmphdmE=) | `90.71% <100%> (+2.28%)` | `4 <0> (ø)` | :arrow_down: |\n| [...\/operators\/completable\/CompletableConcatArray.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/cd91a9f712db77e09dfc3147ba9b9eaaefb525fb...158cb0d97bd44133124353de5bf68f3a25207b94?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0QXJyYXkuamF2YQ==) | `93.75% <0%> (-6.25%)` | `2% <0%> (ø)` | |\n| [...internal\/operators\/completable\/CompletableAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/cd91a9f712db77e09dfc3147ba9b9eaaefb525fb...158cb0d97bd44133124353de5bf68f3a25207b94?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQW1iLmphdmE=) | `94.91% <0%> (-5.09%)` | `10% <0%> (-1%)` | |\n| [...ternal\/operators\/completable\/CompletableUsing.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/cd91a9f712db77e09dfc3147ba9b9eaaefb525fb...158cb0d97bd44133124353de5bf68f3a25207b94?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlVXNpbmcuamF2YQ==) | `95.23% <0%> (-4.77%)` | `4% <0%> (ø)` | |\n| [...reactivex\/internal\/operators\/single\/SingleAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/cd91a9f712db77e09dfc3147ba9b9eaaefb525fb...158cb0d97bd44133124353de5bf68f3a25207b94?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS9TaW5nbGVBbWIuamF2YQ==) | `96.36% <0%> (-3.64%)` | `9% <0%> (-1%)` | |\n| [...vex\/internal\/operators\/single\/SingleTakeUntil.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/cd91a9f712db77e09dfc3147ba9b9eaaefb525fb...158cb0d97bd44133124353de5bf68f3a25207b94?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS9TaW5nbGVUYWtlVW50aWwuamF2YQ==) | `91.8% <0%> (-3.28%)` | `2% <0%> (ø)` | |\n| [...x\/internal\/operators\/flowable\/FlowablePublish.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/cd91a9f712db77e09dfc3147ba9b9eaaefb525fb...158cb0d97bd44133124353de5bf68f3a25207b94?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlUHVibGlzaC5qYXZh) | `93.83% <0%> (-1.77%)` | `9% <0%> (-1%)` | |\n| [...ternal\/operators\/observable\/ObservablePublish.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/cd91a9f712db77e09dfc3147ba9b9eaaefb525fb...158cb0d97bd44133124353de5bf68f3a25207b94?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVB1Ymxpc2guamF2YQ==) | `94.73% <0%> (-1.76%)` | `9% <0%> (-2%)` | |\n| [...al\/operators\/observable\/ObservableSampleTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/cd91a9f712db77e09dfc3147ba9b9eaaefb525fb...158cb0d97bd44133124353de5bf68f3a25207b94?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVNhbXBsZVRpbWVkLmphdmE=) | `96.66% <0%> (-1.67%)` | `3% <0%> (ø)` | |\n| ... and [39 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5213?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5213?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5213?src=pr&el=footer). Last update [cd91a9f...158cb0d](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/cd91a9f712db77e09dfc3147ba9b9eaaefb525fb...158cb0d97bd44133124353de5bf68f3a25207b94?el=footer&src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-03-22T19:54:35Z","description":"The `window()` operator overload with time and size bound didn't work correctly when some windows were terminated by the timeout and others by the size. This PR fixes:\r\n\r\n  - the case when the operator restarts the time windows when the size bound is reached,\r\n  - leaking of the worker,\r\n  - the item counter not reset to zero when the time bound is reached,\r\n  - periodic window bound stopped working after the first window.\r\n\r\nRelated #5104 (again).","id":"216040719","title":"2.x: fix window() with time+size emission problems","opened_on":"2017-03-22T12:09:38Z","closed_by":"akarnokd"},{"number":"5207","reopenOn":null,"comments":[{"date":"2017-03-20T19:47:59Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5207?src=pr&el=h1) Report\n> Merging [#5207](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5207?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/ab0c59094d11142cea4fef70169f053e062d85ec?src=pr&el=desc) will **increase** coverage by `0.05%`.\n> The diff coverage is `98.93%`.\n\n\n```diff\n@@             Coverage Diff             @@\n##               2.x    #5207      +\/-   ##\n===========================================\n+ Coverage     95.9%   95.95%   +0.05%     \n- Complexity    5678     5706      +28     \n===========================================\n  Files          621      624       +3     \n  Lines        40611    40677      +66     \n  Branches      5632     5644      +12     \n===========================================\n+ Hits         38947    39032      +85     \n+ Misses         673      660      -13     \n+ Partials       991      985       -6\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5207?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...activex\/internal\/schedulers\/ExecutorScheduler.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/ab0c59094d11142cea4fef70169f053e062d85ec...80dcb69e73abfb6bf3f95ee5c4e18524f28b8843?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc2NoZWR1bGVycy9FeGVjdXRvclNjaGVkdWxlci5qYXZh) | `94.59% <100%> (-1.89%)` | `9 <0> (ø)` | |\n| [...reactivex\/internal\/schedulers\/NewThreadWorker.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/ab0c59094d11142cea4fef70169f053e062d85ec...80dcb69e73abfb6bf3f95ee5c4e18524f28b8843?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc2NoZWR1bGVycy9OZXdUaHJlYWRXb3JrZXIuamF2YQ==) | `100% <100%> (ø)` | `17 <5> (+2)` | :arrow_up: |\n| [...ternal\/schedulers\/ScheduledDirectPeriodicTask.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/ab0c59094d11142cea4fef70169f053e062d85ec...80dcb69e73abfb6bf3f95ee5c4e18524f28b8843?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc2NoZWR1bGVycy9TY2hlZHVsZWREaXJlY3RQZXJpb2RpY1Rhc2suamF2YQ==) | `100% <100%> (ø)` | `2 <2> (?)` | |\n| [...reactivex\/internal\/schedulers\/SingleScheduler.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/ab0c59094d11142cea4fef70169f053e062d85ec...80dcb69e73abfb6bf3f95ee5c4e18524f28b8843?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc2NoZWR1bGVycy9TaW5nbGVTY2hlZHVsZXIuamF2YQ==) | `95.77% <100%> (+0.12%)` | `13 <3> (ø)` | :arrow_down: |\n| [...tivex\/internal\/schedulers\/ScheduledDirectTask.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/ab0c59094d11142cea4fef70169f053e062d85ec...80dcb69e73abfb6bf3f95ee5c4e18524f28b8843?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc2NoZWR1bGVycy9TY2hlZHVsZWREaXJlY3RUYXNrLmphdmE=) | `100% <100%> (ø)` | `2 <2> (?)` | |\n| [...ctivex\/internal\/schedulers\/AbstractDirectTask.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/ab0c59094d11142cea4fef70169f053e062d85ec...80dcb69e73abfb6bf3f95ee5c4e18524f28b8843?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc2NoZWR1bGVycy9BYnN0cmFjdERpcmVjdFRhc2suamF2YQ==) | `100% <100%> (ø)` | `16 <16> (?)` | |\n| [...activex\/internal\/schedulers\/ScheduledRunnable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/ab0c59094d11142cea4fef70169f053e062d85ec...80dcb69e73abfb6bf3f95ee5c4e18524f28b8843?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc2NoZWR1bGVycy9TY2hlZHVsZWRSdW5uYWJsZS5qYXZh) | `95.74% <100%> (+2.41%)` | `27 <7> (+3)` | :arrow_up: |\n| [src\/main\/java\/io\/reactivex\/Scheduler.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/ab0c59094d11142cea4fef70169f053e062d85ec...80dcb69e73abfb6bf3f95ee5c4e18524f28b8843?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvU2NoZWR1bGVyLmphdmE=) | `98.83% <91.66%> (-1.17%)` | `11 <0> (ø)` | |\n| [...al\/operators\/observable\/ObservableSampleTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/ab0c59094d11142cea4fef70169f053e062d85ec...80dcb69e73abfb6bf3f95ee5c4e18524f28b8843?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVNhbXBsZVRpbWVkLmphdmE=) | `88.33% <0%> (-8.34%)` | `3% <0%> (ø)` | |\n| [...ternal\/operators\/observable\/ObservablePublish.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/ab0c59094d11142cea4fef70169f053e062d85ec...80dcb69e73abfb6bf3f95ee5c4e18524f28b8843?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVB1Ymxpc2guamF2YQ==) | `91.22% <0%> (-5.27%)` | `9% <0%> (-2%)` | |\n| ... and [44 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5207?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5207?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5207?src=pr&el=footer). Last update [ab0c590...80dcb69](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/ab0c59094d11142cea4fef70169f053e062d85ec...80dcb69e73abfb6bf3f95ee5c4e18524f28b8843?el=footer&src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-03-22T12:51:57Z","description":"Task wrappers of the various schedulers and modes (direct & worker) were able to get cancelled via interruption from the same thread they were running.\r\n\r\nRelated #5203.","id":"215531010","title":"2.x: prevent tasks to self interrupt on the standard schedulers","opened_on":"2017-03-20T19:32:55Z","closed_by":"akarnokd"},{"number":"5205","reopenOn":null,"comments":[{"date":"2017-03-20T17:35:02Z","author":"akarnokd","text":"Unfortunately, this may break a legitimate use case for interrupting a sleep that happens on the `onNext` call of the timer itself:\r\n\r\n```java\r\nto = Observable.timer(1, TimeUnit.SECONDS)\r\n.map(v -> Thread.sleep(5000))\r\n.test();\r\n\r\nThread.sleep(2000);\r\n\r\nto.cancel();\r\n```"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-03-20T17:35:02Z","description":"When the `timer()` is firing its `onNext(0L)`, there is no point in allowing a canellation to bubble up to the current `Future` as it just interrupts the current thread. The fix thus makes sure the cancellation chain is cut off before `onNext` and the current parent `Future` should complete normally.\r\n\r\nRelated: #5203.","id":"215489050","title":"2.x: fix timer() to prevent a self-interrupt when signals its only value","opened_on":"2017-03-20T17:05:12Z","closed_by":"akarnokd"},{"number":"5203","reopenOn":null,"comments":[{"date":"2017-03-20T16:56:22Z","author":"akarnokd","text":"This is an unexpected side-effect of cancelling the delay timer inside the `delaySubscription` operator. I'll post a fix for it shortly."},{"date":"2017-03-20T19:47:12Z","author":"akarnokd","text":"See #5207."},{"date":"2017-03-20T22:38:47Z","author":"hkurokawa","text":"Thank you for your prompt work on this. Waiting for the next release including this fix."},{"date":"2017-03-27T07:35:11Z","author":"akarnokd","text":"Closing via #5207."}],"opened_by":"hkurokawa","reopen":false,"closed_on":"2017-03-27T07:35:11Z","description":"I ran the below test code with RxJava 2.0.7 and got a failure which succeeded with RxJava 1.x.\r\n\r\n```java\r\n    final TestObserver<Boolean> observer = TestObserver.create();\r\n    Observable.<Boolean>create(emitter -> {\r\n      emitter.onNext(Thread.interrupted());\r\n      emitter.onComplete();\r\n    })\r\n        .delaySubscription(100, TimeUnit.MICROSECONDS)\r\n        .subscribe(observer);\r\n    observer.awaitTerminalEvent();\r\n    observer.assertValue(false);\r\n  }\r\n```\r\n\r\nIf I put `subscribeOn()` before `delaySubscription()`, it does not fail.\r\n\r\nI am not sure if it is as expected so want to know if it is the expected behaviour.\r\n\r\nHere is some background of my issue: I am using RxJava 2.0.7 with Retrofit 2.2.0 and it seems Retrofit (precisely speaking, Okio, which is being used in OkHttp) throws an error when the thread is interrupted while it tries to read the HTTP response. I am trying to delay the HTTP call to achieve something like debounce() with delaySubscription() operator and encountered this issue. I have a workaround so just want to know if it is the expected behaviour.\r\n\r\nThank you for your support in advance.","id":"215471650","title":"Is delaySubscription() interrupts the thread immediately as expected?","opened_on":"2017-03-20T16:11:07Z","closed_by":"akarnokd"},{"number":"5188","reopenOn":null,"comments":[{"date":"2017-03-15T15:36:52Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5188?src=pr&el=h1) Report\n> Merging [#5188](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5188?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/2d03fa9711e8f4e99cfb8150c7043021002ac13e?src=pr&el=desc) will **decrease** coverage by `0.04%`.\n> The diff coverage is `73.33%`.\n\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5188      +\/-   ##\n============================================\n- Coverage     95.98%   95.94%   -0.05%     \n- Complexity     5665     5667       +2     \n============================================\n  Files           621      621              \n  Lines         40340    40346       +6     \n  Branches       5616     5620       +4     \n============================================\n- Hits          38722    38711      -11     \n- Misses          638      653      +15     \n- Partials        980      982       +2\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5188?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...x\/internal\/operators\/flowable\/FlowableFlatMap.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...6f6a1b4ec7407daf75ecfe301e96673eb98ea418?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRmxhdE1hcC5qYXZh) | `88.09% <71.42%> (+0.09%)` | `4 <0> (ø)` | :x: |\n| [...ternal\/operators\/observable\/ObservableFlatMap.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...6f6a1b4ec7407daf75ecfe301e96673eb98ea418?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXAuamF2YQ==) | `83.93% <75%> (+1.15%)` | `3 <0> (ø)` | :x: |\n| [...a\/io\/reactivex\/processors\/SerializedProcessor.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...6f6a1b4ec7407daf75ecfe301e96673eb98ea418?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcHJvY2Vzc29ycy9TZXJpYWxpemVkUHJvY2Vzc29yLmphdmE=) | `89.36% <0%> (-8.52%)` | `26% <0%> (-2%)` | |\n| [...in\/java\/io\/reactivex\/subjects\/BehaviorSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...6f6a1b4ec7407daf75ecfe301e96673eb98ea418?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvQmVoYXZpb3JTdWJqZWN0LmphdmE=) | `83.93% <0%> (-6.74%)` | `55% <0%> (-1%)` | |\n| [...ex\/internal\/operators\/maybe\/MaybeTimeoutMaybe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...6f6a1b4ec7407daf75ecfe301e96673eb98ea418?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlVGltZW91dE1heWJlLmphdmE=) | `94.11% <0%> (-4.42%)` | `2% <0%> (ø)` | |\n| [...erators\/completable\/CompletableConcatIterable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...6f6a1b4ec7407daf75ecfe301e96673eb98ea418?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0SXRlcmFibGUuamF2YQ==) | `95.91% <0%> (-4.09%)` | `2% <0%> (ø)` | |\n| [...ernal\/operators\/flowable\/FlowableFromIterable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...6f6a1b4ec7407daf75ecfe301e96673eb98ea418?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRnJvbUl0ZXJhYmxlLmphdmE=) | `94.11% <0%> (-3.75%)` | `5% <0%> (ø)` | |\n| [...internal\/operators\/completable\/CompletableAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...6f6a1b4ec7407daf75ecfe301e96673eb98ea418?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQW1iLmphdmE=) | `94.91% <0%> (-3.39%)` | `10% <0%> (-1%)` | |\n| [...ternal\/operators\/completable\/CompletableCache.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...6f6a1b4ec7407daf75ecfe301e96673eb98ea418?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ2FjaGUuamF2YQ==) | `96.96% <0%> (-3.04%)` | `23% <0%> (-1%)` | |\n| [...\/operators\/observable\/ObservableFlatMapSingle.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...6f6a1b4ec7407daf75ecfe301e96673eb98ea418?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXBTaW5nbGUuamF2YQ==) | `94.02% <0%> (-2.99%)` | `2% <0%> (ø)` | |\n| ... and [35 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5188?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5188?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5188?src=pr&el=footer). Last update [2d03fa9...6f6a1b4](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...6f6a1b4ec7407daf75ecfe301e96673eb98ea418?src=pr&el=footer&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."},{"date":"2017-03-15T15:53:05Z","author":"akarnokd","text":"`flatMap` is one of the few operators where it is extremely difficult to make sure certain lines get executed and this probabilistic nature may rarely manifest itself on the slow CI."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-03-16T08:26:14Z","description":"This PR fixes the case when `Flowable.flatMap` and `Observable.flatMap` would emit the `ExceptionHelper.TERMINTED` indicator exception to downstream due to emission-cancellation race.\r\n\r\nReported on [StackOverflow](http:\/\/stackoverflow.com\/questions\/42580195\/what-is-the-meaning-of-no-further-exceptions).","id":"214424619","title":"2.x: fix flatMap emitting the terminal exception indicator on cancel","opened_on":"2017-03-15T15:20:02Z","closed_by":"akarnokd"},{"number":"5187","reopenOn":null,"comments":[{"date":"2017-03-15T14:47:46Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5187?src=pr&el=h1) Report\n> Merging [#5187](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5187?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/2d03fa9711e8f4e99cfb8150c7043021002ac13e?src=pr&el=desc) will **increase** coverage by `0.05%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5187      +\/-   ##\n============================================\n+ Coverage     95.98%   96.04%   +0.05%     \n- Complexity     5665     5673       +8     \n============================================\n  Files           621      621              \n  Lines         40340    40581     +241     \n  Branches       5616     5620       +4     \n============================================\n+ Hits          38722    38975     +253     \n- Misses          638      641       +3     \n+ Partials        980      965      -15\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5187?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [src\/main\/java\/io\/reactivex\/Single.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...bd35fc70adc710d99d1e3e0d6d00d70808d4e45c?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvU2luZ2xlLmphdmE=) | `99.32% <100%> (+0.02%)` | `131 <12> (ø)` | :x: |\n| [...\/operators\/flowable\/FlowableBlockingSubscribe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...bd35fc70adc710d99d1e3e0d6d00d70808d4e45c?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlQmxvY2tpbmdTdWJzY3JpYmUuamF2YQ==) | `97.22% <100%> (+0.25%)` | `10 <1> (ø)` | :x: |\n| [src\/main\/java\/io\/reactivex\/Flowable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...bd35fc70adc710d99d1e3e0d6d00d70808d4e45c?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvRmxvd2FibGUuamF2YQ==) | `100% <100%> (ø)` | `522 <19> (ø)` | :x: |\n| [src\/main\/java\/io\/reactivex\/Observable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...bd35fc70adc710d99d1e3e0d6d00d70808d4e45c?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvT2JzZXJ2YWJsZS5qYXZh) | `100% <100%> (ø)` | `506 <46> (ø)` | :x: |\n| [src\/main\/java\/io\/reactivex\/Maybe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...bd35fc70adc710d99d1e3e0d6d00d70808d4e45c?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvTWF5YmUuamF2YQ==) | `100% <100%> (ø)` | `168 <10> (+1)` | :white_check_mark: |\n| [src\/main\/java\/io\/reactivex\/Completable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...bd35fc70adc710d99d1e3e0d6d00d70808d4e45c?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvQ29tcGxldGFibGUuamF2YQ==) | `100% <100%> (ø)` | `112 <1> (ø)` | :x: |\n| [...rators\/observable\/ObservableBlockingSubscribe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...bd35fc70adc710d99d1e3e0d6d00d70808d4e45c?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUJsb2NraW5nU3Vic2NyaWJlLmphdmE=) | `96.96% <100%> (+0.3%)` | `9 <1> (ø)` | :x: |\n| [...\/java\/io\/reactivex\/subscribers\/TestSubscriber.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...bd35fc70adc710d99d1e3e0d6d00d70808d4e45c?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3Vic2NyaWJlcnMvVGVzdFN1YnNjcmliZXIuamF2YQ==) | `99.27% <100%> (+0.01%)` | `57 <0> (+1)` | :white_check_mark: |\n| [...vex\/internal\/operators\/single\/SingleTakeUntil.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...bd35fc70adc710d99d1e3e0d6d00d70808d4e45c?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS9TaW5nbGVUYWtlVW50aWwuamF2YQ==) | `86.88% <0%> (-6.56%)` | `2% <0%> (ø)` | |\n| [...rnal\/subscriptions\/DeferredScalarSubscription.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...bd35fc70adc710d99d1e3e0d6d00d70808d4e45c?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaXB0aW9ucy9EZWZlcnJlZFNjYWxhclN1YnNjcmlwdGlvbi5qYXZh) | `93.84% <0%> (-4.62%)` | `27% <0%> (-1%)` | |\n| ... and [35 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5187?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5187?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5187?src=pr&el=footer). Last update [2d03fa9...bd35fc7](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2d03fa9711e8f4e99cfb8150c7043021002ac13e...bd35fc70adc710d99d1e3e0d6d00d70808d4e45c?el=footer&src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."},{"date":"2017-03-15T16:37:32Z","author":"akarnokd","text":"Thanks @vanniktech ! I'm merging this because there are a couple of inbound API changes from other contributors and having this in place avoids conflicts."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-03-15T16:37:37Z","description":"This PR adds a reflection-based parameter validator to check the base reactive classes for proper parameter validation: null checks and argument ranges. The problems detected are fixed as well.","id":"214406772","title":"2.x: reflection-based parameter validator & fixes","opened_on":"2017-03-15T14:28:18Z","closed_by":"akarnokd"},{"number":"5182","reopenOn":null,"comments":[{"date":"2017-03-13T23:47:12Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5182?src=pr&el=h1) Report\n> Merging [#5182](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5182?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/88c60b9a5b75b07fa23bac460b4a95f0a47bbeba?src=pr&el=desc) will **decrease** coverage by `0.03%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@             Coverage Diff             @@\n##                2.x   #5182      +\/-   ##\n===========================================\n- Coverage     96.04%     96%   -0.04%     \n- Complexity     5655    5665      +10     \n===========================================\n  Files           621     621              \n  Lines         40320   40336      +16     \n  Branches       5610    5616       +6     \n===========================================\n+ Hits          38725   38726       +1     \n- Misses          630     640      +10     \n- Partials        965     970       +5\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5182?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...\/internal\/operators\/flowable\/FlowableRefCount.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/88c60b9a5b75b07fa23bac460b4a95f0a47bbeba...c2f2435b35c99f36210f85bdad5ac9c0f5004cc0?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlUmVmQ291bnQuamF2YQ==) | `98.71% <100%> (+0.06%)` | `7 <0> (ø)` | :x: |\n| [...ernal\/operators\/observable\/ObservableRefCount.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/88c60b9a5b75b07fa23bac460b4a95f0a47bbeba...c2f2435b35c99f36210f85bdad5ac9c0f5004cc0?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVJlZkNvdW50LmphdmE=) | `98.68% <100%> (+0.07%)` | `7 <0> (ø)` | :x: |\n| [...nternal\/operators\/observable\/ObservableReplay.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/88c60b9a5b75b07fa23bac460b4a95f0a47bbeba...c2f2435b35c99f36210f85bdad5ac9c0f5004cc0?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVJlcGxheS5qYXZh) | `97.77% <100%> (-0.26%)` | `22 <4> (+3)` | |\n| [...ex\/internal\/operators\/flowable\/FlowableReplay.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/88c60b9a5b75b07fa23bac460b4a95f0a47bbeba...c2f2435b35c99f36210f85bdad5ac9c0f5004cc0?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlUmVwbGF5LmphdmE=) | `90.69% <100%> (+0.07%)` | `21 <4> (+4)` | :white_check_mark: |\n| [...al\/operators\/observable\/ObservableSampleTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/88c60b9a5b75b07fa23bac460b4a95f0a47bbeba...c2f2435b35c99f36210f85bdad5ac9c0f5004cc0?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVNhbXBsZVRpbWVkLmphdmE=) | `88.33% <0%> (-8.34%)` | `3% <0%> (ø)` | |\n| [...in\/java\/io\/reactivex\/subjects\/BehaviorSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/88c60b9a5b75b07fa23bac460b4a95f0a47bbeba...c2f2435b35c99f36210f85bdad5ac9c0f5004cc0?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvQmVoYXZpb3JTdWJqZWN0LmphdmE=) | `84.97% <0%> (-4.67%)` | `56% <0%> (+1%)` | |\n| [...a\/io\/reactivex\/internal\/util\/QueueDrainHelper.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/88c60b9a5b75b07fa23bac460b4a95f0a47bbeba...c2f2435b35c99f36210f85bdad5ac9c0f5004cc0?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvdXRpbC9RdWV1ZURyYWluSGVscGVyLmphdmE=) | `60.28% <0%> (-4.26%)` | `32% <0%> (-3%)` | |\n| [...rnal\/operators\/completable\/CompletableTimeout.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/88c60b9a5b75b07fa23bac460b4a95f0a47bbeba...c2f2435b35c99f36210f85bdad5ac9c0f5004cc0?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlVGltZW91dC5qYXZh) | `94% <0%> (-4%)` | `2% <0%> (ø)` | |\n| [...\/operators\/observable\/ObservableFlatMapSingle.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/88c60b9a5b75b07fa23bac460b4a95f0a47bbeba...c2f2435b35c99f36210f85bdad5ac9c0f5004cc0?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXBTaW5nbGUuamF2YQ==) | `92.53% <0%> (-3.74%)` | `2% <0%> (ø)` | |\n| [...reactivex\/internal\/operators\/single\/SingleAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/88c60b9a5b75b07fa23bac460b4a95f0a47bbeba...c2f2435b35c99f36210f85bdad5ac9c0f5004cc0?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS9TaW5nbGVBbWIuamF2YQ==) | `96.36% <0%> (-3.64%)` | `9% <0%> (-1%)` | |\n| ... and [33 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5182?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5182?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5182?src=pr&el=footer). Last update [88c60b9...c2f2435](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/88c60b9a5b75b07fa23bac460b4a95f0a47bbeba...c2f2435b35c99f36210f85bdad5ac9c0f5004cc0?el=footer&src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-03-14T08:57:08Z","description":"This PR updates `Observable.replay()` and `Flowable.replay()` **for 2.x** to not leak items between reconnections when run with `.refCount()`. The `replay()` operator is designed to hold onto the buffer even after its completion so late subscribers can still receive the cached data. Only a new `connect()` clears this data which may or may not happen. Since `refCount` ensures that there won't be any latecommers to an already completed connection (because it also drops its current subscribers on termination or when reaching zero), the `replay()` can be reset to an empty state.\r\n\r\nRelated: #5172, #5181.","id":"213922495","title":"2.x: fix replay().refCount() leaking items between connections","opened_on":"2017-03-13T23:02:59Z","closed_by":"akarnokd"},{"number":"5181","reopenOn":null,"comments":[{"date":"2017-03-13T22:04:28Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5181?src=pr&el=h1) Report\n> Merging [#5181](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5181?src=pr&el=desc) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/881183178e5f0d163052a4dd86569fbac1fb8bf1?src=pr&el=desc) will **increase** coverage by `0.02%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@             Coverage Diff              @@\n##                1.x    #5181      +\/-   ##\n============================================\n+ Coverage     84.33%   84.36%   +0.02%     \n- Complexity     2879     2882       +3     \n============================================\n  Files           290      290              \n  Lines         18107    18115       +8     \n  Branches       2475     2478       +3     \n============================================\n+ Hits          15270    15282      +12     \n+ Misses         1971     1962       -9     \n- Partials        866      871       +5\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5181?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...ava\/rx\/internal\/operators\/OnSubscribeRefCount.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/881183178e5f0d163052a4dd86569fbac1fb8bf1...c4221a650883081beb5fb33cc295b77814b0b2bf?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvT25TdWJzY3JpYmVSZWZDb3VudC5qYXZh) | `96.42% <100%> (+0.27%)` | `6 <0> (ø)` | :x: |\n| [...ain\/java\/rx\/internal\/operators\/OperatorReplay.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/881183178e5f0d163052a4dd86569fbac1fb8bf1...c4221a650883081beb5fb33cc295b77814b0b2bf?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JSZXBsYXkuamF2YQ==) | `82.77% <100%> (+0.13%)` | `15 <4> (+4)` | :white_check_mark: |\n| [...ain\/java\/rx\/internal\/schedulers\/SchedulerWhen.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/881183178e5f0d163052a4dd86569fbac1fb8bf1...c4221a650883081beb5fb33cc295b77814b0b2bf?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9zY2hlZHVsZXJzL1NjaGVkdWxlcldoZW4uamF2YQ==) | `83.78% <0%> (-4.06%)` | `4% <0%> (ø)` | |\n| [...n\/java\/rx\/subscriptions\/CompositeSubscription.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/881183178e5f0d163052a4dd86569fbac1fb8bf1...c4221a650883081beb5fb33cc295b77814b0b2bf?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9zdWJzY3JpcHRpb25zL0NvbXBvc2l0ZVN1YnNjcmlwdGlvbi5qYXZh) | `74.02% <0%> (-3.9%)` | `23% <0%> (-2%)` | |\n| [...n\/java\/rx\/internal\/operators\/CachedObservable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/881183178e5f0d163052a4dd86569fbac1fb8bf1...c4221a650883081beb5fb33cc295b77814b0b2bf?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvQ2FjaGVkT2JzZXJ2YWJsZS5qYXZh) | `83.69% <0%> (-1.64%)` | `6% <0%> (ø)` | |\n| [...\/rx\/internal\/schedulers\/CachedThreadScheduler.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/881183178e5f0d163052a4dd86569fbac1fb8bf1...c4221a650883081beb5fb33cc295b77814b0b2bf?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9zY2hlZHVsZXJzL0NhY2hlZFRocmVhZFNjaGVkdWxlci5qYXZh) | `87.37% <0%> (-0.98%)` | `6% <0%> (ø)` | |\n| [...main\/java\/rx\/internal\/operators\/OperatorMerge.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/881183178e5f0d163052a4dd86569fbac1fb8bf1...c4221a650883081beb5fb33cc295b77814b0b2bf?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JNZXJnZS5qYXZh) | `86.6% <0%> (-0.47%)` | `7% <0%> (ø)` | |\n| [...ternal\/operators\/OperatorOnBackpressureLatest.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/881183178e5f0d163052a4dd86569fbac1fb8bf1...c4221a650883081beb5fb33cc295b77814b0b2bf?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JPbkJhY2twcmVzc3VyZUxhdGVzdC5qYXZh) | `82.85% <0%> (+1.9%)` | `3% <0%> (ø)` | :x: |\n| [...java\/rx\/internal\/schedulers\/ExecutorScheduler.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/881183178e5f0d163052a4dd86569fbac1fb8bf1...c4221a650883081beb5fb33cc295b77814b0b2bf?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9zY2hlZHVsZXJzL0V4ZWN1dG9yU2NoZWR1bGVyLmphdmE=) | `81.69% <0%> (+4.22%)` | `2% <0%> (ø)` | :x: |\n| [...ain\/java\/rx\/internal\/operators\/OnSubscribeAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/881183178e5f0d163052a4dd86569fbac1fb8bf1...c4221a650883081beb5fb33cc295b77814b0b2bf?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvT25TdWJzY3JpYmVBbWIuamF2YQ==) | `84.17% <0%> (+5.03%)` | `13% <0%> (ø)` | :x: |\n| ... and [1 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5181?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5181?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5181?src=pr&el=footer). Last update [8811831...c4221a6](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/881183178e5f0d163052a4dd86569fbac1fb8bf1...c4221a650883081beb5fb33cc295b77814b0b2bf?el=footer&src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-03-15T16:31:09Z","description":"This PR updates `replay()` to not leak items between reconnections when run with `.refCount()`. The `replay()` operator is designed to hold onto the buffer even after its completion so late subscribers can still receive the cached data. Only a new `connect()` clears this data which may or may not happen. Since `refCount` ensures that there won't be any latecommers to an already completed connection (because it also drops its current subscribers on termination or when reaching zero), the `replay()` can be reset to an empty state.\r\n\r\nReported in #5172 \r\n","id":"213909059","title":"1.x: replay().refCount() avoid leaking items between connections","opened_on":"2017-03-13T21:54:55Z","closed_by":"akarnokd"},{"number":"5170","reopenOn":null,"comments":[{"date":"2017-03-10T08:55:41Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5170?src=pr&el=h1) Report\n> Merging [#5170](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5170?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/b5501c5630c05b9add97b7b3b0f352adfd8d28fa?src=pr&el=desc) will **decrease** coverage by `<.01%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5170      +\/-   ##\n============================================\n- Coverage     95.94%   95.94%   -0.01%     \n+ Complexity     5658     5656       -2     \n============================================\n  Files           621      621              \n  Lines         39972    39974       +2     \n  Branches       5610     5610              \n============================================\n  Hits          38352    38352              \n+ Misses          643      642       -1     \n- Partials        977      980       +3\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5170?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [src\/main\/java\/io\/reactivex\/Observable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b5501c5630c05b9add97b7b3b0f352adfd8d28fa...b9942bbbf715fed6037ce5afbdb22ba3824bb9b2?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvT2JzZXJ2YWJsZS5qYXZh) | `100% <ø> (ø)` | `506 <0> (ø)` | :x: |\n| [...operators\/observable\/ObservableInternalHelper.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b5501c5630c05b9add97b7b3b0f352adfd8d28fa...b9942bbbf715fed6037ce5afbdb22ba3824bb9b2?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUludGVybmFsSGVscGVyLmphdmE=) | `86.31% <ø> (ø)` | `18 <0> (ø)` | :x: |\n| [...o\/reactivex\/internal\/observers\/LambdaObserver.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b5501c5630c05b9add97b7b3b0f352adfd8d28fa...b9942bbbf715fed6037ce5afbdb22ba3824bb9b2?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb2JzZXJ2ZXJzL0xhbWJkYU9ic2VydmVyLmphdmE=) | `100% <100%> (ø)` | `12 <0> (ø)` | :x: |\n| [...al\/operators\/observable\/ObservableSampleTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b5501c5630c05b9add97b7b3b0f352adfd8d28fa...b9942bbbf715fed6037ce5afbdb22ba3824bb9b2?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVNhbXBsZVRpbWVkLmphdmE=) | `88.33% <0%> (-8.34%)` | `3% <0%> (ø)` | |\n| [...\/java\/io\/reactivex\/subjects\/SerializedSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b5501c5630c05b9add97b7b3b0f352adfd8d28fa...b9942bbbf715fed6037ce5afbdb22ba3824bb9b2?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvU2VyaWFsaXplZFN1YmplY3QuamF2YQ==) | `89.47% <0%> (-6.32%)` | `26% <0%> (-1%)` | |\n| [...l\/operators\/observable\/ObservableFlatMapMaybe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b5501c5630c05b9add97b7b3b0f352adfd8d28fa...b9942bbbf715fed6037ce5afbdb22ba3824bb9b2?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXBNYXliZS5qYXZh) | `89.54% <0%> (-5.89%)` | `2% <0%> (ø)` | |\n| [...ternal\/operators\/completable\/CompletableUsing.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b5501c5630c05b9add97b7b3b0f352adfd8d28fa...b9942bbbf715fed6037ce5afbdb22ba3824bb9b2?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlVXNpbmcuamF2YQ==) | `95.23% <0%> (-4.77%)` | `4% <0%> (ø)` | |\n| [...a\/io\/reactivex\/internal\/util\/QueueDrainHelper.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b5501c5630c05b9add97b7b3b0f352adfd8d28fa...b9942bbbf715fed6037ce5afbdb22ba3824bb9b2?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvdXRpbC9RdWV1ZURyYWluSGVscGVyLmphdmE=) | `60.28% <0%> (-4.26%)` | `32% <0%> (-3%)` | |\n| [...\/operators\/observable\/ObservableFlatMapSingle.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b5501c5630c05b9add97b7b3b0f352adfd8d28fa...b9942bbbf715fed6037ce5afbdb22ba3824bb9b2?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXBTaW5nbGUuamF2YQ==) | `91.79% <0%> (-3.74%)` | `2% <0%> (ø)` | |\n| [...ava\/io\/reactivex\/internal\/util\/HalfSerializer.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b5501c5630c05b9add97b7b3b0f352adfd8d28fa...b9942bbbf715fed6037ce5afbdb22ba3824bb9b2?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvdXRpbC9IYWxmU2VyaWFsaXplci5qYXZh) | `97.5% <0%> (-2.5%)` | `22% <0%> (-1%)` | |\n| ... and [32 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5170?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5170?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5170?src=pr&el=footer). Last update [b5501c5...b9942bb](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b5501c5630c05b9add97b7b3b0f352adfd8d28fa...b9942bbbf715fed6037ce5afbdb22ba3824bb9b2?el=footer&src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-03-10T17:22:23Z","description":"The `LambdaObserver` didn't cancel the upstream when its `onSubscribe` and `onNext` callbacks crashed. Also reported on the mailing list:\r\n\r\n> Dave Smith: When I am using an operator in Observable that calls subscribe (forEach as a example) and the onNext function throws an Exception the underlying class (LambdaObserver) marks the subscription disposed but does not notify upstream that is is disposed. What is the reason for this?\r\n\r\nThe `LambdaSubscriber` was working correctly. Both received unit tests to ensure the correct behavior.","id":"213278157","title":"2.x: fix LambdaObserver not cancelling the upstream","opened_on":"2017-03-10T08:41:49Z","closed_by":"akarnokd"},{"number":"5169","reopenOn":null,"comments":[{"date":"2017-03-09T14:45:26Z","author":"akarnokd","text":"Hi. It is possible but I can't really read Groovy\/Spock code. The resolution could be to remove the set and have the individual Disposables there. PR welcome (also check of Maybe is needed as well)."},{"date":"2017-03-15T14:59:27Z","author":"gaganis","text":"Hi @janbols, I have tried running your Spock speck in a fresh project with just a dependency to `io.reactivex.rxjava2:rxjava:2.0.6` and it did not fail.\r\n\r\nThis is weird, and the only thing that you might be running something before this spec that might impact this. Could you provide more info?\r\n\r\n"},{"date":"2017-03-20T19:38:27Z","author":"akarnokd","text":"PR #5207 should resolve this case as well."},{"date":"2017-03-22T19:48:00Z","author":"janbols","text":"Excellent. Indeed that would solve it. Thanks"},{"date":"2017-03-22T19:51:45Z","author":"janbols","text":"Hi @gaganis , yes indeed the test succeeds. That's intentional because the feature methods indicating the bug are annotated with [`FailsWith`](http:\/\/spockframework.org\/spock\/javadoc\/1.0\/spock\/lang\/FailsWith.html). They will start failing once the bug is fixed, indicating that the annotation can be removed.\r\n\r\nBest regards\r\nJan"},{"date":"2017-03-22T20:33:54Z","author":"gaganis","text":"I am new to spock so I missed that! Thanks @janbols for the clarification! "},{"date":"2017-03-29T08:59:25Z","author":"akarnokd","text":"@janbols RxJava 2.0.8 has been released with fixes to the schedulers. Could you verify the issue is resolved for you?"},{"date":"2017-03-29T09:07:49Z","author":"janbols","text":"Hi @akarnokd , \r\ncommenting out the `FailsWith` annotation on my unit tests, made them pass. In spock-speak this means the bug is fixed indeed. \r\n\r\nThanks for all the work. I'll close the issue."}],"opened_by":"janbols","reopen":false,"closed_on":"2017-03-29T09:07:49Z","description":"Hi, I'm running `io.reactivex.rxjava2:rxjava:2.0.6` .\r\n\r\nWhen doing the following, the thread running the otherSingleSource has its interrupted flag set. This throws` java.lang.InterruptedException`s. Below, you can find an example:\r\n````\r\nSingle.timer(3, TimeUnit.SECONDS)\r\n                .timeout(1, TimeUnit.SECONDS, Single.fromCallable { return Long.MAX_VALUE })\r\n                .blockingGet()\r\n````\r\n\r\nThe thread that runs `return Long.MAX_VALUE` is interrupted.  You can find a unit test using spock on https:\/\/gist.github.com\/janbols\/e97ceb349641f58895379ff562aab59b\r\n\r\nThe same effect is observed when we call `timeout `with an explicit scheduler. The only way I could make this working is by subscribing the otherSingleSource on another thread like the following:\r\n````\r\nSingle.timer(3, TimeUnit.SECONDS)\r\n                .timeout(1, TimeUnit.SECONDS, Single.fromCallable { return Long.MAX_VALUE }).subscribeOn(io())\r\n                .blockingGet()\r\n````\r\n\r\n\r\nI tried to debug the code and I think it has something to do with the call to `set.clear()` inside the runnable when the timer expires in `io.reactivex.internal.operators.single.SingleTimeout#subscribeActual`. At that time `set` contains the `timer` disposable and by clearing it, you're also interrupting the thread that's running the task in `io.reactivex.internal.schedulers.ScheduledRunnable#dispose`.\r\n\r\nOf course I could be completely wrong as well since thread scheduling isn't really my cup of tea :-).","id":"213053549","title":"Thread running otherSingleSource of a timeout is interrupted before running","opened_on":"2017-03-09T14:30:17Z","closed_by":"janbols"},{"number":"5163","reopenOn":null,"comments":[{"date":"2017-03-08T10:42:17Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5163?src=pr&el=h1) Report\n> Merging [#5163](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5163?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/23b46f5b83eabebff15fbfbb4b471cde93706b81?src=pr&el=desc) will **decrease** coverage by `-0.02%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5163      +\/-   ##\n============================================\n- Coverage     95.97%   95.95%   -0.02%     \n+ Complexity     5655     5653       -2     \n============================================\n  Files           621      621              \n  Lines         39960    39962       +2     \n  Branches       5610     5610              \n============================================\n- Hits          38351    38345       -6     \n- Misses          628      648      +20     \n+ Partials        981      969      -12\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5163?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...vex\/internal\/observers\/ConsumerSingleObserver.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/23b46f5b83eabebff15fbfbb4b471cde93706b81...2f7fa979acb84c51767ae688546e22861b72a350?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb2JzZXJ2ZXJzL0NvbnN1bWVyU2luZ2xlT2JzZXJ2ZXIuamF2YQ==) | `100% <100%> (ø)` | `7 <2> (ø)` | :x: |\n| [...in\/java\/io\/reactivex\/subjects\/BehaviorSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/23b46f5b83eabebff15fbfbb4b471cde93706b81...2f7fa979acb84c51767ae688546e22861b72a350?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvQmVoYXZpb3JTdWJqZWN0LmphdmE=) | `83.93% <0%> (-6.74%)` | `55% <0%> (-1%)` | |\n| [...rnal\/subscriptions\/ArrayCompositeSubscription.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/23b46f5b83eabebff15fbfbb4b471cde93706b81...2f7fa979acb84c51767ae688546e22861b72a350?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaXB0aW9ucy9BcnJheUNvbXBvc2l0ZVN1YnNjcmlwdGlvbi5qYXZh) | `93.33% <0%> (-6.67%)` | `17% <0%> (-1%)` | |\n| [...\/operators\/completable\/CompletableConcatArray.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/23b46f5b83eabebff15fbfbb4b471cde93706b81...2f7fa979acb84c51767ae688546e22861b72a350?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0QXJyYXkuamF2YQ==) | `93.75% <0%> (-6.25%)` | `2% <0%> (ø)` | |\n| [...ava\/io\/reactivex\/processors\/BehaviorProcessor.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/23b46f5b83eabebff15fbfbb4b471cde93706b81...2f7fa979acb84c51767ae688546e22861b72a350?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcHJvY2Vzc29ycy9CZWhhdmlvclByb2Nlc3Nvci5qYXZh) | `86.44% <0%> (-6.08%)` | `55% <0%> (-1%)` | |\n| [...ernal\/operators\/maybe\/MaybeTakeUntilPublisher.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/23b46f5b83eabebff15fbfbb4b471cde93706b81...2f7fa979acb84c51767ae688546e22861b72a350?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlVGFrZVVudGlsUHVibGlzaGVyLmphdmE=) | `96% <0%> (-4%)` | `2% <0%> (ø)` | |\n| [...rnal\/operators\/flowable\/FlowableTakeLastTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/23b46f5b83eabebff15fbfbb4b471cde93706b81...2f7fa979acb84c51767ae688546e22861b72a350?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlVGFrZUxhc3RUaW1lZC5qYXZh) | `96.29% <0%> (-2.78%)` | `2% <0%> (ø)` | |\n| [...main\/java\/io\/reactivex\/subjects\/SingleSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/23b46f5b83eabebff15fbfbb4b471cde93706b81...2f7fa979acb84c51767ae688546e22861b72a350?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvU2luZ2xlU3ViamVjdC5qYXZh) | `95.23% <0%> (-2.39%)` | `38% <0%> (-1%)` | |\n| [...operators\/observable\/ObservableConcatMapEager.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/23b46f5b83eabebff15fbfbb4b471cde93706b81...2f7fa979acb84c51767ae688546e22861b72a350?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUNvbmNhdE1hcEVhZ2VyLmphdmE=) | `97.29% <0%> (-2.17%)` | `2% <0%> (ø)` | |\n| [...\/internal\/operators\/maybe\/MaybeTakeUntilMaybe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/23b46f5b83eabebff15fbfbb4b471cde93706b81...2f7fa979acb84c51767ae688546e22861b72a350?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlVGFrZVVudGlsTWF5YmUuamF2YQ==) | `95.91% <0%> (-2.05%)` | `2% <0%> (ø)` | |\n| ... and [35 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5163?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5163?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5163?src=pr&el=footer). Last update [23b46f5...2f7fa97](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/23b46f5b83eabebff15fbfbb4b471cde93706b81...2f7fa979acb84c51767ae688546e22861b72a350?src=pr&el=footer&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-03-08T17:05:18Z","description":"The `ConsumerSingleObserver` didn't report `isDisposed` consistently with its state.\r\n\r\nReported in #5160.","id":"212695279","title":"2.x: Single.subscribe() to report isDisposed() true on success\/error","opened_on":"2017-03-08T10:27:07Z","closed_by":"akarnokd"},{"number":"5160","reopenOn":null,"comments":[{"date":"2017-03-08T10:27:42Z","author":"akarnokd","text":"Thanks for reporting. It looks like a simple oversight since the tests pass when I add the `lazySet`s. See #5163."},{"date":"2017-03-08T17:05:41Z","author":"akarnokd","text":"Closing via #5163."}],"opened_by":"kxfeng","reopen":false,"closed_on":"2017-03-08T17:05:41Z","description":"When using Single.subscribe(onSuccess, onError) , the returned Disposable is not disposed after terminal event. However , for Observable, Flowable, Maybe and Completable , the results are all disposed.\r\n\r\nHere is the test code: \r\n```java\r\n@Test\r\npublic void testDisposable() throws Exception {\r\n\r\n\tDisposable disposable;\r\n\r\n\tdisposable = Single.just(1).subscribe(\r\n\t\tnext -> System.out.println(\"Single Success\"),\r\n\t\terror -> System.out.println(\"Single Error\")\r\n\t);\r\n\r\n\tSystem.out.println(\"Single Disposed: \" + disposable.isDisposed());\r\n\r\n\tdisposable = Observable.just(1).subscribe(\r\n\t\tnext -> System.out.println(\"Observable Next\"),\r\n\t\terror -> System.out.println(\"Observable Error\"),\r\n\t\t() -> System.out.println(\"Observable Complete\")\r\n\t);\r\n\r\n\tSystem.out.println(\"Observable Disposed: \" + disposable.isDisposed());\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\nSingle Success\r\nSingle Disposed: false\r\n\r\nObservable Next\r\nObservable Complete\r\nObservable Disposed: true\r\n```\r\n\r\nI found the Disposeable not lazySet to DISPOSED in  ConsumerSingleObserver compared with LambdaObserver. Is this a bug or there are some special reasons to do this?\r\n\r\n\r\n```java\r\nConsumerSingleObserver\r\n\r\n@Override\r\npublic void onSuccess(T value) {\r\n\ttry {\r\n\t\tonSuccess.accept(value);\r\n\t} catch (Throwable ex) {\r\n\t\tExceptions.throwIfFatal(ex);\r\n\t\tRxJavaPlugins.onError(ex);\r\n\t}\r\n}\r\n```\r\n\r\n```java\r\nLambdaObserver\r\n\r\n@Override\r\npublic void onComplete() {\r\n\tif (!isDisposed()) {\r\n\t\tlazySet(DisposableHelper.DISPOSED);\r\n\t\ttry {\r\n\t\t\tonComplete.run();\r\n\t\t} catch (Throwable e) {\r\n\t\t\tExceptions.throwIfFatal(e);\r\n\t\t\tRxJavaPlugins.onError(e);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nRxJava 2.0.6","id":"212678373","title":"2.x: Disposable returned from Single.subscribe() is not disposed after terminal event","opened_on":"2017-03-08T09:15:56Z","closed_by":"akarnokd"},{"number":"5141","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-27T18:25:54Z","description":"The timed `replay()` operator didn't terminate a late subscriber if all the items timed out in the meantime.\r\n\r\nRelated: #5139.","id":"210563749","title":"1.x: fix timed replay() not terminating when all items timeout","opened_on":"2017-02-27T18:16:10Z","closed_by":"akarnokd"},{"number":"5140","reopenOn":null,"comments":[{"date":"2017-02-27T14:55:02Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5140?src=pr&el=h1) Report\n> Merging [#5140](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5140?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/a03bf90c19e0eed80c677eb0e3071079220fd392?src=pr&el=desc) will **decrease** coverage by `-0.01%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5140      +\/-   ##\n============================================\n- Coverage     95.96%   95.96%   -0.01%     \n+ Complexity     5611     5601      -10     \n============================================\n  Files           620      620              \n  Lines         39820    39850      +30     \n  Branches       5599     5603       +4     \n============================================\n+ Hits          38215    38242      +27     \n  Misses          633      633              \n- Partials        972      975       +3\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5140?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...\/java\/io\/reactivex\/processors\/ReplayProcessor.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a03bf90c19e0eed80c677eb0e3071079220fd392...6377b58f99ce270c71c0704c0b601c784d9ef6ed?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcHJvY2Vzc29ycy9SZXBsYXlQcm9jZXNzb3IuamF2YQ==) | `98.76% <100%> (ø)` | `49 <0> (ø)` | :x: |\n| [...ex\/internal\/operators\/flowable\/FlowableReplay.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a03bf90c19e0eed80c677eb0e3071079220fd392...6377b58f99ce270c71c0704c0b601c784d9ef6ed?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlUmVwbGF5LmphdmE=) | `90.09% <100%> (+0.32%)` | `17 <0> (ø)` | :x: |\n| [...main\/java\/io\/reactivex\/subjects\/ReplaySubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a03bf90c19e0eed80c677eb0e3071079220fd392...6377b58f99ce270c71c0704c0b601c784d9ef6ed?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvUmVwbGF5U3ViamVjdC5qYXZh) | `97.11% <100%> (-0.22%)` | `51 <0> (ø)` | |\n| [...nternal\/operators\/observable\/ObservableReplay.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a03bf90c19e0eed80c677eb0e3071079220fd392...6377b58f99ce270c71c0704c0b601c784d9ef6ed?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVJlcGxheS5qYXZh) | `96.96% <100%> (-1.14%)` | `18 <0> (ø)` | |\n| [...rnal\/subscriptions\/ArrayCompositeSubscription.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a03bf90c19e0eed80c677eb0e3071079220fd392...6377b58f99ce270c71c0704c0b601c784d9ef6ed?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaXB0aW9ucy9BcnJheUNvbXBvc2l0ZVN1YnNjcmlwdGlvbi5qYXZh) | `93.33% <0%> (-6.67%)` | `17% <0%> (-1%)` | |\n| [...ternal\/operators\/completable\/CompletableUsing.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a03bf90c19e0eed80c677eb0e3071079220fd392...6377b58f99ce270c71c0704c0b601c784d9ef6ed?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlVXNpbmcuamF2YQ==) | `95.23% <0%> (-4.77%)` | `4% <0%> (ø)` | |\n| [...erators\/completable\/CompletableConcatIterable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a03bf90c19e0eed80c677eb0e3071079220fd392...6377b58f99ce270c71c0704c0b601c784d9ef6ed?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0SXRlcmFibGUuamF2YQ==) | `95.91% <0%> (-4.09%)` | `2% <0%> (ø)` | |\n| [...io\/reactivex\/internal\/util\/BackpressureHelper.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a03bf90c19e0eed80c677eb0e3071079220fd392...6377b58f99ce270c71c0704c0b601c784d9ef6ed?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvdXRpbC9CYWNrcHJlc3N1cmVIZWxwZXIuamF2YQ==) | `95.91% <0%> (-4.09%)` | `21% <0%> (-1%)` | |\n| [...internal\/operators\/completable\/CompletableAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a03bf90c19e0eed80c677eb0e3071079220fd392...6377b58f99ce270c71c0704c0b601c784d9ef6ed?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQW1iLmphdmE=) | `94.44% <0%> (-3.71%)` | `10% <0%> (-1%)` | |\n| [...reactivex\/internal\/operators\/single\/SingleAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a03bf90c19e0eed80c677eb0e3071079220fd392...6377b58f99ce270c71c0704c0b601c784d9ef6ed?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS9TaW5nbGVBbWIuamF2YQ==) | `96.36% <0%> (-3.64%)` | `9% <0%> (-1%)` | |\n| ... and [37 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5140?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5140?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5140?src=pr&el=footer). Last update [a03bf90...6377b58](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a03bf90c19e0eed80c677eb0e3071079220fd392...6377b58f99ce270c71c0704c0b601c784d9ef6ed?el=footer&src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-27T17:10:17Z","description":"The timed versions of `Flowable.replay()`, `ReplayProcessor`, `Observable.replay()` and `ReplaySubject` all replay outdated items to new subscribers and through the `getValues()` and `size()` state-peeking methods, similar to issue #3917 resolved via #4023.\r\n\r\nThe fix includes a node-walk for new subscribers that skips old entries. Some unit tests weren't logically considering the emission pattern (i.e., items timed out shouldn't appear) and have been fixed as well.\r\n\r\nReported in #5139.","id":"210501814","title":"2.x: fix timed replay-like components replaying outdated items","opened_on":"2017-02-27T14:38:06Z","closed_by":"akarnokd"},{"number":"5139","reopenOn":null,"comments":[{"date":"2017-02-27T14:27:16Z","author":"akarnokd","text":"Hi and thanks for reporting. Indeed this is a bug that was not resolved in 2.x:\r\n\r\n```java\r\nio.reactivex.schedulers.TestScheduler scheduler = new io.reactivex.schedulers.TestScheduler();\r\n        \r\nio.reactivex.Observable<Integer> source = io.reactivex.Observable.just(3)\r\n                .replay(2, TimeUnit.SECONDS, scheduler)\r\n                .autoConnect();\r\n\r\nsource.test().assertResult(3);\r\n\r\nsource.test().assertResult(3);\r\n\r\nscheduler.advanceTimeBy(3, TimeUnit.SECONDS);\r\n\r\nsource.test().assertResult();\r\n```\r\n\r\nThe timed versions of `Flowable.replay()`, `ReplayProcessor`, `Observable.replay()` and `ReplaySubject` are all affected.\r\n\r\n and appears to be partially broken in 1.x:\r\n\r\n```java\r\nrx.schedulers.TestScheduler scheduler = new rx.schedulers.TestScheduler();\r\n        \r\nrx.Observable<Integer> source = rx.Observable.just(1)\r\n                .replay(2, TimeUnit.SECONDS, scheduler)\r\n                .autoConnect();\r\n\r\nsource.test().assertResult(1);\r\n\r\nsource.test().assertResult(1);\r\n\r\nscheduler.advanceTimeBy(3, TimeUnit.SECONDS);\r\n\r\nsource.test().assertResult();\r\n```\r\n\r\nfails on the last line with `Not completed!`.\r\n\r\nI'll post the fixes for the respective versions shortly."},{"date":"2017-02-27T18:26:41Z","author":"akarnokd","text":"Closing via #5140 & #5141."}],"opened_by":"adevhere","reopen":false,"closed_on":"2017-02-27T18:26:41Z","description":" - Using RxJava 2.0.6\r\n\r\nIt seems [this issue](https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3917) is still present in RxJava 2. When late subscribers `subscribe()` to a source with `replay(time, unit)` that has already expired, the source still emits the \"expired emission\" if `onNext()` is not called.\r\n\r\nPosted this originally on [StackOverflow](http:\/\/stackoverflow.com\/questions\/42486432\/rxjavas-replaytime-unit-is-replaying-expired-emissions-is-that-the-expect) but I'm now referencing it here because it seems to be an issue with the library.","id":"210484675","title":"2.x: replay() seems to be still replaying old data for late subscribers","opened_on":"2017-02-27T13:34:03Z","closed_by":"akarnokd"},{"number":"5136","reopenOn":null,"comments":[{"date":"2017-02-25T10:41:03Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5136?src=pr&el=h1) Report\n> :exclamation: No coverage uploaded for pull request base (`2.x@2a4b18e`). [Click here to learn what that means](https:\/\/docs.codecov.io\/docs\/error-reference#section-missing-base-commit).\n> The diff coverage is `n\/a`.\n\n\n```diff\n@@          Coverage Diff           @@\n##             2.x    #5136   +\/-   ##\n======================================\n  Coverage       ?   95.81%           \n  Complexity     ?     5601           \n======================================\n  Files          ?      620           \n  Lines          ?    39820           \n  Branches       ?     5599           \n======================================\n  Hits           ?    38154           \n  Misses         ?      672           \n  Partials       ?      994\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5136?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [src\/main\/java\/io\/reactivex\/Flowable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2a4b18e743f0958551f4e31fdf81e618cc35f238...d7bd221e9977238fcb33b3a2fc602cf6198ebb93?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvRmxvd2FibGUuamF2YQ==) | `100% <ø> (ø)` | `522 <ø> (?)` | |\n| [src\/main\/java\/io\/reactivex\/Single.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2a4b18e743f0958551f4e31fdf81e618cc35f238...d7bd221e9977238fcb33b3a2fc602cf6198ebb93?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvU2luZ2xlLmphdmE=) | `99.29% <ø> (ø)` | `131 <ø> (?)` | |\n| [src\/main\/java\/io\/reactivex\/Completable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2a4b18e743f0958551f4e31fdf81e618cc35f238...d7bd221e9977238fcb33b3a2fc602cf6198ebb93?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvQ29tcGxldGFibGUuamF2YQ==) | `100% <ø> (ø)` | `112 <ø> (?)` | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5136?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5136?src=pr&el=footer). Last update [2a4b18e...d7bd221](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2a4b18e743f0958551f4e31fdf81e618cc35f238...d7bd221e9977238fcb33b3a2fc602cf6198ebb93?el=footer&src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-25T20:48:22Z","description":"Adjust the `repeatWhen` and `retryWhen` signatures to accept `Publisher<?>` on `Single` and `Completable`, matching `Flowable`'s signature.\r\n\r\nReported in #5135.","id":"210226423","title":"2.x: fix repeatWhen and retryWhen signatures","opened_on":"2017-02-25T10:27:53Z","closed_by":"akarnokd"},{"number":"5135","reopenOn":null,"comments":[{"date":"2017-02-24T20:07:13Z","author":"HolySamosa","text":"@akarnokd Sorry, I accidentally submitted the issue without my description.  Now fixed. This isn't a crosspost, but appears to be a bug."},{"date":"2017-02-24T20:12:37Z","author":"akarnokd","text":"You have the wrong return type argument in the first case. Either change it to `?` or `Throwable`."},{"date":"2017-02-24T20:58:52Z","author":"HolySamosa","text":"@akarnokd  Aren't the `Completable` `runwith` Function argument and return types incompatible?\r\n\r\n    public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<Object>> handler) \r\n\r\nSo the following `retryWith` lambda:\r\n\r\n        Completable.error(new RuntimeException())\r\n                .retryWhen(throwableFlowable -> throwableFlowable.delay(5, TimeUnit.SECONDS); \r\n\r\nproduces the error:\r\n\r\n    Bad return type in lambda expression: Flowable<Throwable> cannot be converted to Publisher<Object>\r\n\r\n"},{"date":"2017-02-24T21:26:53Z","author":"akarnokd","text":"Thanks, I see he issue now. Indeed, the Completable and Single signature for retryWhen is different from the others. `repeatWhen` is also off. Would you like to submit a PR?"},{"date":"2017-02-24T21:58:34Z","author":"HolySamosa","text":"Sure, I can do that.  \r\n\r\nQuestion:  Should the function return type be `Publisher<?>` or `CompletableSource<?>` \/  `SingleSource<?>` ?   `Flowable` and `Observable` differ in this regard."},{"date":"2017-02-24T22:26:23Z","author":"akarnokd","text":"I'd like to encourage you to think about that a bit."},{"date":"2017-02-24T23:00:47Z","author":"akarnokd","text":"Two hints:\r\n- you'd want to retry multiple times\r\n- you'd want to avoid ClassCastException on existing operator users"},{"date":"2017-02-25T20:48:36Z","author":"akarnokd","text":"Closing via #5136."}],"opened_by":"HolySamosa","reopen":false,"closed_on":"2017-02-25T20:48:36Z","description":"When I attempt to use `retryWhen` to delay a retry with `Completable` or `Single` I receive an _incompatible types_ error, as demonstrated in the following code:\r\n            \r\n            Completable.error(new RuntimeException())\r\n                    .retryWhen(new Function<Flowable<Throwable>, Publisher<Object>>() {\r\n                        @Override\r\n                        public Publisher<Object> apply(@io.reactivex.annotations.NonNull Flowable<Throwable> source) throws Exception {\r\n                            return source.delay(5, TimeUnit.SECONDS); \/\/ <- Incompatible type error\r\n                        }\r\n                    });\r\n            \r\n            Single.error(new RuntimeException())\r\n                    .retryWhen(new Function<Flowable<Throwable>, Publisher<Object>>() {\r\n                        @Override\r\n                        public Publisher<Object> apply(@io.reactivex.annotations.NonNull Flowable<Throwable> source) throws Exception {\r\n                            return source.delay(5, TimeUnit.SECONDS); \/\/ <- Incompatible type error\r\n                        }\r\n                    });\r\n\r\n\r\nHowever, there are no issues with `Observable` or `Flowable`:\r\n\r\n            Observable.error(new RuntimeException())\r\n                    .retryWhen(new Function<Observable<Throwable>, ObservableSource<?>>() {\r\n                        @Override\r\n                        public ObservableSource<?> apply(@io.reactivex.annotations.NonNull Observable<Throwable> source) throws Exception {\r\n                            return source.delay(5, TimeUnit.SECONDS);\r\n                        }\r\n                    });\r\n            Flowable.error(new RuntimeException())\r\n                    .retryWhen(new Function<Flowable<Throwable>, Publisher<?>>() {\r\n                        @Override\r\n                        public Publisher<?> apply(@io.reactivex.annotations.NonNull Flowable<Throwable> source) throws Exception {\r\n                            return source.delay(5, TimeUnit.SECONDS);\r\n                        }\r\n                    });\r\n\r\nLooks like there is an issue with the return types for `apply`?","id":"210143314","title":"retryWhen method signature for with Completable and Single","opened_on":"2017-02-24T19:56:59Z","closed_by":"akarnokd"},{"number":"5133","reopenOn":null,"comments":[{"date":"2017-02-24T09:53:23Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5133?src=pr&el=h1) Report\n> Merging [#5133](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5133?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/7494a2c05cf2f02142fc3193682141826974661a?src=pr&el=desc) will **increase** coverage by `0.02%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5133      +\/-   ##\n============================================\n+ Coverage     95.92%   95.94%   +0.02%     \n+ Complexity     5608     5601       -7     \n============================================\n  Files           620      620              \n  Lines         39810    39820      +10     \n  Branches       5597     5599       +2     \n============================================\n+ Hits          38186    38207      +21     \n+ Misses          651      640      -11     \n  Partials        973      973\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5133?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...x\/internal\/operators\/flowable\/FlowableFlatMap.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7494a2c05cf2f02142fc3193682141826974661a...6457c110f57f728a7e38a9a9c31b39e25439c1d7?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRmxhdE1hcC5qYXZh) | `88% <100%> (+0.05%)` | `4 <ø> (ø)` | :x: |\n| [...a\/io\/reactivex\/processors\/SerializedProcessor.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7494a2c05cf2f02142fc3193682141826974661a...6457c110f57f728a7e38a9a9c31b39e25439c1d7?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcHJvY2Vzc29ycy9TZXJpYWxpemVkUHJvY2Vzc29yLmphdmE=) | `91.48% <ø> (-6.39%)` | `27% <ø> (-1%)` | |\n| [...\/operators\/completable\/CompletableConcatArray.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7494a2c05cf2f02142fc3193682141826974661a...6457c110f57f728a7e38a9a9c31b39e25439c1d7?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0QXJyYXkuamF2YQ==) | `93.75% <ø> (-6.25%)` | `2% <ø> (ø)` | |\n| [...\/internal\/operators\/maybe\/MaybeTakeUntilMaybe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7494a2c05cf2f02142fc3193682141826974661a...6457c110f57f728a7e38a9a9c31b39e25439c1d7?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlVGFrZVVudGlsTWF5YmUuamF2YQ==) | `93.87% <ø> (-6.13%)` | `2% <ø> (ø)` | |\n| [...a\/io\/reactivex\/internal\/util\/QueueDrainHelper.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7494a2c05cf2f02142fc3193682141826974661a...6457c110f57f728a7e38a9a9c31b39e25439c1d7?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvdXRpbC9RdWV1ZURyYWluSGVscGVyLmphdmE=) | `58.86% <ø> (-5.68%)` | `31% <ø> (-4%)` | |\n| [...\/operators\/observable\/ObservableFlatMapSingle.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7494a2c05cf2f02142fc3193682141826974661a...6457c110f57f728a7e38a9a9c31b39e25439c1d7?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXBTaW5nbGUuamF2YQ==) | `91.79% <ø> (-4.48%)` | `2% <ø> (ø)` | |\n| [...\/main\/java\/io\/reactivex\/subjects\/MaybeSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7494a2c05cf2f02142fc3193682141826974661a...6457c110f57f728a7e38a9a9c31b39e25439c1d7?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvTWF5YmVTdWJqZWN0LmphdmE=) | `95.65% <ø> (-4.35%)` | `46% <ø> (-2%)` | |\n| [...ernal\/operators\/flowable\/FlowableFromIterable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7494a2c05cf2f02142fc3193682141826974661a...6457c110f57f728a7e38a9a9c31b39e25439c1d7?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRnJvbUl0ZXJhYmxlLmphdmE=) | `91.97% <ø> (-3.21%)` | `5% <ø> (ø)` | |\n| [...rnal\/operators\/flowable\/FlowableTakeLastTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7494a2c05cf2f02142fc3193682141826974661a...6457c110f57f728a7e38a9a9c31b39e25439c1d7?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlVGFrZUxhc3RUaW1lZC5qYXZh) | `96.29% <ø> (-2.78%)` | `2% <ø> (ø)` | |\n| [...nternal\/operators\/observable\/ObservableCreate.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7494a2c05cf2f02142fc3193682141826974661a...6457c110f57f728a7e38a9a9c31b39e25439c1d7?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUNyZWF0ZS5qYXZh) | `97.32% <ø> (-2.68%)` | `2% <ø> (ø)` | |\n| ... and [36 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5133?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5133?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5133?src=pr&el=footer). Last update [7494a2c...6457c11](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7494a2c05cf2f02142fc3193682141826974661a...6457c110f57f728a7e38a9a9c31b39e25439c1d7?el=footer&src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-24T14:40:06Z","description":"This PR fixes the lack of eager cancellation when flatmapping sources and not stopping the upstream if the inner source fails.\r\n\r\nUnit tests were added to verify `Single` (in case it receives a dedicated implementation one day as currently it delegates to `Flowable`), `Flowable` and `Observable`.\r\n\r\nReported in #5132.","id":"210001116","title":"2.x: fix flatMap not cancelling the upstream eagerly","opened_on":"2017-02-24T09:39:26Z","closed_by":"akarnokd"},{"number":"5132","reopenOn":null,"comments":[{"date":"2017-02-24T09:13:29Z","author":"akarnokd","text":"Thanks for reporting. This is indeed an inconsistency between `Observable` and the `Flowable`-based merges not stopping immediately when one of the inner sources fails and subscribing to the next inner source in synchronous mode."},{"date":"2017-02-24T14:40:23Z","author":"akarnokd","text":"Closing via #5133."}],"opened_by":"stepango","reopen":false,"closed_on":"2017-02-24T14:40:23Z","description":"Sorry for code in kotlin.\r\n\r\n```\r\n    @Test fun singleMergeTest() {\r\n        val illegalAccessError = IllegalAccessError()\r\n        Single.merge<String>(listOf(\r\n                Single.error(illegalAccessError),\r\n                Single.error(illegalAccessError),\r\n                Single.error(illegalAccessError)\r\n        )).test().await().assertError(illegalAccessError)\r\n    }\r\n\r\n    @Test fun observableMergeTest() {\r\n        val illegalAccessError = IllegalAccessError()\r\n        Observable.merge<String>(listOf(\r\n                Observable.error(illegalAccessError),\r\n                Observable.error(illegalAccessError),\r\n                Observable.error(illegalAccessError)\r\n        )).test().await().assertError(illegalAccessError)\r\n    }\r\n```\r\n\r\nFirst test produces `UndeliverableError` after execution but second one completes successfully without errors. Is it expected behaviour or a bug?","id":"209979027","title":"2.x v2.0.6 Single.merge produce UndeliverableError [Question]","opened_on":"2017-02-24T07:33:43Z","closed_by":"akarnokd"},{"number":"5123","reopenOn":null,"comments":[{"date":"2017-02-20T09:56:28Z","author":"codecov-io","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5123?src=pr&el=h1) Report\n> Merging [#5123](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5123?src=pr&el=desc) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/5468972024dbbe5ee7cca080bc09a033b9488f37?src=pr&el=desc) will **increase** coverage by `0.02%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@             Coverage Diff              @@\n##                1.x    #5123      +\/-   ##\n============================================\n+ Coverage     84.38%   84.41%   +0.02%     \n- Complexity     2876     2877       +1     \n============================================\n  Files           290      290              \n  Lines         18070    18070              \n  Branches       2468     2468              \n============================================\n+ Hits          15249    15254       +5     \n- Misses         1951     1954       +3     \n+ Partials        870      862       -8\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5123?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...a\/rx\/internal\/operators\/OperatorThrottleFirst.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5468972024dbbe5ee7cca080bc09a033b9488f37...8c27da2389932ed1e9e028ab9a3fbe76230f74f5?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JUaHJvdHRsZUZpcnN0LmphdmE=) | `100% <100%> (ø)` | `2 <ø> (ø)` | :x: |\n| [...ain\/java\/rx\/internal\/operators\/OnSubscribeAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5468972024dbbe5ee7cca080bc09a033b9488f37...8c27da2389932ed1e9e028ab9a3fbe76230f74f5?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvT25TdWJzY3JpYmVBbWIuamF2YQ==) | `79.13% <ø> (-5.04%)` | `13% <ø> (ø)` | |\n| [...va\/rx\/internal\/schedulers\/EventLoopsScheduler.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5468972024dbbe5ee7cca080bc09a033b9488f37...8c27da2389932ed1e9e028ab9a3fbe76230f74f5?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9zY2hlZHVsZXJzL0V2ZW50TG9vcHNTY2hlZHVsZXIuamF2YQ==) | `84.84% <ø> (-3.04%)` | `7% <ø> (ø)` | |\n| [...n\/java\/rx\/subjects\/SubjectSubscriptionManager.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5468972024dbbe5ee7cca080bc09a033b9488f37...8c27da2389932ed1e9e028ab9a3fbe76230f74f5?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9zdWJqZWN0cy9TdWJqZWN0U3Vic2NyaXB0aW9uTWFuYWdlci5qYXZh) | `80.71% <ø> (-1.43%)` | `15% <ø> (-1%)` | |\n| [...n\/java\/rx\/internal\/operators\/CachedObservable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5468972024dbbe5ee7cca080bc09a033b9488f37...8c27da2389932ed1e9e028ab9a3fbe76230f74f5?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvQ2FjaGVkT2JzZXJ2YWJsZS5qYXZh) | `84.23% <ø> (+0.54%)` | `6% <ø> (ø)` | :x: |\n| [...main\/java\/rx\/internal\/operators\/OperatorMerge.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5468972024dbbe5ee7cca080bc09a033b9488f37...8c27da2389932ed1e9e028ab9a3fbe76230f74f5?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JNZXJnZS5qYXZh) | `87.06% <ø> (+0.69%)` | `7% <ø> (ø)` | :x: |\n| [...ava\/rx\/internal\/util\/BackpressureDrainManager.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5468972024dbbe5ee7cca080bc09a033b9488f37...8c27da2389932ed1e9e028ab9a3fbe76230f74f5?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC91dGlsL0JhY2twcmVzc3VyZURyYWluTWFuYWdlci5qYXZh) | `67.9% <ø> (+1.23%)` | `21% <ø> (+1%)` | :white_check_mark: |\n| [...rx\/internal\/operators\/OnSubscribeFromIterable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5468972024dbbe5ee7cca080bc09a033b9488f37...8c27da2389932ed1e9e028ab9a3fbe76230f74f5?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9vcGVyYXRvcnMvT25TdWJzY3JpYmVGcm9tSXRlcmFibGUuamF2YQ==) | `93.9% <ø> (+2.43%)` | `5% <ø> (ø)` | :x: |\n| [...\/rx\/internal\/schedulers\/CachedThreadScheduler.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5468972024dbbe5ee7cca080bc09a033b9488f37...8c27da2389932ed1e9e028ab9a3fbe76230f74f5?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9zY2hlZHVsZXJzL0NhY2hlZFRocmVhZFNjaGVkdWxlci5qYXZh) | `90.29% <ø> (+2.91%)` | `6% <ø> (ø)` | :x: |\n| [...ain\/java\/rx\/internal\/schedulers\/SchedulerWhen.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5468972024dbbe5ee7cca080bc09a033b9488f37...8c27da2389932ed1e9e028ab9a3fbe76230f74f5?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9yeC9pbnRlcm5hbC9zY2hlZHVsZXJzL1NjaGVkdWxlcldoZW4uamF2YQ==) | `87.83% <ø> (+4.05%)` | `4% <ø> (ø)` | :x: |\n| ... and [2 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5123?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5123?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5123?src=pr&el=footer). Last update [5468972...8c27da2](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5468972024dbbe5ee7cca080bc09a033b9488f37...8c27da2389932ed1e9e028ab9a3fbe76230f74f5?el=footer&src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-22T09:59:44Z","description":"If the current time moves backwards before the time the gate was closed, the opening of the gate would happen way later. Since we don't know how much relative time has passed, this fix opens the gate when the drift is detected during `onNext`.\r\n\r\nReported in #5120.\r\n\r\n\/cc @davidmoten as you've been experimenting with time-only (that is non-scheduled) gating.","id":"208828595","title":"1.x: throttleFirst detecting clock-drift backwards to open the gate","opened_on":"2017-02-20T09:44:06Z","closed_by":"akarnokd"},{"number":"5121","reopenOn":null,"comments":[{"date":"2017-02-20T01:51:38Z","author":"codecov-io","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5121?src=pr&el=h1) Report\n> Merging [#5121](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5121?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/9a342fdff91ee1bcc0f3d95441c3039ad8d897f9?src=pr&el=desc) will **decrease** coverage by `-0.07%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@             Coverage Diff             @@\n##                2.x   #5121      +\/-   ##\n===========================================\n- Coverage     95.17%   95.1%   -0.07%     \n+ Complexity     5566    5564       -2     \n===========================================\n  Files           620     620              \n  Lines         40014   40020       +6     \n  Branches       5632    5633       +1     \n===========================================\n- Hits          38082   38062      -20     \n- Misses          929     941      +12     \n- Partials       1003    1017      +14\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5121?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...x\/internal\/operators\/observable\/ObservableZip.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9a342fdff91ee1bcc0f3d95441c3039ad8d897f9...87b47730f7778d07f1f49c33b648aee0dd08a67b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVppcC5qYXZh) | `100% <100%> (ø)` | `6 <ø> (ø)` | :x: |\n| [...al\/operators\/observable\/ObservableSampleTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9a342fdff91ee1bcc0f3d95441c3039ad8d897f9...87b47730f7778d07f1f49c33b648aee0dd08a67b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVNhbXBsZVRpbWVkLmphdmE=) | `90% <ø> (-6.67%)` | `3% <ø> (ø)` | |\n| [...rnal\/subscriptions\/ArrayCompositeSubscription.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9a342fdff91ee1bcc0f3d95441c3039ad8d897f9...87b47730f7778d07f1f49c33b648aee0dd08a67b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaXB0aW9ucy9BcnJheUNvbXBvc2l0ZVN1YnNjcmlwdGlvbi5qYXZh) | `93.33% <ø> (-6.67%)` | `17% <ø> (-1%)` | |\n| [...l\/operators\/observable\/ObservableFlatMapMaybe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9a342fdff91ee1bcc0f3d95441c3039ad8d897f9...87b47730f7778d07f1f49c33b648aee0dd08a67b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXBNYXliZS5qYXZh) | `90.19% <ø> (-5.23%)` | `2% <ø> (ø)` | |\n| [...\/internal\/operators\/maybe\/MaybeTakeUntilMaybe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9a342fdff91ee1bcc0f3d95441c3039ad8d897f9...87b47730f7778d07f1f49c33b648aee0dd08a67b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlVGFrZVVudGlsTWF5YmUuamF2YQ==) | `95.91% <ø> (-4.09%)` | `2% <ø> (ø)` | |\n| [...vex\/internal\/operators\/flowable\/FlowableTimer.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9a342fdff91ee1bcc0f3d95441c3039ad8d897f9...87b47730f7778d07f1f49c33b648aee0dd08a67b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlVGltZXIuamF2YQ==) | `92.85% <ø> (-3.58%)` | `2% <ø> (ø)` | |\n| [...nternal\/operators\/parallel\/ParallelSortedJoin.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9a342fdff91ee1bcc0f3d95441c3039ad8d897f9...87b47730f7778d07f1f49c33b648aee0dd08a67b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL3BhcmFsbGVsL1BhcmFsbGVsU29ydGVkSm9pbi5qYXZh) | `92.75% <ø> (-2.18%)` | `2% <ø> (ø)` | |\n| [...\/main\/java\/io\/reactivex\/subjects\/MaybeSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9a342fdff91ee1bcc0f3d95441c3039ad8d897f9...87b47730f7778d07f1f49c33b648aee0dd08a67b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvTWF5YmVTdWJqZWN0LmphdmE=) | `95.65% <ø> (-2.18%)` | `46% <ø> (-1%)` | |\n| [...operators\/observable\/ObservableConcatMapEager.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9a342fdff91ee1bcc0f3d95441c3039ad8d897f9...87b47730f7778d07f1f49c33b648aee0dd08a67b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUNvbmNhdE1hcEVhZ2VyLmphdmE=) | `97.29% <ø> (-2.17%)` | `2% <ø> (ø)` | |\n| [...activex\/internal\/disposables\/DisposableHelper.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9a342fdff91ee1bcc0f3d95441c3039ad8d897f9...87b47730f7778d07f1f49c33b648aee0dd08a67b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvZGlzcG9zYWJsZXMvRGlzcG9zYWJsZUhlbHBlci5qYXZh) | `98.14% <ø> (-1.86%)` | `27% <ø> (-1%)` | |\n| ... and [28 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5121?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5121?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5121?src=pr&el=footer). Last update [9a342fd...87b4773](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9a342fdff91ee1bcc0f3d95441c3039ad8d897f9...87b47730f7778d07f1f49c33b648aee0dd08a67b?el=footer&src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"jbarr21","reopen":false,"closed_on":"2017-02-20T08:30:43Z","description":"This PR fixes `Observable.zip` to dispose the sources outside the serialization loop, just like `Flowable.zip` does. This allows cancellation even if the serialization loop is busy\/blocking inside an `onNext` emission.\r\n\r\nIn addition, a unit test was added to `Observable.zip` as well.\r\n\r\nReported in #5111.","id":"208765066","title":"2.x: fix Observable.zip to dispose eagerly","opened_on":"2017-02-20T01:37:54Z","closed_by":"akarnokd"},{"number":"5120","reopenOn":null,"comments":[{"date":"2017-02-20T01:07:24Z","author":"akarnokd","text":"Would you like to post a fix?"},{"date":"2017-02-21T04:34:27Z","author":"juhwan-jeong","text":"Thank you for your feedback. "},{"date":"2017-02-21T12:43:37Z","author":"akarnokd","text":"I've restructured the issue and moved your comment into the top field. If you have the means, you are welcome to verify #5123."},{"date":"2017-02-24T14:26:21Z","author":"akarnokd","text":"Closing via #5123 & release 1.2.7"}],"opened_by":"juhwan-jeong","reopen":false,"closed_on":"2017-02-24T14:26:21Z","description":"I used throttleFirst operator for prevening duplicated click event like below\r\n```\r\nRxView.clicks(v).throttleFirst(500, TimeUnit.MILLISECONDS, AndroidSchedulers.mainThread())\r\n```\r\n\r\nIt works well in general case. But if user changed system time as past after click view, thrrottleFist doesn't emit item. (In the android, user can change system time using settings application.)\r\nBecause, OperatorThrottleFirst's below routine. \r\n```\r\n    @Override\r\n    public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {\r\n        return new Subscriber<T>(subscriber) {\r\n\r\n            private long lastOnNext = -1;\r\n            \/\/ ...\r\n            @Override\r\n            public void onNext(T v) {\r\n                long now = scheduler.now();\r\n                if (lastOnNext == -1 || now - lastOnNext >= timeInMilliseconds) {\r\n                    lastOnNext = now;\r\n                    subscriber.onNext(v);\r\n                }\r\n            }\r\n```\r\nI think (now - lastOnNext) become negative value, item should be emitted too. ","id":"208760794","title":"[1.2.6] throttleFirst doesn't emit item if user changed system time as past","opened_on":"2017-02-20T00:42:48Z","closed_by":"akarnokd"},{"number":"5114","reopenOn":null,"comments":[{"date":"2017-02-18T10:30:05Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5114?src=pr&el=h1) Report\n> Merging [#5114](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5114?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/a00ea07a4d2ce409e8dbea66ddbca9c0a77ddab6?src=pr&el=desc) will **decrease** coverage by `-0.07%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@             Coverage Diff              @@\n##                2.x    #5114      +\/-   ##\n============================================\n- Coverage     95.15%   95.09%   -0.07%     \n- Complexity     5561     5565       +4     \n============================================\n  Files           620      620              \n  Lines         40011    40014       +3     \n  Branches       5632     5632              \n============================================\n- Hits          38072    38050      -22     \n- Misses          920      944      +24     \n- Partials       1019     1020       +1\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5114?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...\/operators\/observable\/ObservableCombineLatest.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a00ea07a4d2ce409e8dbea66ddbca9c0a77ddab6...00502753f3828016b036c384f94283d9eebd240b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUNvbWJpbmVMYXRlc3QuamF2YQ==) | `98.75% <100%> (+0.02%)` | `6 <ø> (ø)` | :x: |\n| [...\/operators\/observable\/ObservableFlatMapSingle.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a00ea07a4d2ce409e8dbea66ddbca9c0a77ddab6...00502753f3828016b036c384f94283d9eebd240b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXBTaW5nbGUuamF2YQ==) | `89.55% <ø> (-7.47%)` | `2% <ø> (ø)` | |\n| [...internal\/disposables\/ArrayCompositeDisposable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a00ea07a4d2ce409e8dbea66ddbca9c0a77ddab6...00502753f3828016b036c384f94283d9eebd240b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvZGlzcG9zYWJsZXMvQXJyYXlDb21wb3NpdGVEaXNwb3NhYmxlLmphdmE=) | `92.85% <ø> (-7.15%)` | `15% <ø> (-1%)` | |\n| [...in\/java\/io\/reactivex\/subjects\/BehaviorSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a00ea07a4d2ce409e8dbea66ddbca9c0a77ddab6...00502753f3828016b036c384f94283d9eebd240b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvQmVoYXZpb3JTdWJqZWN0LmphdmE=) | `83.93% <ø> (-5.7%)` | `55% <ø> (ø)` | |\n| [...rnal\/subscribers\/SinglePostCompleteSubscriber.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a00ea07a4d2ce409e8dbea66ddbca9c0a77ddab6...00502753f3828016b036c384f94283d9eebd240b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaWJlcnMvU2luZ2xlUG9zdENvbXBsZXRlU3Vic2NyaWJlci5qYXZh) | `94.87% <ø> (-5.13%)` | `14% <ø> (-1%)` | |\n| [...ava\/io\/reactivex\/processors\/BehaviorProcessor.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a00ea07a4d2ce409e8dbea66ddbca9c0a77ddab6...00502753f3828016b036c384f94283d9eebd240b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcHJvY2Vzc29ycy9CZWhhdmlvclByb2Nlc3Nvci5qYXZh) | `87.38% <ø> (-4.21%)` | `56% <ø> (+1%)` | |\n| [...x\/internal\/operators\/maybe\/MaybeSwitchIfEmpty.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a00ea07a4d2ce409e8dbea66ddbca9c0a77ddab6...00502753f3828016b036c384f94283d9eebd240b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlU3dpdGNoSWZFbXB0eS5qYXZh) | `97.22% <ø> (-2.78%)` | `2% <ø> (ø)` | |\n| [...rnal\/operators\/flowable\/FlowableTakeLastTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a00ea07a4d2ce409e8dbea66ddbca9c0a77ddab6...00502753f3828016b036c384f94283d9eebd240b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlVGFrZUxhc3RUaW1lZC5qYXZh) | `96.29% <ø> (-2.78%)` | `2% <ø> (ø)` | |\n| [...l\/operators\/observable\/ObservableFlatMapMaybe.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a00ea07a4d2ce409e8dbea66ddbca9c0a77ddab6...00502753f3828016b036c384f94283d9eebd240b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXBNYXliZS5qYXZh) | `92.15% <ø> (-2.62%)` | `2% <ø> (ø)` | |\n| [...activex\/internal\/schedulers\/ExecutorScheduler.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a00ea07a4d2ce409e8dbea66ddbca9c0a77ddab6...00502753f3828016b036c384f94283d9eebd240b?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc2NoZWR1bGVycy9FeGVjdXRvclNjaGVkdWxlci5qYXZh) | `94.07% <ø> (-2.23%)` | `9% <ø> (ø)` | |\n| ... and [38 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5114\/changes?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5114?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5114?src=pr&el=footer). Last update [a00ea07...0050275](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a00ea07a4d2ce409e8dbea66ddbca9c0a77ddab6...00502753f3828016b036c384f94283d9eebd240b?src=pr&el=footer&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-18T20:22:07Z","description":"This PR fixes `Observable.combineLatest` to dispose the sources outside the serialization loop, just like `Flowable.combineLatest` does. This allows cancellation even if the serialization loop is busy\/blocking inside an `onNext` emission.\r\n\r\nIn addition, a unit test was added to `Flowable.combineLatest` as well.\r\n\r\nReported in #5111.","id":"208630321","title":"2.x: fix Observable.combineLatest to dispose eagerly","opened_on":"2017-02-18T10:16:55Z","closed_by":"akarnokd"},{"number":"5111","reopenOn":null,"comments":[{"date":"2017-02-17T23:52:17Z","author":"akarnokd","text":"If there is no ongoing onNext, that should dispose the sources. Does your downstream block for any reason on onNext?"},{"date":"2017-02-18T10:12:40Z","author":"akarnokd","text":"`Flowable` is implemented with an eager cancellation so I consider this to be a bug. I'll post a fix shortly."},{"date":"2017-02-18T20:29:30Z","author":"akarnokd","text":"Closing via #5114."},{"date":"2017-02-19T16:44:35Z","author":"jbarr21","text":"@akarnokd, thanks for the quick turnaround! would this also apply to [ObservableZip](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/2.x\/src\/main\/java\/io\/reactivex\/internal\/operators\/observable\/ObservableZip.java#L118), as well? here is [FlowableZip](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/2.x\/src\/main\/java\/io\/reactivex\/internal\/operators\/flowable\/FlowableZip.java#L146)'s cancel()"},{"date":"2017-02-19T16:49:46Z","author":"akarnokd","text":"Indeed. Would you like to submit a PR?"},{"date":"2017-02-19T16:52:59Z","author":"jbarr21","text":"will do"}],"opened_by":"jbarr21","reopen":false,"closed_on":"2017-02-18T20:29:30Z","description":"When a ObservableCombineLatest is disposed, is there any particular reason why it does not dispose all of it's observers? i'm seeing `getAndIncrement()` be non-zero and that observer is not receiving any more events, so a memory leak is caused\r\n\r\nhttps:\/\/github.com\/ReactiveX\/RxJava\/blob\/2.x\/src\/main\/java\/io\/reactivex\/internal\/operators\/observable\/ObservableCombineLatest.java#L128","id":"208583649","title":"2.x: Disposal of ObservableCombineLatest's observers?","opened_on":"2017-02-17T23:20:08Z","closed_by":"akarnokd"},{"number":"5106","reopenOn":null,"comments":[{"date":"2017-02-17T11:00:22Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5106?src=pr&el=h1) Report\n> Merging [#5106](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5106?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/d9e2df90cb47caef6b32d4912a2c04b80d5f94f7?src=pr&el=desc) will **increase** coverage by `0.06%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@             Coverage Diff             @@\n##               2.x    #5106      +\/-   ##\n===========================================\n+ Coverage     95.6%   95.67%   +0.06%     \n+ Complexity    5558     5556       -2     \n===========================================\n  Files          615      615              \n  Lines        39703    39705       +2     \n  Branches      5583     5583              \n===========================================\n+ Hits         37959    37986      +27     \n+ Misses         758      745      -13     \n+ Partials       986      974      -12\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5106?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...ternal\/operators\/flowable\/FlowableWindowTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d9e2df90cb47caef6b32d4912a2c04b80d5f94f7...754cc8634ed1197bf480ed31e8940e71031c0dd8?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlV2luZG93VGltZWQuamF2YQ==) | `83.86% <100%> (+0.26%)` | `4 <ø> (ø)` | :x: |\n| [...al\/operators\/observable\/ObservableWindowTimed.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d9e2df90cb47caef6b32d4912a2c04b80d5f94f7...754cc8634ed1197bf480ed31e8940e71031c0dd8?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVdpbmRvd1RpbWVkLmphdmE=) | `87.84% <100%> (+0.03%)` | `4 <ø> (ø)` | :x: |\n| [...a\/io\/reactivex\/processors\/SerializedProcessor.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d9e2df90cb47caef6b32d4912a2c04b80d5f94f7...754cc8634ed1197bf480ed31e8940e71031c0dd8?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcHJvY2Vzc29ycy9TZXJpYWxpemVkUHJvY2Vzc29yLmphdmE=) | `92.55% <ø> (-5.32%)` | `26% <ø> (-2%)` | |\n| [...rnal\/operators\/completable\/CompletableTimeout.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d9e2df90cb47caef6b32d4912a2c04b80d5f94f7...754cc8634ed1197bf480ed31e8940e71031c0dd8?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlVGltZW91dC5qYXZh) | `92.3% <ø> (-5.13%)` | `2% <ø> (ø)` | |\n| [...erators\/completable\/CompletableConcatIterable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d9e2df90cb47caef6b32d4912a2c04b80d5f94f7...754cc8634ed1197bf480ed31e8940e71031c0dd8?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0SXRlcmFibGUuamF2YQ==) | `95.91% <ø> (-4.09%)` | `2% <ø> (ø)` | |\n| [...operators\/observable\/ObservableConcatMapEager.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d9e2df90cb47caef6b32d4912a2c04b80d5f94f7...754cc8634ed1197bf480ed31e8940e71031c0dd8?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUNvbmNhdE1hcEVhZ2VyLmphdmE=) | `97.29% <ø> (-2.17%)` | `2% <ø> (ø)` | |\n| [...reactivex\/internal\/operators\/maybe\/MaybeUsing.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d9e2df90cb47caef6b32d4912a2c04b80d5f94f7...754cc8634ed1197bf480ed31e8940e71031c0dd8?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlVXNpbmcuamF2YQ==) | `93.93% <ø> (-2.03%)` | `4% <ø> (ø)` | |\n| [...\/internal\/disposables\/ListCompositeDisposable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d9e2df90cb47caef6b32d4912a2c04b80d5f94f7...754cc8634ed1197bf480ed31e8940e71031c0dd8?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvZGlzcG9zYWJsZXMvTGlzdENvbXBvc2l0ZURpc3Bvc2FibGUuamF2YQ==) | `98% <ø> (-2%)` | `34% <ø> (-1%)` | |\n| [...activex\/internal\/disposables\/DisposableHelper.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d9e2df90cb47caef6b32d4912a2c04b80d5f94f7...754cc8634ed1197bf480ed31e8940e71031c0dd8?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvZGlzcG9zYWJsZXMvRGlzcG9zYWJsZUhlbHBlci5qYXZh) | `98.14% <ø> (-1.86%)` | `27% <ø> (-1%)` | |\n| [...internal\/operators\/completable\/CompletableAmb.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d9e2df90cb47caef6b32d4912a2c04b80d5f94f7...754cc8634ed1197bf480ed31e8940e71031c0dd8?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQW1iLmphdmE=) | `96.29% <ø> (-1.86%)` | `10% <ø> (-1%)` | |\n| ... and [37 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5106\/changes?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5106?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5106?src=pr&el=footer). Last update [d9e2df9...754cc86](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d9e2df90cb47caef6b32d4912a2c04b80d5f94f7...754cc8634ed1197bf480ed31e8940e71031c0dd8?el=footer&src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-17T17:56:17Z","description":"This PR fixes the operators `Flowable.window(time, size)` and `Observable.window(time, size)` to complete the current window if the time elapses before the size limit is reached.\r\n\r\nReported in #5104.","id":"208403999","title":"2.x: fix window(time, size) not completing windows on timeout","opened_on":"2017-02-17T10:46:18Z","closed_by":"akarnokd"},{"number":"5104","reopenOn":null,"comments":[{"date":"2017-02-17T08:45:05Z","author":"akarnokd","text":"There are two problems with your code:\r\n\r\n- You are using `toList` which requires a finite stream. Since you don't call `onComplete` on `vehicleToFetch` the sequence above won't print anything.\r\n- You are probably not waiting long enough to see the results. The default RxJava schedulers are daemon threads and when the \"main\" thread ends, the whole application stops.\r\n\r\n```java\r\nPublishSubject<String> vehicleToFetch = PublishSubject.create();\r\nvehicleToFetch\r\n        .delay(2,TimeUnit.SECONDS)\r\n        .window(10, TimeUnit.SECONDS, 5)\r\n        .observeOn(Schedulers.io())\r\n        .subscribe(w-> w.toList().subscribe(ws-> {\r\n            ws.forEach(v -> {\r\n                System.out.println(String.format(\"%s %d\", v, Thread.currentThread().getId()));\r\n                vehicleToFetch.onNext(v);\r\n            });\r\n        }));\r\n\r\n\r\nObservable.just(\"v1\",\"v2\",\"v3\",\"v4\").subscribe(vehicleToFetch);\r\n\r\nThread.sleep(3000);\r\n```"},{"date":"2017-02-17T10:12:02Z","author":"xiemeilong","text":"@akarnokd Thanks.  I am calling `toList()` on a window observable ,not on `vehicleToFetch`, There is print if I change ` .window(10, TimeUnit.SECONDS, 5)` to `.window(10, TimeUnit.SECONDS, 4)`.\r\n\r\nI am using a `CountDownLatch`(not show in code) to wait a long time."},{"date":"2017-02-17T10:14:27Z","author":"akarnokd","text":"Yes, because the window with limit 4 will call `onComplete` for you on the window that `toList()` consumes. With 5 there is noone to call `onComplete`. If you had a \"v5\" in that case, you'd see the printout again."},{"date":"2017-02-17T10:21:26Z","author":"xiemeilong","text":"Why did it not call `onComplete` when the timeout is reached?  Does not this method mean either timeout or max count is reach will emit a window? "},{"date":"2017-02-17T10:29:13Z","author":"akarnokd","text":"Oh, I see it now. There is a bug in the operator that doesn't complete the old window if a new one is due to the timeout. I'll post a fix for it."},{"date":"2017-02-18T20:30:57Z","author":"akarnokd","text":"Closing via #5106."},{"date":"2017-03-22T09:57:17Z","author":"xiemeilong","text":"It  worked after upgrade to 2.0.7,  but after three times timeout, there is no timeout anymore."},{"date":"2017-03-22T10:21:13Z","author":"akarnokd","text":"Do you have a new unit test for it?"},{"date":"2017-03-22T10:29:14Z","author":"xiemeilong","text":"You can use the same code , it will block after three new window emitted."},{"date":"2017-03-22T10:50:54Z","author":"akarnokd","text":"Odd. I'll look into it again."},{"date":"2017-03-22T12:10:18Z","author":"akarnokd","text":"Found a couple of remaining issues. See PR #5213; the example works with it properly for me."}],"opened_by":"xiemeilong","reopen":false,"closed_on":"2017-02-18T20:30:57Z","description":"This code will print nothing all the time.\r\n\r\n```java\r\nPublishSubject<String> vehicleToFetch = PublishSubject.create();\r\n        vehicleToFetch\r\n                .delay(2,TimeUnit.SECONDS)\r\n                .window(10, TimeUnit.SECONDS, 5)\r\n                .observeOn(Schedulers.io())\r\n                .subscribe(w-> w.toList().subscribe(ws-> {\r\n                    ws.forEach(v -> {\r\n                        System.out.println(String.format(\"%s %d\", v, Thread.currentThread().getId()));\r\n                        vehicleToFetch.onNext(v);\r\n                    });\r\n                }));\r\n\r\n\r\n        Observable.just(\"v1\",\"v2\",\"v3\",\"v4\")\r\n                .subscribe(v->{\r\n                    vehicleToFetch.onNext(v);\r\n                });\r\n\r\n```\r\n\r\nI am using rxjava:2.0.6.\r\n","id":"208312674","title":"2.x : window(timespan, unit, count) always emit empty observable if not reach max count","opened_on":"2017-02-17T02:14:45Z","closed_by":"akarnokd"},{"number":"5103","reopenOn":null,"comments":[{"date":"2017-02-16T22:13:27Z","author":"codecov[bot]","text":"# [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5103?src=pr&el=h1) Report\n> Merging [#5103](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5103?src=pr&el=desc) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/commit\/6daf59ebc19f5ef8914086fe466823f51ca628a9?src=pr&el=desc) will **decrease** coverage by `-0.01%`.\n> The diff coverage is `96.96%`.\n\n\n```diff\n@@             Coverage Diff             @@\n##                2.x   #5103      +\/-   ##\n===========================================\n- Coverage     95.61%   95.6%   -0.01%     \n- Complexity     5554    5562       +8     \n===========================================\n  Files           615     615              \n  Lines         39685   39703      +18     \n  Branches       5578    5583       +5     \n===========================================\n+ Hits          37944   37959      +15     \n- Misses          757     762       +5     \n+ Partials        984     982       -2\n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5103?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...x\/internal\/observers\/DisposableLambdaObserver.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6daf59ebc19f5ef8914086fe466823f51ca628a9...d67794db730f9467bb67dd8e69b535340e7aa89d?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb2JzZXJ2ZXJzL0Rpc3Bvc2FibGVMYW1iZGFPYnNlcnZlci5qYXZh) | `85.29% <100%> (+20.77%)` | `8 <4> (+2)` | :white_check_mark: |\n| [...rnal\/operators\/flowable\/FlowableDoOnLifecycle.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6daf59ebc19f5ef8914086fe466823f51ca628a9...d67794db730f9467bb67dd8e69b535340e7aa89d?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRG9PbkxpZmVjeWNsZS5qYXZh) | `100% <100%> (ø)` | `2 <ø> (ø)` | :x: |\n| [...nternal\/operators\/completable\/CompletablePeek.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6daf59ebc19f5ef8914086fe466823f51ca628a9...d67794db730f9467bb67dd8e69b535340e7aa89d?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlUGVlay5qYXZh) | `96.87% <96.29%> (-3.13%)` | `2 <1> (ø)` | |\n| [...in\/java\/io\/reactivex\/subjects\/BehaviorSubject.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6daf59ebc19f5ef8914086fe466823f51ca628a9...d67794db730f9467bb67dd8e69b535340e7aa89d?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvQmVoYXZpb3JTdWJqZWN0LmphdmE=) | `83.93% <ø> (-6.74%)` | `55% <ø> (-1%)` | |\n| [...\/operators\/completable\/CompletableConcatArray.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6daf59ebc19f5ef8914086fe466823f51ca628a9...d67794db730f9467bb67dd8e69b535340e7aa89d?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0QXJyYXkuamF2YQ==) | `93.75% <ø> (-6.25%)` | `2% <ø> (ø)` | |\n| [...rnal\/subscribers\/SinglePostCompleteSubscriber.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6daf59ebc19f5ef8914086fe466823f51ca628a9...d67794db730f9467bb67dd8e69b535340e7aa89d?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaWJlcnMvU2luZ2xlUG9zdENvbXBsZXRlU3Vic2NyaWJlci5qYXZh) | `94.87% <ø> (-5.13%)` | `14% <ø> (-1%)` | |\n| [...rnal\/subscriptions\/DeferredScalarSubscription.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6daf59ebc19f5ef8914086fe466823f51ca628a9...d67794db730f9467bb67dd8e69b535340e7aa89d?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaXB0aW9ucy9EZWZlcnJlZFNjYWxhclN1YnNjcmlwdGlvbi5qYXZh) | `93.84% <ø> (-4.62%)` | `27% <ø> (-1%)` | |\n| [...erators\/completable\/CompletableConcatIterable.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6daf59ebc19f5ef8914086fe466823f51ca628a9...d67794db730f9467bb67dd8e69b535340e7aa89d?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0SXRlcmFibGUuamF2YQ==) | `95.91% <ø> (-4.09%)` | `2% <ø> (ø)` | |\n| [...reactivex\/internal\/operators\/maybe\/MaybeUsing.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6daf59ebc19f5ef8914086fe466823f51ca628a9...d67794db730f9467bb67dd8e69b535340e7aa89d?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlVXNpbmcuamF2YQ==) | `95.95% <ø> (-4.05%)` | `4% <ø> (ø)` | |\n| [...ernal\/operators\/maybe\/MaybeTakeUntilPublisher.java](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6daf59ebc19f5ef8914086fe466823f51ca628a9...d67794db730f9467bb67dd8e69b535340e7aa89d?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlVGFrZVVudGlsUHVibGlzaGVyLmphdmE=) | `96% <ø> (-4%)` | `2% <ø> (ø)` | |\n| ... and [36 more](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5103\/changes?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5103?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5103?src=pr&el=footer). Last update [6daf59e...d67794d](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6daf59ebc19f5ef8914086fe466823f51ca628a9...d67794db730f9467bb67dd8e69b535340e7aa89d?src=pr&el=footer&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments)."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-16T22:31:04Z","description":"This PR fixes the issue reported on [StackOverflow](http:\/\/stackoverflow.com\/questions\/42279543\/exception-is-not-propagated-to-onerror-when-thrown-from-doonsubscribe) where crashing the lambda in `Flowable.doOnSubscribe` calls the `RxJavaPlugins.onError`, which crashes the app and prevents calling the `EmptySubscription.error` on Android. (Desktop prints to the console and delivers the error normally.)\r\n\r\nThe bug was present in the `Flowable`, `Observable` and `Completable`. All 5 base types received the respective unit test to ensure correct behavior.","id":"208259004","title":"2.x: fix doOnSubscribe signalling Undeliv.Exception instead of just onError","opened_on":"2017-02-16T21:54:43Z","closed_by":"akarnokd"},{"number":"5101","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-16T17:20:41Z","description":"This PR fixes `Maybe.concatX` subscribing to the next source when the downstream cancelled the `Flowable` sequence from its `onNext`. This resulted in executing the subscription side-effects of the source to be immediately cancelled when it called `onSubscribe` on concat's `MaybeObserver`.\r\n\r\nIn addition, tests were added to verify the other types don't have this kind of a problem.\r\n\r\nRelated #5100.","id":"208162077","title":"2.x: fix Maybe.concat() subscribe-after-cancel, verify others","opened_on":"2017-02-16T15:54:36Z","closed_by":"akarnokd"},{"number":"5100","reopenOn":null,"comments":[{"date":"2017-02-16T15:20:38Z","author":"akarnokd","text":"Hi and thanks for reporting. This is a bug in the underlying `concat` operator that doesn't expect a cancellation (happening due to `firstElement`) after emitting an item and happily subscribes to the next source, triggering subscription side-effects but actually cancelling out that new source immediately.\r\n\r\nI'll post a fix shortly."},{"date":"2017-02-16T17:22:20Z","author":"akarnokd","text":"Closing via #5101.\r\n\r\nTemporary workaround: add `Maybe.empty()` between the sources to absorb the extra subscription."}],"opened_by":"ekosuhariyadi","reopen":false,"closed_on":"2017-02-16T17:22:20Z","description":"Hi, I'm relatively new to RxJava.\r\n\r\nI tried RxJava 2.0.6 (previously 2.0.5) to check if it still produces the same result.\r\n\r\nHere my code (still using Java 6)\r\n\r\n```\r\nMaybe<String> m1 = Maybe.create(new MaybeOnSubscribe<String>() {\r\n\r\n    @Override public void subscribe(MaybeEmitter<String> e) throws Exception {\r\n        System.out.println(\"m1 called\");\r\n        e.onSuccess(\"m1\");\r\n    }\r\n});\r\nMaybe<String> m2 = Maybe.create(new MaybeOnSubscribe<String>() {\r\n\r\n    @Override public void subscribe(MaybeEmitter<String> e) throws Exception {\r\n        System.out.println(\"m2 called\");\r\n        e.onSuccess(\"m2\");\r\n    }\r\n});\r\nDisposable subscribe = Maybe.concat(m1, m2)\r\n        .firstElement()\r\n        .subscribe(new Consumer<String>() {\r\n\r\n            @Override public void accept(String t) throws Exception {\r\n                System.out.println(t);\r\n            }\r\n        });\r\n```\r\n\r\nthe output :\r\nm1 called\r\nm1\r\nm2 called\r\n\r\nIs it correct or not? Because while using Observable, the second Observable is not called when the first one already emit value\r\n\r\nThanks","id":"208142892","title":"Maybe concat with firstElement still call second Maybe although the first emit value","opened_on":"2017-02-16T14:51:37Z","closed_by":"akarnokd"},{"number":"5091","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-11T09:36:19Z","description":"This PR allows to fix the same-pool deadlock that may happen with `create()` (formerly `fromEmitter`) and `subscribeOn` as `subscribeOn` by default schedules the requests behind a running emitter and thus the internal request amount may not get updated, leading to unnecessary dataloss.\r\n\r\nSee #4735.\r\n\r\nIn the update, if `subscribeOn` detects its upstream is `OnSubscribeCreate`, it no longer reschedules requests for it. For other, non-immediate cases, a new overload allows specifying the `requestOn` parameter that should be `false` if there is a `create(Action1, BackpressureStrategy)` in the sequence upstream.","id":"206763028","title":"1.x: create+subscribeOn avoid same-pool deadlock","opened_on":"2017-02-10T10:41:35Z","closed_by":"akarnokd"},{"number":"5090","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-11T09:37:16Z","description":"For performance reasons, the `scan` delayed the emission of accumulated items by one which worked well with sources that pushed new items frequently. \r\n\r\nUnfortunately, if the source stopped emitting (without completion), the very last accumulated item was stuck and no way to get it out of `scan`. I considered this type of use being rare but apparently I was wrong.\r\n\r\nThe PR changes `scan` to emit accumulated items, including the initial seed, as soon as there is request for it. The operator now uses a stable-prefetch queue-drain found throughout other operators such as `observeOn`. \r\n\r\nRemark: sadly, request trickery such as capturing the first `request` call, emitting the seed and then requesting n - 1 doesn't work because if the `request()` call itself happens from another thread and the source is empty, the `onNext` and `onComplete` could run concurrently.\r\n\r\nReported in #5089 ","id":"206751517","title":"2.x: fix scan(seed, f) to emit accumulated values asap","opened_on":"2017-02-10T09:50:12Z","closed_by":"akarnokd"},{"number":"5089","reopenOn":null,"comments":[{"date":"2017-02-10T08:33:52Z","author":"akarnokd","text":"Scan was changed to have less overhead than before at the cost of delaying the upstream values by one step. This works if the source keeps emitting frequently enough but as you demonstrated, if there is nothing to push more the operator just stops.\r\n\r\nI'll create a PR that doesn't delay items shortly."},{"date":"2017-02-11T18:07:07Z","author":"akarnokd","text":"Closing via #5090."}],"opened_by":"lambdas","reopen":false,"closed_on":"2017-02-11T18:07:08Z","description":"Hi guys! \r\n\r\nI'm using `Flowable.scan(seed)` to accumulate values of infinite sequence(stream of updates from server that comes not so often). The problem is that whenever FlowableScanSeed receives new value it publishes previous one. I guess it's not a problem with a finite sequence(at completion all values will be published anyway), but with infinite seq the last value is held until next comes.\r\n\r\nI wrote test case to demonstrate the issue\r\n```\r\n    @Test\r\n    public void testScanWithSeedEmitsAllItemsOnInfiniteSequence() {\r\n        Flowable.concat(Flowable.just(1, 2, 3), Flowable.<Integer>never()).scan(0, SUM)\r\n                .test(4)\r\n                .assertValues(0, 1, 3, 6);\r\n    }\r\n```\r\n\r\nHere seed+3 values are expected, but since sequence is infinite last value never comes.\r\n\r\nI don't have much experience with rx so can't provide you with a patch, sorry ;)","id":"206708773","title":"2.0.4 FlowableScanSeed introduces delay","opened_on":"2017-02-10T04:56:03Z","closed_by":"akarnokd"},{"number":"5064","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-03T18:40:43Z","description":"This PR fixes both `Flowable.replay()` and `Observable.replay()` throwing a `NullPointerException` if the connection is disconnect before the upstream calls `onSubscribe` on the connection being established. \r\n\r\nIn practice, this requires an async cancellation to happen through `refCount().unsubscribeOn()` for example. The validation tests simulate this by not calling `onSubscribe` until the synchronous connect\/disconnect happens.\r\n\r\nReported in #5060.","id":"205232926","title":"2.x: fix replay() cancel\/dispose NPE","opened_on":"2017-02-03T18:25:47Z","closed_by":"akarnokd"},{"number":"5060","reopenOn":null,"comments":[{"date":"2017-02-03T17:26:54Z","author":"akarnokd","text":"Thanks for reporting, this is a bug. What happens is that the asnyc dispose happens before the chain of onSubscribe call reaches the operator. The same happens inside `FlowableReplay`. I'll post a fix shortly."},{"date":"2017-02-03T18:28:08Z","author":"akarnokd","text":"See #5064"},{"date":"2017-02-03T18:41:07Z","author":"akarnokd","text":"Closing via #5064"}],"opened_by":"hvisser","reopen":false,"closed_on":"2017-02-03T18:41:09Z","description":"Stack trace below shows a crash that I unfortunately can't reproduce currently. I've checked the source for `ObservableReplay.ReplayObserver` and it looks like this can only happen if it's being disposed before being subscribed which sounds odd to me? What might be relevant is that `unsubscribeOn()` is used on the observable.\r\n\r\n```\r\njava.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference\r\n    at io.reactivex.internal.operators.observable.ObservableReplay$ReplayObserver.dispose(ObservableReplay.java:361)\r\n    at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:216)\r\n    at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:79)\r\n    at io.reactivex.internal.operators.observable.ObservableRefCount$2.run(ObservableRefCount.java:126)\r\n    at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:28)\r\n    at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:18)\r\n    at io.reactivex.disposables.ReferenceDisposable.dispose(ReferenceDisposable.java:42)\r\n    at io.reactivex.internal.operators.observable.ObservableRefCount$ConnectionObserver.dispose(ObservableRefCount.java:181)\r\n    at io.reactivex.internal.disposables.DisposableHelper.setOnce(DisposableHelper.java:79)\r\n    at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onSubscribe(ObservableSubscribeOn.java:58)\r\n    at io.reactivex.internal.operators.observable.ObservableRefCount.doSubscribe(ObservableRefCount.java:113)\r\n    at io.reactivex.internal.operators.observable.ObservableRefCount$1.accept(ObservableRefCount.java:98)\r\n    at io.reactivex.internal.operators.observable.ObservableRefCount$1.accept(ObservableRefCount.java:92)\r\n    at io.reactivex.internal.operators.observable.ObservableReplay.connect(ObservableReplay.java:305)\r\n    at io.reactivex.internal.operators.observable.ObservableRefCount.subscribeActual(ObservableRefCount.java:68)\r\n    at io.reactivex.Observable.subscribe(Observable.java:10514)\r\n    at io.reactivex.internal.operators.observable.ObservableSubscribeOn$1.run(ObservableSubscribeOn.java:39)\r\n    at io.reactivex.Scheduler$1.run(Scheduler.java:134)\r\n    at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)\r\n    at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)\r\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272)\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\n    at java.lang.Thread.run(Thread.java:761)\r\n```","id":"205190811","title":"2.x: NPE at ObservableReplay.ReplayObserver.dispose()","opened_on":"2017-02-03T15:40:04Z","closed_by":"akarnokd"},{"number":"5030","reopenOn":null,"comments":[{"date":"2017-01-28T11:02:47Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5030?src=pr) is 84.14% (diff: 100%)\n> Merging [#5030](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5030?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will decrease coverage by **0.05%**\n\n```diff\n@@                1.x      #5030   diff @@\n==========================================\n  Files           288        288          \n  Lines         17806      17805     -1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2698       2698          \n==========================================\n- Hits          14993      14982    -11   \n- Misses         1958       1965     +7   \n- Partials        855        858     +3   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [56d94b2...9abdee6](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/56d94b2d6dfbb54fb6c1c0d8ab0e04659ff05f0b...9abdee6d649862dfe94448a678ff68853020f3f3?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-01-28T18:17:31Z","description":"Due to an unnecessary `request(1)`, `groupBy` consumed the upstream in an unbounded manner no matter the downstream request patterns against the main or the inner groups themselves.\r\n\r\nThis PR fixes this by removing it and rearranging the group\/group item handling similar to how 2.x is implemented.\r\n\r\nRelated #5029.","id":"203801214","title":"1.x: fix groupBy consuming the upstream in an unbounded manner","opened_on":"2017-01-28T10:55:40Z","closed_by":"akarnokd"},{"number":"5029","reopenOn":null,"comments":[{"date":"2017-01-27T22:54:33Z","author":"sbarlabanov","text":"It does work correctly with rxjava 2.x Flowable."},{"date":"2017-01-27T23:08:06Z","author":"akarnokd","text":"For historical reasons, `flatMap` in 1.x requests an unbounded amount of source elements for its 1 argument overload. There is another overload that takes a `maxConcurrent` parameter with which you can limit the number of active inner sources."},{"date":"2017-01-28T10:02:26Z","author":"sbarlabanov","text":"I know ;). But it does not work either :(. If I add maxConcurrent (1 or 2 or 3 etc.) to flatMap after groupBy the behavior stays the same - all 10000 items are requested at once.\r\n\r\n```\r\n    public static void main(String[] args) throws Exception {\r\n        Observable<Integer> source = range(1, 10000);\r\n        source\r\n                .doOnNext(i -> System.out.println(\"Requested \" + i))\r\n                .groupBy(v -> v % 5)\r\n                .flatMap(g -> g.observeOn(Schedulers.io()).map(GroupByTest::calculation), 4) \/\/ <---- maxConcurrent\r\n                .subscribe(i -> System.out.println(\"Got \" + i));\r\n        Thread.sleep(100000);\r\n    }\r\n```"},{"date":"2017-01-28T10:29:03Z","author":"sbarlabanov","text":"In RxJava 1.x there is OperatorGroupByTest which tests some backpressure scenarios.\r\nIf I adjust https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/test\/java\/rx\/internal\/operators\/OperatorGroupByTest.java#L1027 by putting `doOnNext` with `System.out.println` I observe the same behavior as I described above - all items are requested at once.\r\nSo OperatorGroupByTest#testGroupByBackpressure does not test any backpressure ;)."},{"date":"2017-01-28T10:35:07Z","author":"akarnokd","text":"OperatorGroupBy L247 keeps requesting from upstream and thus consumes it in an unbounded manner. Would you like to work out a fix?"},{"date":"2017-01-28T10:56:32Z","author":"akarnokd","text":"This is a bug. Fix posted in #5030."},{"date":"2017-01-28T16:28:11Z","author":"sbarlabanov","text":"Looks good. Your fix seems to work :). \r\nI tried my examples from above and also tested in a more complex scenario from a customer project (consuming from Kafka, grouping by partition and processing every partition in its own thread).\r\nIs any action required from my side?"},{"date":"2017-01-28T16:33:52Z","author":"akarnokd","text":"Thanks for verifying the fix. No further action is necessary of you. There are a few pending contributions targeting 1.x but I'll try to release 1.2.6 next Friday."},{"date":"2017-01-28T18:17:51Z","author":"akarnokd","text":"Closing via #5030"}],"opened_by":"sbarlabanov","reopen":false,"closed_on":"2017-01-28T18:17:51Z","description":"There are a plenty of issues fixing some sorts of backpressure problems in groupBy (e.g. #3428, #3425).\r\nBut nevertheless when I try the following code it requests all 10000 values from the source at once without waiting for processing of single items (example running with rxjava 1.2.x):\r\n\r\n```\r\nimport rx.Observable;\r\nimport rx.schedulers.Schedulers;\r\n\r\nimport java.util.Random;\r\n\r\nimport static rx.Observable.range;\r\n\r\npublic class GroupByTest {\r\n    public static void main(String[] args) throws Exception {\r\n        Observable<Integer> source = range(1, 10000);\r\n        source\r\n                .doOnNext(i -> System.out.println(\"Requested \" + i))\r\n                .groupBy(v -> v % 5)\r\n                .flatMap(g -> g.observeOn(Schedulers.io()).map(GroupByTest::calculation))\r\n                .subscribe(i -> System.out.println(\"Got \" + i));\r\n        Thread.sleep(100000);\r\n    }\r\n\r\n    private static Integer calculation(Integer i) {\r\n        sleep();\r\n        System.out.println(\"Processing \" + i);\r\n        return i * 20;\r\n    }\r\n\r\n    private static void sleep() {\r\n        try {\r\n            Thread.sleep(new Random().nextInt(1000));\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWhen running the code I see 10000 \"Requested X\" messages getting printed immediately and afterwards messages \"Processing X\" coming after some timeout.\r\nWith this behavior it does not seem to be possible to parallelize processing of single groups in rxjava  in any useful way when working with large or unlimited sources.","id":"203755633","title":"GroupBy with flatMap and observeOn does not seem to support backpressure in 1.2.x","opened_on":"2017-01-27T22:24:33Z","closed_by":"akarnokd"},{"number":"5005","reopenOn":null,"comments":[{"date":"2017-01-18T17:35:12Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5005?src=pr) is 95.61% (diff: 79.31%)\n> Merging [#5005](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/5005?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.17%**\n\n```diff\n@@                2.x      #5005   diff @@\n==========================================\n  Files           592        592          \n  Lines         37989      38011    +22   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5772       5777     +5   \n==========================================\n+ Hits          36257      36346    +89   \n+ Misses          764        720    -44   \n+ Partials        968        945    -23   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [9c34eb1...dd0c96d](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9c34eb12a22359c9dc3bbaf07a3410e7523050c5...dd0c96d4b49cb86bb54242aa3fc1e85e76f792c0?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-01-18T19:15:06Z","description":"This PR makes the `Disposable` returned by the `ExecutorScheduler.scheduleDirect()` report `isDisposed` `true` if the task has actually finished, which should now be consistent with the `Worker` behavior of other schedulers.\r\n\r\nReported in #5004.","id":"201637604","title":"2.x: ExecutorScheduler.scheduleDirect to report isDisposed on complete","opened_on":"2017-01-18T17:20:02Z","closed_by":"akarnokd"},{"number":"5004","reopenOn":null,"comments":[{"date":"2017-01-18T14:48:04Z","author":"akarnokd","text":"Yes, the internal `ExecutorScheduler.BooleanDisposable` doesn't set its state to disposed after the task has run.\r\n\r\nHow much problem is it for you? \r\n\r\n(Sidenote: It is generally not recommended to spin on `isDisposed()` because that nullifies the reason RxJava exists: not blocking on `Future.get()` or spinning on `Future.isDone()`.)"},{"date":"2017-01-18T14:53:04Z","author":"konmik","text":"The bug it was causing is that when user scrolls messages up, I wanted paging to run if it is not already running. After the transition to RxJava 2 I started to use this new `scheduleDirect` method. The first paging iteration worked as expected, but after that it just hangs up without any signs of living.\r\n\r\nThis is my current workaround:\r\n\r\n    public static Disposable scheduleDirect(Scheduler scheduler, Runnable runnable) {\r\n        Scheduler.Worker worker = scheduler.createWorker();\r\n        worker.schedule(() -> {\r\n            try {\r\n                runnable.run();\r\n            } finally {\r\n                worker.dispose();\r\n            }\r\n        });\r\n        return worker;\r\n    }\r\n\r\n"},{"date":"2017-01-18T14:55:01Z","author":"konmik","text":"(As a sidenote: some real-world tasks DO require blocking operations or running of tasks depending on other tasks state.)"},{"date":"2017-01-18T14:56:22Z","author":"akarnokd","text":"Okay, for consistency with other Schedulers, I'll post a fix for this."},{"date":"2017-01-18T14:59:27Z","author":"konmik","text":"Cool! :)"},{"date":"2017-01-18T19:35:38Z","author":"akarnokd","text":"Closing via #5005."}],"opened_by":"konmik","reopen":false,"closed_on":"2017-01-18T19:35:38Z","description":"\r\nThis fails:\r\n\r\n    @Test\r\n    public void directScheduleOnSingleThreadExecutor() {\r\n        Scheduler scheduler = Schedulers.from(Executors.newSingleThreadExecutor());\r\n\r\n        Disposable disposable = scheduler.scheduleDirect(() -> {\r\n        });\r\n\r\n        long start = nanoTime();\r\n        while (!disposable.isDisposed()) {\r\n            assertTrue(nanoTime() - start < SECONDS.toNanos(10));\r\n        }\r\n    }\r\n\r\nwhile replacing `from(...)` with `io()` works\r\n\r\nI can't find where the error exactly is, my debugger can't jump in to the right source code line.\r\n","id":"201591319","title":"2.0.4: an infinite disposable","opened_on":"2017-01-18T14:38:44Z","closed_by":"akarnokd"},{"number":"4992","reopenOn":null,"comments":[{"date":"2017-01-13T11:31:20Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4992?src=pr) is 95.58% (diff: 100%)\n> Merging [#4992](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4992?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.05%**\n\n```diff\n@@                2.x      #4992   diff @@\n==========================================\n  Files           592        592          \n  Lines         37969      37974     +5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5752       5768    +16   \n==========================================\n+ Hits          36273      36298    +25   \n+ Misses          741        725    -16   \n+ Partials        955        951     -4   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [cd45675...02ab095](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/cd45675960ad745c20e60a4eebb083de675f785b...02ab095abb4d21f08cdc9c2ed889cdbc920deff9?src=pr)"},{"date":"2017-01-17T20:04:38Z","author":"JakeWharton","text":":+1:"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-01-16T10:13:07Z","description":"The `flatMap` implementations always subscribed to the generated inner source even if there was an asynchronous cancel while the function was running. With typical functions, there is only a really tiny window inside function but some users tend to block\/sleep in the function and when that returns, the `flatMap` operator is already cancelled. \r\n\r\nIf the generated inner source emitted an error disregarding its own cancellation signal (the `error()` operators do this), those errors end up in the `RxJavaPlugins.onError` and crash the app (on Android).\r\n\r\nThis PR adjusts the `flatMap` implementations to check for the disposed\/cancelled state before subscribing to the inner source. For `Observable` and `Flowable`, this has practically no extra overhead as the add\/remove already checks for the terminal state and can return a boolean for it. The rest require an explicit `isDisposed()` check.","id":"200606449","title":"2.x: A.flatMapB to eagerly check for cancellations before subscribing","opened_on":"2017-01-13T11:18:32Z","closed_by":"akarnokd"},{"number":"4991","reopenOn":null,"comments":[{"date":"2017-01-13T10:09:30Z","author":"akarnokd","text":"`flatMap` is not expecting the `Function` to block or sleep thus doesn't check immediately if the user has disposed the sequence. When the `error()` emits, it finds a terminated sequence and relays the exception into the global error handler. Do you really have to wait\/block inside the flatMap's function?"},{"date":"2017-01-13T11:20:15Z","author":"akarnokd","text":"This is a grey area and can be considered as bug. Fix in #4992."},{"date":"2017-01-15T03:29:58Z","author":"loongee","text":"In my situation, I used a `socket.read()` instead of the `while (System.currentTimeMillis() < endTime) {}`, if the socket returns the unexpecting data, Observable.error(...) will return to indicate an server error. Under my circumstance, the task will be cancelled when it's no longer needed. That's how this happened."},{"date":"2017-01-17T09:54:11Z","author":"akarnokd","text":"Closing via #4992"},{"date":"2017-03-08T08:11:09Z","author":"xudshen","text":"I also encountered this problem when using the `Observable.fromCallable` and the `2.0.7`version does not seem to solve the problem.\r\n @akarnokd @loongee would you pls help me solve it?\r\n \r\n```\r\npublic class ExceptionAfterDispose {\r\n    public static void test() {\r\n        final Disposable disposable = Observable.fromCallable(new Callable<Object>() {\r\n            @Override\r\n            public Object call() throws Exception {\r\n                long endTime = System.currentTimeMillis() + 2000;\r\n                while (System.currentTimeMillis() < endTime) {\r\n                }\r\n                \/\/network spends 2000ms, then throw an exception\r\n                throw new IllegalStateException(\"error on network\");\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribeWith(new DisposableObserver<Object>() {\r\n                    @Override\r\n                    public void onNext(Object o) {\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                });\r\n        \/\/dispose it after 500ms\r\n        Observable.timer(500, TimeUnit.MILLISECONDS).subscribe(new Consumer<Long>() {\r\n            @Override\r\n            public void accept(@NonNull Long aLong) throws Exception {\r\n                disposable.dispose();\r\n            }\r\n        });\r\n    }\r\n}\r\n```\r\n\r\nand the exception is\r\n\r\n```\r\njava.lang.IllegalStateException: error on network\r\n   at info.xudshen.android.playground.recyclerview.fragment.ExceptionAfterDispose$2.call(ExceptionAfterDispose.java:27)\r\n   at io.reactivex.internal.operators.observable.ObservableFromCallable.subscribeActual(ObservableFromCallable.java:42)\r\n   at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n   at io.reactivex.internal.operators.observable.ObservableSubscribeOn$1.run(ObservableSubscribeOn.java:39)\r\n   at io.reactivex.Scheduler$1.run(Scheduler.java:138)\r\n   at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)\r\n   at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)\r\n   at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272)\r\n   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\n   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\n   at java.lang.Thread.run(Thread.java:761)\r\n```"},{"date":"2017-03-08T09:07:16Z","author":"akarnokd","text":"@xudshen Indeed the `dispose()` call should have prevented the error to reach `Observer.onError`, but since `fromCallable` can't determine if the thrown exception was due to the `dispose()` call, it has to route the error to `RxJavaPlugins.onError` which by default crashes Android apps."},{"date":"2017-03-08T09:42:14Z","author":"xudshen","text":"@akarnokd I test the same logic with `Flowable` and it does not crash anymore. lol"}],"opened_by":"loongee","reopen":false,"closed_on":"2017-01-17T09:54:11Z","description":"Exception unhandled if dispose() called.\r\nDid I used it in a wrong way ?\r\n\r\nerror stack:\r\n```\r\njava.lang.IllegalStateException: example\r\n\tat com.example.MyClass$2.apply(MyClass.java:31)\r\n\tat com.example.MyClass$2.apply(MyClass.java:23)\r\n\tat io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:121)\r\n\tat io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:63)\r\n\tat io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:246)\r\n\tat io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:10179)\r\n\tat io.reactivex.internal.operators.observable.ObservableSubscribeOn$1.run(ObservableSubscribeOn.java:39)\r\n\tat io.reactivex.Scheduler$1.run(Scheduler.java:134)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\nException in thread \"RxCachedThreadScheduler-1\" java.lang.IllegalStateException: illegal\r\n\tat com.example.MyClass$2.apply(MyClass.java:31)\r\n\tat com.example.MyClass$2.apply(MyClass.java:23)\r\n\tat io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:121)\r\n\tat io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:63)\r\n\tat io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:246)\r\n\tat io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:10179)\r\n\tat io.reactivex.internal.operators.observable.ObservableSubscribeOn$1.run(ObservableSubscribeOn.java:39)\r\n\tat io.reactivex.Scheduler$1.run(Scheduler.java:134)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)\r\n\tat io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n```\r\n\r\n\r\nsample code:\r\n\r\n```\r\n\r\npublic class MyClass {\r\n\r\n    static Disposable disposable = null;\r\n\r\n    public static void main(String[] args) {\r\n\r\n        Observable.just(1)\r\n                .subscribeOn(Schedulers.io())\r\n                .flatMap(new Function<Integer, ObservableSource<Integer>>() {\r\n                    @Override\r\n                    public ObservableSource<Integer> apply(Integer integer) throws Exception {\r\n                        long endTime = System.currentTimeMillis() + 500;\r\n                        while (System.currentTimeMillis() < endTime) {\r\n                        }\r\n                        return Observable.error(new IllegalStateException(\"example\"));\r\n                    }\r\n                })\r\n                .subscribe(new Observer<Integer>() {\r\n                    @Override\r\n                    public void onError(Throwable e) {}\r\n\r\n                    @Override\r\n                    public void onComplete() {}\r\n\r\n                    @Override\r\n                    public void onSubscribe(Disposable d) {\r\n                        disposable = d;\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(Integer integer) {}\r\n                });\r\n\r\n\r\n        try {\r\n            Thread.sleep(50);\r\n            disposable.dispose();\r\n            Thread.sleep(500000);\r\n        } catch (InterruptedException e) {\r\n        }\r\n    }\r\n}\r\n```","id":"200587521","title":"2.x Exception unhandled after dispose()","opened_on":"2017-01-13T09:47:52Z","closed_by":"akarnokd"},{"number":"4987","reopenOn":null,"comments":[{"date":"2017-01-12T18:12:15Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4987?src=pr) is 95.62% (diff: 100%)\n> Merging [#4987](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4987?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **<.01%**\n\n```diff\n@@                2.x      #4987   diff @@\n==========================================\n  Files           592        592          \n  Lines         37968      37968          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5752       5752          \n==========================================\n- Hits          36307      36306     -1   \n  Misses          701        701          \n- Partials        960        961     +1   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [5717827...4ea2a05](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/57178273acc7a4673d7f0247f295e5288657291a...4ea2a0597d0dec7426a5b86aa0679067d423cd24?src=pr)"},{"date":"2017-01-14T11:24:15Z","author":"ferhatparmak","text":"ya\n\nOn Jan 12, 2017 9:25 PM, \"David Karnok\" <notifications@github.com> wrote:\n\n> Merged #4987 <https:\/\/github.com\/ReactiveX\/RxJava\/pull\/4987>.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/ReactiveX\/RxJava\/pull\/4987#event-921159486>, or mute\n> the thread\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AGhr1dW7YfbfY8Ya_T8bHXvx8rQIVj_aks5rRnAfgaJpZM4LiArG>\n> .\n>\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-01-12T18:25:12Z","description":"This PR fixes `Observable.combineLatest` to be consistent with `Flowable.combineLatest` by not subscribing to additional input sources if the operator reached a terminal state due to a valueless source (that completes or errors). In addition, such early termination didn't properly cancel the other sources when `delayErrors == true`.\r\n\r\nI've also extended the documentation on the overloads to warn about empty sources that will terminate the operator, even with `combineLatestDelayError`, and thus subscription side-effects may not happen.\r\n\r\nThere is a related issue #4414 where the operator should fully consume each input source no matter what and terminate when all terminate. I'm still considering what would be the best way to introduce this.\r\n\r\nReported in #4986","id":"200427740","title":"2.x: make Obs.combineLatest consistent with Flowable + doc cornercase","opened_on":"2017-01-12T17:18:39Z","closed_by":"akarnokd"},{"number":"4986","reopenOn":null,"comments":[{"date":"2017-01-12T16:47:55Z","author":"akarnokd","text":"Hi.\r\n\r\n1) `doOnTerminate` executes before the terminal event is emitted, also != ˛`doFinally` which executes after.\r\n2) `Flowable.combineLatest` doesn't subscribe to the second source if the first terminates without any onNext item\r\n3) `Observable.combineLatest` is supposed to work like 2) but apparently doesn't, hence the extra error."},{"date":"2017-01-12T16:56:14Z","author":"StanislavChumarin","text":"Thanks for clarification. Mixed ```doOnTerminate``` and ```doAfterTerminate``` operators. \r\n\r\nStill I find behaviour of ```Observable.combineLatest``` wrong. That was main reason of this post.\r\nWill it be fixed?"},{"date":"2017-01-12T17:06:17Z","author":"akarnokd","text":"Yes, I'm working on the fix for 3)."},{"date":"2017-01-12T17:44:43Z","author":"StanislavChumarin","text":"Just was experimenting with ```combineLatestDelayError```\r\nLooks like this case also throws extra exception.\r\n\r\n``` Java\r\n @Test\r\n    public void testCombine2Flowable2Errors() throws Exception {\r\n        TestSubscriber<Integer> testObserver = TestSubscriber.create();\r\n\r\n        TestScheduler testScheduler = new TestScheduler();\r\n\r\n        Flowable<Integer> emptyFlowable = Flowable.timer(10, TimeUnit.MILLISECONDS, testScheduler)\r\n                .flatMap(aLong -> Flowable.error(new Exception()));\r\n        Flowable<Object> errorFlowable = Flowable.timer(100, TimeUnit.MILLISECONDS, testScheduler).map(aLong -> {\r\n            throw new Exception();\r\n        });\r\n\r\n        Flowable.combineLatestDelayError(\r\n                Arrays.asList(\r\n                        emptyFlowable\r\n                                .doOnEach(integerNotification -> System.out.println(\"emptyFlowable: \" + integerNotification))\r\n                                .doFinally(() -> System.out.println(\"emptyFlowable: doFinally\")),\r\n                        errorFlowable\r\n                                .doOnEach(integerNotification -> System.out.println(\"errorFlowable: \" + integerNotification))\r\n                                .doFinally(() -> System.out.println(\"errorFlowable: doFinally\"))),\r\n                objects -> 0\r\n        )\r\n                .doOnEach(integerNotification -> System.out.println(\"combineLatestDelayError: \" + integerNotification))\r\n                .doFinally(() -> System.out.println(\"combineLatestDelayError: doFinally\"))\r\n                .subscribe(testObserver);\r\n\r\n        testScheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\r\n\r\n        testObserver.awaitTerminalEvent();\r\n    }\r\n```\r\n\r\nOutput\r\n```\r\nemptyFlowable: OnErrorNotification[java.lang.Exception]\r\ncombineLatestDelayError: OnErrorNotification[java.lang.Exception]\r\ncombineLatestDelayError: doFinally\r\nemptyFlowable: doFinally\r\nerrorFlowable: OnErrorNotification[java.lang.Exception]\r\nerrorFlowable: doFinally\r\njava.lang.Exception\r\n\tat com.myproject.Test.testCombine2Flowable2Errors(Test.java:298)\r\n        at io.reactivex.internal.operators.flowable.FlowableMap$MapSubscriber.onNext(FlowableMap.java:62)\r\n\tat io.reactivex.internal.operators.flowable.FlowableTimer$TimerSubscriber.run(FlowableTimer.java:76)\r\n\tat io.reactivex.Scheduler$1.run(Scheduler.java:134)\r\n\tat io.reactivex.schedulers.TestScheduler.triggerActions(TestScheduler.java:115)\r\n\t\/\/ not really important Stacktrace\r\nException in thread \"main\" java.lang.Exception\r\n\tat com.myproject.Test.testCombine2Flowable2Errors(Test.java:298)\r\n        at io.reactivex.internal.operators.flowable.FlowableMap$MapSubscriber.onNext(FlowableMap.java:62)\r\n\tat io.reactivex.internal.operators.flowable.FlowableTimer$TimerSubscriber.run(FlowableTimer.java:76)\r\n\tat io.reactivex.Scheduler$1.run(Scheduler.java:134)\r\n\tat io.reactivex.schedulers.TestScheduler.triggerActions(TestScheduler.java:115)\r\n\t\/\/ repeat of not important Stacktrace\r\n```\r\n\r\nWithout timeouts it works as expected \r\n"},{"date":"2017-01-12T18:00:56Z","author":"akarnokd","text":"Yes, it looks like the other source is not cancelled in time.\r\n\r\nI've posted the fix PR as #4987 that resolves 3) and this latest case."},{"date":"2017-01-19T14:01:31Z","author":"akarnokd","text":"Closing via #4987 "}],"opened_by":"StanislavChumarin","reopen":false,"closed_on":"2017-01-19T14:01:31Z","description":"Observable.combineLatestDelayError sends error event after complete event happened and treated as unhandled.\r\nChecked on ```rx.Observable```, ```io.reactivex.Observable``` and ```Flowable```\r\n\r\n``` Java\r\n    @Test\r\n    public void testCombine() {\r\n        rx.observers.TestSubscriber<Integer> testSubscriber = rx.observers.TestSubscriber.create();\r\n\r\n        rx.Observable<Long> emptyObservable = rx.Observable.empty();\r\n        rx.Observable<Object> errorObservable = rx.Observable.error(new Exception());\r\n\r\n        rx.Observable.combineLatestDelayError(\r\n                Arrays.asList(\r\n                        emptyObservable\r\n                                .doOnEach(integerNotification -> System.out.println(\"emptyObservable: \" + integerNotification))\r\n                                .doOnTerminate(() -> System.out.println(\"emptyObservable: doFinally\")),\r\n                        errorObservable\r\n                                .doOnEach(integerNotification -> System.out.println(\"errorObservable: \" + integerNotification))\r\n                                .doOnTerminate(() -> System.out.println(\"errorObservable: doFinally\"))),\r\n                objects -> 0\r\n        )\r\n                .doOnEach(integerNotification -> System.out.println(\"combineLatestDelayError: \" + integerNotification))\r\n                .doOnTerminate(() -> System.out.println(\"combineLatestDelayError: doFinally\"))\r\n                .subscribe(testSubscriber);\r\n\r\n        testSubscriber.awaitTerminalEvent();\r\n    }\r\n\r\n    @Test\r\n    public void testCombine2() {\r\n        TestObserver<Integer> testObserver = TestObserver.create();\r\n\r\n        Observable<Long> emptyObservable = Observable.empty();\r\n        Observable<Object> errorObservable = Observable.error(new Exception());\r\n\r\n        Observable.combineLatestDelayError(\r\n                Arrays.asList(\r\n                        emptyObservable\r\n                                .doOnEach(integerNotification -> System.out.println(\"emptyObservable: \" + integerNotification))\r\n                                .doFinally(() -> System.out.println(\"emptyObservable: doFinally\")),\r\n                        errorObservable\r\n                                .doOnEach(integerNotification -> System.out.println(\"errorObservable: \" + integerNotification))\r\n                                .doFinally(() -> System.out.println(\"errorObservable: doFinally\"))),\r\n                objects -> 0\r\n        )\r\n                .doOnEach(integerNotification -> System.out.println(\"combineLatestDelayError: \" + integerNotification))\r\n                .doFinally(() -> System.out.println(\"combineLatestDelayError: doFinally\"))\r\n                .subscribe(testObserver);\r\n\r\n        testObserver.awaitTerminalEvent();\r\n    }\r\n\r\n    @Test\r\n    public void testCombine2Flowable() {\r\n        TestSubscriber<Integer> testObserver = TestSubscriber.create();\r\n\r\n        Flowable<Integer> emptyFlowable = Flowable.empty();\r\n        Flowable<Object> errorFlowable = Flowable.error(new Exception());\r\n\r\n        Flowable.combineLatestDelayError(\r\n                Arrays.asList(\r\n                        emptyFlowable\r\n                                .doOnEach(integerNotification -> System.out.println(\"emptyFlowable: \" + integerNotification))\r\n                                .doFinally(() -> System.out.println(\"emptyFlowable: doFinally\")),\r\n                        errorFlowable\r\n                                .doOnEach(integerNotification -> System.out.println(\"errorFlowable: \" + integerNotification))\r\n                                .doFinally(() -> System.out.println(\"errorFlowable: doFinally\"))),\r\n                objects -> 0\r\n        )\r\n                .doOnEach(integerNotification -> System.out.println(\"combineLatestDelayError: \" + integerNotification))\r\n                .doFinally(() -> System.out.println(\"combineLatestDelayError: doFinally\"))\r\n                .subscribe(testObserver);\r\n\r\n        testObserver.awaitTerminalEvent();\r\n    }\r\n```\r\n\r\nOutput:\r\ntestCombine\r\n```\r\nemptyObservable: [rx.Notification@2b4a2ec7 OnCompleted]\r\nemptyObservable: doFinally\r\ncombineLatestDelayError: [rx.Notification@2b4a2ec7 OnCompleted]\r\ncombineLatestDelayError: doFinally\r\n```\r\ntestCombine2\r\n```\r\nemptyObservable: OnCompleteNotification\r\ncombineLatestDelayError: OnCompleteNotification\r\ncombineLatestDelayError: doFinally\r\nemptyObservable: doFinally\r\nerrorObservable: OnErrorNotification[java.lang.Exception]\r\nerrorObservable: doFinally\r\njava.lang.Exception\r\n\tat com.myproject.Test.testCombine2(Test.java:298)\r\n\t\/\/ not really important Stacktrace\r\nException in thread \"main\" java.lang.Exception\r\n\tat com.myproject.Test.testCombine2(Test.java:298)\r\n\t\/\/ repeat of not important Stacktrace\r\n```\r\ntestCombine2Flowable\r\n```\r\nemptyFlowable: OnCompleteNotification\r\ncombineLatestDelayError: OnCompleteNotification\r\ncombineLatestDelayError: doFinally\r\nemptyFlowable: doFinally\r\n```\r\n\r\nIf error emitter goes first or add some timer instead of empty, then everything is ok. \r\n\r\nAlso noticed difference in events order between 1.x and 2.x. Is it correct?","id":"200409107","title":"2.x Observable.combineLatestDelayError delivers Error after completion","opened_on":"2017-01-12T16:11:19Z","closed_by":"akarnokd"},{"number":"4984","reopenOn":null,"comments":[{"date":"2017-01-12T09:32:46Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4984?src=pr) is 95.55% (diff: 100%)\n> Merging [#4984](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4984?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.07%**\n\n```diff\n@@                2.x      #4984   diff @@\n==========================================\n  Files           592        592          \n  Lines         37968      37968          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5752       5752          \n==========================================\n- Hits          36307      36279    -28   \n- Misses          701        735    +34   \n+ Partials        960        954     -6   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [5717827...0664155](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/57178273acc7a4673d7f0247f295e5288657291a...066415533f473c5a53c19bec6e967c5e487e46fb?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-01-12T18:24:55Z","description":"When `flatMap` and `zip` fuses its sources, it was possible one of the async source polls on another source which executed boundary-sensitive operators (`map`, `filter`) on the wrong thread.\r\n\r\nFor clarity, here is a diagram showing the execution flow of a classical and fused setup:\r\n\r\n![image](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/21883621\/536a123c-d8b0-11e6-9a7a-b6deb2ffb26b.png)\r\n\r\nIn the classical flow, everything is push and when flatMap collects the available elements, all side-effects happened inside `map`.\r\n\r\nIn the fused flow, there are no queues and the onNext call is an indication to `poll()` on the sources inside `flatMap` (or zip). If the first source triggers onNext, that source is correctly polled and `map` executes on the right thread. However, when the flatMap continues to collect other available elements, it polls on the other source and executes that `map` still on the first scheduler, despite that source having its own scheduler specified.\r\n\r\nThe solution is to mark `flatMap` and `zip`'s inner consumer as boundary sensitive which prevents the fusion above since `map` is also marked as boundary sensitive.\r\n\r\nRelated: https:\/\/github.com\/reactor\/reactor-core\/issues\/342","id":"200315269","title":"2.x: fix cross-boundary invalid fusion with observeOn, flatMap & zip","opened_on":"2017-01-12T09:20:39Z","closed_by":"akarnokd"},{"number":"4982","reopenOn":null,"comments":[{"date":"2017-01-11T16:53:56Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4982?src=pr) is 95.65% (diff: 100%)\n> Merging [#4982](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4982?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.10%**\n\n```diff\n@@                2.x      #4982   diff @@\n==========================================\n  Files           592        592          \n  Lines         37977      37968     -9   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5754       5752     -2   \n==========================================\n+ Hits          36287      36320    +33   \n+ Misses          720        700    -20   \n+ Partials        970        948    -22   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [0a254a8...64cf7cb](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/0a254a83e5bf2e3d8b2540b34718ed0c9d71b4ce...64cf7cb6bf2e8ff15e71a3f7e4a818dd290a00ed?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-01-11T19:34:33Z","description":"The operator `Observable.concatMapEager` had a bad optimization targeting scalar and callable sources and emitted their values immediately even if it wasn't that particular source's turn for it.\r\n\r\nThe `Flowable` is not affected, added unit tests for both.\r\n\r\nReported in #4981.","id":"200143120","title":"2.x: fix Observable.concatMapEager bad logic for immediate scalars","opened_on":"2017-01-11T16:36:20Z","closed_by":"akarnokd"},{"number":"4981","reopenOn":null,"comments":[{"date":"2017-01-11T16:29:23Z","author":"akarnokd","text":"Thanks for the feedback. This is indeed a bug with `Observable.concatMapEager()`. `Flowable` works properly.\r\n\r\nI'll post a fix shortly. A workaround is to use `just(i).hide()` to break the bad\/false internal optimization."},{"date":"2017-01-11T19:35:07Z","author":"akarnokd","text":"Closing via #4982"}],"opened_by":"ansman","reopen":false,"closed_on":"2017-01-11T19:35:08Z","description":"Sample code (using RxJava 2.0.4):\r\n```java\r\nObservable.just(1, 2, 3, 4, 5)\r\n        .concatMapEager(i -> {\r\n            System.out.println(\"Processing \" + i);\r\n            return i == 3 ? Observable.just(i) : Observable\r\n                    .just(i)\r\n                    .delay(1, TimeUnit.MILLISECONDS, Schedulers.io());\r\n        })\r\n        .observeOn(Schedulers.io())\r\n        .subscribe(i -> System.out.println(\"Value: \" + i));\r\n```\r\n\r\nExpected output:\r\n```\r\nProcessing 1\r\nProcessing 2\r\nProcessing 3\r\nProcessing 4\r\nProcessing 5\r\nValue: 1\r\nValue: 2\r\nValue: 3\r\nValue: 4\r\nValue: 5\r\n```\r\n\r\nActual output:\r\n```\r\nProcessing 1\r\nProcessing 2\r\nProcessing 3\r\nProcessing 4\r\nProcessing 5\r\nValue: 3\r\nValue: 1\r\nValue: 2\r\nValue: 4\r\nValue: 5\r\n```\r\n\r\nAs you can see the order is incorrect. This is due to the fact that the item `3` is mapped to a `Callable` source which won't wait for the previous observables.","id":"200075366","title":"2.x Observable#concatMapEager doesn't always preserve order","opened_on":"2017-01-11T12:01:35Z","closed_by":"akarnokd"},{"number":"4970","reopenOn":null,"comments":[{"date":"2017-01-08T10:26:57Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4970?src=pr) is 95.58% (diff: 100%)\n> Merging [#4970](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4970?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.05%**\n\n```diff\n@@                2.x      #4970   diff @@\n==========================================\n  Files           591        591          \n  Lines         37959      37956     -3   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5756       5753     -3   \n==========================================\n+ Hits          36264      36282    +18   \n+ Misses          721        712     -9   \n+ Partials        974        962    -12   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [d173b6d...29037ba](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d173b6d4f8713907f7a38e00da65c30abfb4a7e2...29037ba28becbddc00a8d99035fcd436485816bf?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-01-08T14:44:43Z","description":"This PR fixes the lack of null check on the result of the `combiner` function as well as fixes the lifecycle of the `FlowableWithLatestFrom` to avoid races with the `onSubscribe`.","id":"199414093","title":"2.x: fix withLatestFrom null checks, lifecycle","opened_on":"2017-01-08T10:15:44Z","closed_by":"akarnokd"},{"number":"4969","reopenOn":null,"comments":[{"date":"2017-01-08T02:50:20Z","author":"hzsweers","text":"Specifically, the static `WithLatestFromObserver` class in `ObservableWithLatestFrom` never calls `OnSubscribe` on its `actual` before sending other events to it."},{"date":"2017-01-08T10:12:37Z","author":"akarnokd","text":"The main problem is that `withLatestFrom` doesn't check for null returned by the `combiner`. I'll post a PR shortly."},{"date":"2017-01-08T10:13:58Z","author":"hzsweers","text":":+1: thanks!"},{"date":"2017-01-08T23:37:50Z","author":"hzsweers","text":"Fixed in #4970"}],"opened_by":"hzsweers","reopen":false,"closed_on":"2017-01-09T06:29:50Z","description":"We're seeing an NPE from the `s` field of `SerializedObserver` not being set when used with `.withLatestFrom()`. Digging around in the source, it looks like it internally is not calling `onSubscribe()` to the `actual` observer field.\r\n\r\nExample trace looks like this:\r\n\r\n```\r\njava.lang.NullPointerException\r\n\tat io.reactivex.observers.SerializedObserver.onNext(SerializedObserver.java:91)\r\n\tat io.reactivex.internal.operators.observable.ObservableWithLatestFrom$WithLatestFromObserver.onNext(ObservableWithLatestFrom.java:101)\r\n\tat io.reactivex.internal.operators.observable.ObservableFilter$FilterObserver.onNext(ObservableFilter.java:51)\r\n\tat io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:63)\r\n\tat io.reactivex.subjects.PublishSubject$PublishDisposable.onNext(PublishSubject.java:263)\r\n\tat io.reactivex.subjects.PublishSubject.onNext(PublishSubject.java:182)\r\n```\r\n\r\nThe snippet in `SerializedObserver` that corresponds to\r\n\r\n```java\r\n    @Override\r\n    public void onNext(T t) {\r\n        if (done) {\r\n            return;\r\n        }\r\n        if (t == null) {\r\n            s.dispose();  \/\/ <----- this line, \"s\" is null because onSubscribe was never called\r\n            onError(new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"));\r\n            return;\r\n        }\r\n```","id":"199399049","title":"2.x: WithLatestFrom not calling onSubscribe() on `actual` observer","opened_on":"2017-01-08T02:48:39Z","closed_by":"hzsweers"},{"number":"4962","reopenOn":null,"comments":[{"date":"2017-01-06T08:54:36Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4962?src=pr) is 95.60% (diff: 100%)\n> Merging [#4962](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4962?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **<.01%**\n\n```diff\n@@                2.x      #4962   diff @@\n==========================================\n  Files           587        587          \n  Lines         37669      37671     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5675       5676     +1   \n==========================================\n  Hits          36016      36016          \n- Misses          693        704    +11   \n+ Partials        960        951     -9   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [71330c0...7818169](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/71330c06186d72548a3443e8b22ef52d995d0e64...781816999ae4a1caaed286db04d95c2536184d18?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-01-06T18:39:59Z","description":"This PR fixes the double termination of `Single.takeUntil(Publisher)` when the `other` fires an item and then completes while ignoring the cancellation in between, trying to signal a `CancellationException` again which is routed to the `RxJavaPlugins.onError` and crashing on Android.\r\n\r\nIn addition, the `Maybe.takeUntil()` received a unit test verifying this doesn't also happen to it.\r\n\r\nRelated: #4961.","id":"199149558","title":"2.x: fix Single.takeUntil() other triggering twice","opened_on":"2017-01-06T08:42:49Z","closed_by":"akarnokd"},{"number":"4961","reopenOn":null,"comments":[{"date":"2017-01-06T07:32:00Z","author":"akarnokd","text":"Please provide the crash stacktrace."},{"date":"2017-01-06T23:09:36Z","author":"akarnokd","text":"Closing via #4962"}],"opened_by":"suckgamony","reopen":false,"closed_on":"2017-01-06T23:09:36Z","description":"```java\r\nSingle<T> main;\r\nFlowable<T> other;\r\n\r\nmain.takeUntil(other.take(1)).subscribe(...);\r\n```\r\n\r\nThis pseudo-code crashes when `other` emits an item. `SingleTakeUntil.TakeUntilOtherSubscriber.onCompleted()` is called twice and second call generate a crash. Please fix this.","id":"199127804","title":"2.0.3 Single.takeUntil() crashes ","opened_on":"2017-01-06T05:35:54Z","closed_by":"akarnokd"},{"number":"4957","reopenOn":null,"comments":[{"date":"2017-01-04T14:48:36Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4957?src=pr) is 95.68% (diff: 100%)\n> Merging [#4957](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4957?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.05%**\n\n```diff\n@@                2.x      #4957   diff @@\n==========================================\n  Files           587        587          \n  Lines         37551      37551          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5655       5655          \n==========================================\n- Hits          35950      35929    -21   \n- Misses          676        685     +9   \n- Partials        925        937    +12   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [19fac95...f7287ce](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/19fac95ca82bf40e9837280f5d33e0bfdc81db39...f7287cee196325943db19bb2eabb3dd43aeda1a8?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-01-04T15:01:33Z","description":"This PR changes the `LambdaObserver` to not dispose the upstream when it receives a terminal event. The `LambdaSubscriber` has been previoulsy updated but apparently not synced.\r\n\r\nReported in #4956.\r\n\r\nThis PR fixes 2 unit test methods of `Flowable.ignoreElements()` as they were not actually testing the operator (discovered when the `Observable.ignoreElements()` initially failed after the patch to `LambdaObserver`).","id":"198718584","title":"2.x: fix LambdaObserver calling dispose when terminating","opened_on":"2017-01-04T14:24:05Z","closed_by":"akarnokd"},{"number":"4956","reopenOn":null,"comments":[{"date":"2017-01-04T13:57:52Z","author":"akarnokd","text":"Indeed, `Observable` behaves differently from `Flowable`:\r\n\r\n```\r\nFlowable.onError\r\nFlowable.doFinally\r\n\r\nFlowable.onNext\r\nFlowable.onComplete\r\nFlowable.doFinally\r\n```\r\n\r\nI'll post a fix shortly."},{"date":"2017-01-04T14:24:27Z","author":"akarnokd","text":"See #4957"},{"date":"2017-01-04T15:22:28Z","author":"akarnokd","text":"Closing via #4957"}],"opened_by":"StanislavChumarin","reopen":false,"closed_on":"2017-01-04T15:22:28Z","description":"Recently discovered behaviour that brings incorrect order for Observable.doFinally\r\n\r\nHere is code to check\r\n``` Java\r\n    @Test\r\n    public void operationFinallyOrder() throws Exception {\r\n        Single.error(new RuntimeException())\r\n                .doOnDispose(() -> System.out.println(\"Single.doOnDispose\"))\r\n                .doFinally(() -> System.out.println(\"Single.doFinally\"))\r\n                .subscribe(o -> System.out.println(\"Single.onSuccess\"),\r\n                        t -> System.out.println(\"Single.onError\"));\r\n        System.out.println();\r\n\r\n        Completable.error(new RuntimeException())\r\n                .doOnDispose(() -> System.out.println(\"Completable.doOnDispose\"))\r\n                .doFinally(() -> System.out.println(\"Completable.doFinally\"))\r\n                .subscribe(() -> System.out.println(\"Completable.onComplete\"),\r\n                        t -> System.out.println(\"Completable.onError\"));\r\n        System.out.println();\r\n\r\n        Observable.error(new RuntimeException())\r\n                .doOnDispose(() -> System.out.println(\"Observable.doOnDispose\"))\r\n                .doFinally(() -> System.out.println(\"Observable.doFinally\"))\r\n                .subscribe(o -> System.out.println(\"Observable.onNext\"),\r\n                        t -> System.out.println(\"Observable.onError\"),\r\n                        () -> System.out.println(\"Observable.onComplete\"));\r\n        System.out.println();\r\n\r\n        Observable.just(new Object())\r\n                .doOnDispose(() -> System.out.println(\"Observable.doOnDispose\"))\r\n                .doFinally(() -> System.out.println(\"Observable.doFinally\"))\r\n                .subscribe(o -> System.out.println(\"Observable.onNext\"),\r\n                        t -> System.out.println(\"Observable.onError\"),\r\n                        () -> System.out.println(\"Observable.onComplete\"));\r\n    }\r\n```\r\nOutput:\r\n```\r\nSingle.onError\r\nSingle.doFinally\r\n\r\nCompletable.onError\r\nCompletable.doFinally\r\n\r\nObservable.doOnDispose\r\nObservable.doFinally\r\nObservable.onError\r\n\r\nObservable.onNext\r\nObservable.doOnDispose\r\nObservable.doFinally\r\nObservable.onComplete\r\n```\r\nAs you can see, order and amount of messages for Single and Completable are correct, but ```LambdaObserver``` calls dispose before terminal event. That triggers doFinally too early. \r\nAccording to new lifecycle (confirmed here https:\/\/github.com\/ReactiveX\/RxJava\/issues\/4811) no messages Observable.doOnDispose should be there.\r\n","id":"198710074","title":"RxJava 2.0.4 Observable calls dispose before terminal event.","opened_on":"2017-01-04T13:43:13Z","closed_by":"akarnokd"},{"number":"4945","reopenOn":null,"comments":[{"date":"2016-12-29T18:45:38Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4945?src=pr) is 95.57% (diff: 100%)\n> Merging [#4945](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4945?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.03%**\n\n```diff\n@@                2.x      #4945   diff @@\n==========================================\n  Files           587        587          \n  Lines         37549      37551     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5655       5655          \n==========================================\n- Hits          35904      35891    -13   \n- Misses          692        702    +10   \n- Partials        953        958     +5   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [a9f1f4f...983b6b0](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a9f1f4f151cecf3fcfc59fcf085fc9cac9223d08...983b6b0cd8f671a181dbcd54d6cd68dd2981bb6c?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-12-29T19:29:50Z","description":"This PR fixes the lack of dispose\/cancel call towards the upstream in the timed+fallback `timeout` operator version.\r\n\r\nIn addition, the selector version received similar unit tests to ensure they work properly (they did).\r\n\r\nRelated: #4944.","id":"198049596","title":"2.x: fix timeout with fallback not cancelling the main source","opened_on":"2016-12-29T18:33:46Z","closed_by":"akarnokd"},{"number":"4944","reopenOn":null,"comments":[{"date":"2016-12-29T18:30:47Z","author":"akarnokd","text":"Thanks for reporting. This is a bug with the fallback version of the `timeout` operator, both in `Observable` and `Flowable`. The fix is underway."},{"date":"2016-12-29T19:38:58Z","author":"akarnokd","text":"Closing via #4945"}],"opened_by":"mbezzubenko","reopen":false,"closed_on":"2016-12-29T19:38:58Z","description":"Please have a look at this sample:\r\n\r\n    public void testSubject() {\r\n        io.reactivex.subjects.PublishSubject<Integer> subject = io.reactivex.subjects.PublishSubject.create();       \r\n        subject\r\n                .timeout(10, TimeUnit.SECONDS, io.reactivex.Observable.error(new RuntimeException()))\r\n                .takeWhile(integer -> integer < 3)\r\n                .toList()\r\n                .subscribe(integers -> System.out.println(integers), throwable -> System.out.println(\"throwable\"));\r\n\r\n        subject.onNext(0);\r\n        subject.onNext(1);\r\n        subject.onNext(2);\r\n        subject.onNext(3);\r\n\r\n        subject.onError(new RuntimeException());\r\n    }\r\n`\r\nIt is expected, that after posting value '3' chain emits result [0, 1, 2] and unsubscribes from the subject and subsequent posting of RuntimeException doesn't push it anywhere and doesn't throw it.\r\n\r\nBut on v2.0.3 it crashes with RuntimeException\r\n\r\nThe same test with rx.subjects.PublishSubject on v1.2.4 works as expected\r\n\r\nIf remove timeout from the chain everything works as expected.\r\n\r\nThanks","id":"198043146","title":"Using Observable.timeout could cause uncaught exception in RxJava 2.x","opened_on":"2016-12-29T17:42:35Z","closed_by":"akarnokd"},{"number":"4943","reopenOn":null,"comments":[{"date":"2016-12-29T16:21:25Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4943?src=pr) is 95.50% (diff: 100%)\n> Merging [#4943](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4943?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.11%**\n\n```diff\n@@                2.x      #4943   diff @@\n==========================================\n  Files           587        587          \n  Lines         37540      37549     +9   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5652       5655     +3   \n==========================================\n- Hits          35896      35863    -33   \n- Misses          694        723    +29   \n- Partials        950        963    +13   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [4851637...f5f753c](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/48516372b9770a0f442bea06f7f93b3d27d6ed32...f5f753c0e7a31d333f89a7b979c2c46c5a3d34c9?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-12-29T16:41:04Z","description":"I was working on converting the [Monte Carlo PI benchmark](http:\/\/swave.io\/usage\/show-off\/monte-carlo-pi.html) to RxJava 2 and it turned out I forgot to replenish the internal queue of `publish(Function)` in case the upstream was not sync-fuseable.\r\n\r\nThis PR fixes the replenishment problem for non-fused and async-fused sources by requesting after 75% consumption.\r\n\r\nIn addition, if an inner subscriber cancelled while it was at request 0, the other inner subscribers might not have resumed draining.\r\n\r\nI've also fixed two unit tests with wrong timeout unit of measure that randomly failed the tests on a slow machine or travis (#4902).","id":"198030072","title":"2.x: fix publish(Function) not replenishing its queue","opened_on":"2016-12-29T16:09:51Z","closed_by":"akarnokd"},{"number":"4941","reopenOn":null,"comments":[{"date":"2016-12-28T21:00:04Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4941?src=pr) is 84.23% (diff: 33.33%)\n> Merging [#4941](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4941?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will decrease coverage by **0.03%**\n\n```diff\n@@                1.x      #4941   diff @@\n==========================================\n  Files           288        288          \n  Lines         17804      17806     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2697       2698     +1   \n==========================================\n- Hits          15004      14999     -5   \n- Misses         1952       1953     +1   \n- Partials        848        854     +6   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [4406bcb...0bce846](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/4406bcb672b7e8e31830ba313e5bd7ebbaf3063a...0bce846d507f301f5dc0a51f0adb684c85b9aefa?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-12-28T21:03:45Z","description":"This PR fixes the unconditional use of `MpscLinkedQueue` when Unsafe is not available or has been disabled inside `CompletableOnSubscribeMergeDelayErrorIterable`.\r\n\r\nRelated: #4940","id":"197905179","title":"1.x: Completable.mergeDelayError check unsafe availability","opened_on":"2016-12-28T19:37:39Z","closed_by":"akarnokd"},{"number":"4940","reopenOn":null,"comments":[{"date":"2016-12-28T19:24:58Z","author":"akarnokd","text":"Thanks. The operator `CompletableOnSubscribeMergeDelayErrorIterable` doesn't properly switch on the unsafe settings. I'll post a fix shortly."},{"date":"2016-12-28T21:04:06Z","author":"akarnokd","text":"Closing via #4941"}],"opened_by":"mstrdev","reopen":false,"closed_on":"2016-12-28T21:04:06Z","description":" - version 1.2.4\r\n\r\nIssue reproduced with android app on device \"Lenovo IdeaTab s6000-H\". I solve many problems with Unsafe by setting \"rx.unsafe-disable\" flag. But BaseLinkedQueueProducerNodeRef ignored this flag. And I received this:\r\n\r\n\r\n```\r\nE\/AndroidRuntime: FATAL EXCEPTION: RxIoScheduler-7\r\nava.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\r\n   at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\r\n   at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)\r\n   at java.util.concurrent.FutureTask.run(FutureTask.java:234)\r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153)\r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267)\r\n   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\r\n   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\r\n   at java.lang.Thread.run(Thread.java:838)\r\nCaused by: java.lang.ExceptionInInitializerError\r\n   at rx.internal.operators.CompletableOnSubscribeMergeDelayErrorIterable.call(CompletableOnSubscribeMergeDelayErrorIterable.java:56)\r\n   at rx.internal.operators.CompletableOnSubscribeMergeDelayErrorIterable.call(CompletableOnSubscribeMergeDelayErrorIterable.java:27)\r\n   at rx.Completable.unsafeSubscribe(Completable.java:2037)\r\n   at rx.Completable$31$1.call(Completable.java:2149)\r\n   at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:230)\r\n   at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n   at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390) \r\n   at java.util.concurrent.FutureTask.run(FutureTask.java:234) \r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153) \r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267) \r\n   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080) \r\n   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573) \r\n   at java.lang.Thread.run(Thread.java:838) \r\nCaused by: java.lang.NullPointerException\r\n   at rx.internal.util.unsafe.UnsafeAccess.addressOf(UnsafeAccess.java:113)\r\n   at rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef.<clinit>(BaseLinkedQueue.java:33)\r\n   at rx.internal.operators.CompletableOnSubscribeMergeDelayErrorIterable.call(CompletableOnSubscribeMergeDelayErrorIterable.java:56) \r\n   at rx.internal.operators.CompletableOnSubscribeMergeDelayErrorIterable.call(CompletableOnSubscribeMergeDelayErrorIterable.java:27) \r\n   at rx.Completable.unsafeSubscribe(Completable.java:2037) \r\n   at rx.Completable$31$1.call(Completable.java:2149) \r\n   at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:230) \r\n   at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55) \r\n   at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390) \r\n   at java.util.concurrent.FutureTask.run(FutureTask.java:234) \r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153) \r\n   at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267) \r\n   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080) \r\n   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573) \r\n   at java.lang.Thread.run(Thread.java:838) \r\n```\r\n\r\nI think that problem with line 33 which directly invoke  Unsafe methods:\r\n```\r\n  protected final static long P_NODE_OFFSET = UnsafeAccess.addressOf(BaseLinkedQueueProducerNodeRef.class, \"producerNode\");\r\n```\r\n","id":"197902038","title":"BaseLinkedQueueProducerNodeRef  ignored flag rx.unsafe-disable","opened_on":"2016-12-28T19:13:59Z","closed_by":"akarnokd"},{"number":"4932","reopenOn":null,"comments":[{"date":"2016-12-20T18:24:52Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4932?src=pr) is 95.60% (diff: 95.45%)\n> Merging [#4932](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4932?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **<.01%**\n\n```diff\n@@                2.x      #4932   diff @@\n==========================================\n  Files           587        587          \n  Lines         37519      37540    +21   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5644       5652     +8   \n==========================================\n+ Hits          35866      35889    +23   \n+ Misses          705        699     -6   \n- Partials        948        952     +4   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [a902d4a...eda6ed8](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a902d4aac034f8585b727e4fc43c53fe20a4db36...eda6ed8a4b3a35b7459ab23fbd60d046b5260d7a?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-12-21T08:28:14Z","description":"`Flowable.generate()` and `Observable.generate()` lacked the safeguards that were present in 1.x. This adds those and adds extra state cleanup.\r\n\r\nRelated: #4931","id":"196741643","title":"2.x: add safeguards to generate()","opened_on":"2016-12-20T18:12:31Z","closed_by":"akarnokd"},{"number":"4931","reopenOn":null,"comments":[{"date":"2016-12-20T17:45:26Z","author":"akarnokd","text":"Thanks, this is a bug with `generate` not having the necessary safeguards. I'll post a fix shortly."},{"date":"2016-12-21T09:08:21Z","author":"akarnokd","text":"Closing via #4932"}],"opened_by":"smiklos","reopen":false,"closed_on":"2016-12-21T09:08:21Z","description":"I'm using RxJava version 2.0.2 and wanted to implement a some logic using `Flowable.generate`.\r\n\r\nBased on the documentation, if I emit more than one item in when calling onNext on the emitter instance, I should get an `IllegalStateException`, but in reality I experience a different behavior:\r\n\r\nTaking this example:\r\n\r\n```\r\n Flowable<Object> test = Flowable.generate(emitter -> {\r\n            emitter.onNext(\"test\");\r\n            emitter.onNext(\"test more\");\r\n        }).observeOn(Schedulers.io(), false,5)\r\n          .doOnNext(System.out::println);\r\n        test.blockingSubscribe();\r\n```\r\n\r\nI get this error: `io.reactivex.exceptions.MissingBackpressureException: Queue is full?!`\r\n\r\nand if I just try: \r\n```\r\n    Flowable<Object> test = Flowable.generate(emitter -> {\r\n            emitter.onNext(\"test\");\r\n            emitter.onNext(\"test more\");\r\n        })\r\n       .doOnNext(System.out::println);\r\n        test.subscribe();\r\n```\r\nthen it just pushes the values indefinitely.\r\n","id":"196730836","title":"Problem with Flowable.generate() (RxJava 2)","opened_on":"2016-12-20T17:22:55Z","closed_by":"akarnokd"},{"number":"4927","reopenOn":null,"comments":[{"date":"2016-12-19T08:31:10Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4927?src=pr) is 95.55% (diff: 100%)\n> Merging [#4927](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4927?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.13%**\n\n```diff\n@@                2.x      #4927   diff @@\n==========================================\n  Files           586        586          \n  Lines         37446      37452     +6   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5625       5627     +2   \n==========================================\n- Hits          35829      35786    -43   \n- Misses          674        712    +38   \n- Partials        943        954    +11   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [7d47932...68a0d8a](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7d479322d8f5649a8a21f8ba13b4ff6b6657168a...68a0d8ae7219cf7080a45e97de04b3b5e597117e?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-12-20T08:31:27Z","description":"Both `Observable.timer()` and `Flowable.timer()` could report `IllegalStateException` because if the delayed task completed before the task's `Disposable` was set, the `setOnce` found a non-null, non-terminal reference already set.\r\n\r\nRelated: #4926.","id":"196354913","title":"2.x: fix timer() ISE due to bad resource mgmt","opened_on":"2016-12-19T08:19:51Z","closed_by":"akarnokd"},{"number":"4926","reopenOn":null,"comments":[{"date":"2016-12-19T08:07:48Z","author":"akarnokd","text":"Thanks for reporting. If the emission happens before the `setResource` call, the `setResource` will find the wrong reference there and complain about it. I'll fix it shortly."},{"date":"2016-12-21T09:08:33Z","author":"akarnokd","text":"Closing via #4927"},{"date":"2017-01-03T23:13:54Z","author":"guidedways","text":"Tried v2.0.2 in production and seeing a lot of these crashes come up. I know this has been fixed, but do we have an ETA for v2.0.4? Thank you."},{"date":"2017-01-03T23:18:39Z","author":"JakeWharton","text":"See https:\/\/github.com\/ReactiveX\/RxJava\/issues\/4947"}],"opened_by":"nhaarman","reopen":false,"closed_on":"2016-12-21T09:08:33Z","description":"- Library version 2.0.3\r\n\r\nThe following test occasionally fails (about 200 out of 1000 fail):\r\n\r\n```kotlin\r\n@Test\r\nfun test() {\r\n    var t: Throwable? = null\r\n    RxJavaPlugins.setErrorHandler { t = it }\r\n    Observable.timer(0L, MILLISECONDS).blockingFirst()\r\n    t?.let { throw it }\r\n}\r\n```\r\n\r\nStacktrace:\r\n\r\n```\r\njava.lang.IllegalStateException: Disposable already set!\r\n\r\n\tat io.reactivex.internal.disposables.DisposableHelper.reportDisposableSet(DisposableHelper.java:144)\r\n\tat io.reactivex.internal.disposables.DisposableHelper.setOnce(DisposableHelper.java:70)\r\n\tat io.reactivex.internal.operators.observable.ObservableTimer$IntervalOnceObserver.setResource(ObservableTimer.java:74)\r\n\tat io.reactivex.internal.operators.observable.ObservableTimer.subscribeActual(ObservableTimer.java:40)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:10514)\r\n\tat io.reactivex.Observable.blockingFirst(Observable.java:4535)\r\n\tat myapp.MyTest.test(MyTest.kt:15)\r\n```\r\n\r\nWhenever the test fails, [IntervalOnceObserver#setResource](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/2.x\/src\/main\/java\/io\/reactivex\/internal\/operators\/observable\/ObservableTimer.java#L40) is called _after_ it is disposed.","id":"196350516","title":"[2.x] IllegalStateException on Observable.timer with 0 milliseconds","opened_on":"2016-12-19T07:48:07Z","closed_by":"akarnokd"},{"number":"4924","reopenOn":null,"comments":[{"date":"2016-12-16T13:38:44Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4924?src=pr) is 95.58% (diff: 100%)\n> Merging [#4924](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4924?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.08%**\n\n```diff\n@@                2.x      #4924   diff @@\n==========================================\n  Files           586        586          \n  Lines         37446      37446          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5625       5625          \n==========================================\n- Hits          35823      35792    -31   \n- Misses          683        698    +15   \n- Partials        940        956    +16   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [1875256...4489b35](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/1875256f3c6a64f56c75585d8f1d00a8d506c68d...4489b350fd272633a855c8cc3441166f232e5307?src=pr)"}],"opened_by":"vanniktech","reopen":false,"closed_on":"2016-12-16T17:25:07Z","description":"Changing `Completable` to `CompletableSource`. Also found one other wrong spot that I fixed within this PR.\r\n\r\nFixes #4923 ","id":"196058514","title":"2.x: Change Completable to CompletableSource","opened_on":"2016-12-16T13:24:49Z","closed_by":"akarnokd"},{"number":"4923","reopenOn":null,"comments":[{"date":"2016-12-16T12:41:10Z","author":"akarnokd","text":"I don't think there are any `CompletableSource` implementations other than RxJava but you are welcome to send a PR."},{"date":"2016-12-16T13:18:32Z","author":"vanniktech","text":"Well it's mostly for consistency and I'll send one right away."},{"date":"2016-12-16T17:25:44Z","author":"akarnokd","text":"Closing via #4924"}],"opened_by":"vanniktech","reopen":false,"closed_on":"2016-12-16T17:25:44Z","description":"The signature looks like this:\r\n\r\n`final Function<? super T, ? extends Completable> mapper`\r\n\r\nalthough it should be \r\n\r\n`final Function<? super T, ? extends CompletableSource> mapper`","id":"196049683","title":"2.x Single.flatMapCompletable expects Completable instead of CompletableSource","opened_on":"2016-12-16T12:33:15Z","closed_by":"akarnokd"},{"number":"4920","reopenOn":null,"comments":[{"date":"2016-12-16T17:26:09Z","author":"akarnokd","text":"Closing via #4921"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-12-16T17:26:09Z","description":"TestSubscriber:210 `onNext received a null Subscription`\r\nTestSubscriber:229 `onError received a null Subscription`\r\nTestObserver:152  `onNext received a null Subscription` \r\n\r\n","id":"195552109","title":"2.x: TestSubscriber\/TestObserver wrong error message","opened_on":"2016-12-14T14:56:00Z","closed_by":"akarnokd"},{"number":"4916","reopenOn":null,"comments":[{"date":"2016-12-11T11:06:29Z","author":"akarnokd","text":"Right. Could you post a PR?"},{"date":"2016-12-11T18:37:10Z","author":"davidmoten","text":"Yep\n\nOn Sun, 11 Dec 2016, 22:06 David Karnok <notifications@github.com> wrote:\n\n> Right. Could you post a PR?\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/ReactiveX\/RxJava\/issues\/4916#issuecomment-266275805>,\n> or mute the thread\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AATa64-_P_YzHv-0oW4Bh9bi9IeTVCn3ks5rG9k3gaJpZM4LJ4_b>\n> .\n>\n"},{"date":"2016-12-12T06:27:33Z","author":"davidmoten","text":"Looks like your recent work on `retry` and `repeat` fixed those signatures so no further changes needed."}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-12-12T06:27:33Z","description":"The `retryWhen` signature doesn't look right:\r\n\r\n```java\r\npublic final Single<T> retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<Object>> handler); \r\n```\r\nThe function should be able to return any `Flowable` for instance but at the moment has to be cast to `Flowable<Object>`. I think the signature should be:\r\n\r\n```java\r\npublic final Single<T> retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler);\r\n```","id":"194824382","title":"2.x: retryWhen signature","opened_on":"2016-12-11T10:27:04Z","closed_by":"davidmoten"},{"number":"4911","reopenOn":null,"comments":[{"date":"2016-12-09T09:20:10Z","author":"akarnokd","text":"I don't know why the travis-ci\/push still shows up."},{"date":"2016-12-09T09:35:00Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4911?src=pr) is 95.64% (diff: 98.43%)\n> Merging [#4911](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4911?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.03%**\n\n```diff\n@@                2.x      #4911   diff @@\n==========================================\n  Files           586        586          \n  Lines         37410      37446    +36   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5628       5625     -3   \n==========================================\n+ Hits          35791      35814    +23   \n- Misses          671        695    +24   \n+ Partials        948        937    -11   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [5b6d1f8...c7b4ccb](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5b6d1f8c8e9e4adc3fe31388811aa4876a5afba2...c7b4ccb947a9ccf5380a789d312a156b6b2ac8b7?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-12-09T17:24:31Z","description":"This PR fixes the `Observable.repeatWhen` not completing properly if the handler completes. In addition, the `ObservableRedo` has been split to `ObservableRetryWhen` and `ObservableRepeatWhen` just like their `Flowable` counterpart and are now they use a less convoluted algorithm.\r\n\r\nRelated: #4909","id":"194547678","title":"2.x: fix & update Observable.repeatWhen and retryWhen (again)","opened_on":"2016-12-09T09:18:52Z","closed_by":"akarnokd"},{"number":"4910","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-12-09T09:17:53Z","description":"This PR fixes the `Observable.repeatWhen` not completing properly if the handler completes. In addition, the `ObservableRedo` has been split to `ObservableRetryWhen` and `ObservableRepeatWhen` just like their `Flowable` counterpart and are now they use a less convoluted algorithm.\r\n\r\nRelated: #4909","id":"194546759","title":"2.x: fix & update Observable.repeatWhen and redoWhen","opened_on":"2016-12-09T09:13:29Z","closed_by":"akarnokd"},{"number":"4909","reopenOn":null,"comments":[{"date":"2016-12-09T08:07:41Z","author":"akarnokd","text":"Thanks. This is a bug with `Observable.repeat`. I'll post a fix shortly."},{"date":"2016-12-09T09:24:15Z","author":"akarnokd","text":"See #4911."},{"date":"2016-12-09T17:25:13Z","author":"akarnokd","text":"Closing via #4911"}],"opened_by":"otal1105","reopen":false,"closed_on":"2016-12-09T17:25:13Z","description":"I tried below\r\n```java\r\nObservable.range(1, 3).repeatWhen(handler -> handler.take(2))\r\n    .subscribe(\r\n        System.out::println, \r\n        e -> e.printStackTrace(),\r\n        () -> System.out.println(\"completed\"));\r\n```\r\n\r\nIt dodin't call onComplete. I got this.\r\n```\r\n1\r\n2\r\n3\r\n1\r\n2\r\n3\r\n1\r\n2\r\n3\r\n```\r\n\r\nHowever, I tried Flowable, it called onComplete.\r\n\r\n```java\r\nFlowable.range(1, 3).repeatWhen(handler -> handler.take(2))\r\n    .subscribe(\r\n        System.out::println, \r\n        e -> e.printStackTrace(),\r\n        () -> System.out.println(\"completed\"));\r\n```\r\n\r\nThe result was below.\r\n```\r\n1\r\n2\r\n3\r\n1\r\n2\r\n3\r\ncompleted\r\n```\r\n\r\nI tried on 2.0.2.","id":"194488573","title":"2.x: Observable.repeatWhen doesn't call onComplete","opened_on":"2016-12-09T01:11:36Z","closed_by":"akarnokd"},{"number":"4904","reopenOn":null,"comments":[],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-12-04T09:07:53Z","description":"This PR\r\n* ensures that scan function throwing cannot result in two terminal events (error or complete) and that additional error event is reported to `RxJavaPlugins` error handler.\r\n* ensures that scan function if throws is not called again","id":"193335866","title":"2.x: Observable.scan, no seed - fix post-terminal behaviour","opened_on":"2016-12-04T06:48:01Z","closed_by":"akarnokd"},{"number":"4903","reopenOn":null,"comments":[{"date":"2016-12-03T21:55:37Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4903?src=pr) is 95.68% (diff: 100%)\n> Merging [#4903](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4903?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.02%**\n\n```diff\n@@                2.x      #4903   diff @@\n==========================================\n  Files           586        586          \n  Lines         37399      37401     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5624       5625     +1   \n==========================================\n+ Hits          35774      35786    +12   \n+ Misses          688        674    -14   \n- Partials        937        941     +4   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [a39fa89...10ef08e](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a39fa891a10eda4eaefff8faac0d0899110525bc...10ef08e3292df7285b97c694ae1b092b6ee5004a?src=pr)"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-12-03T22:03:35Z","description":"This PR\r\n* prevents further calls to the consumer if an error has been thrown","id":"193315366","title":"2.x: doAfterNext - prevent post-error calls to consumer","opened_on":"2016-12-03T21:43:33Z","closed_by":"akarnokd"},{"number":"4901","reopenOn":null,"comments":[{"date":"2016-12-03T21:29:14Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4901?src=pr) is 95.68% (diff: 100%)\n> Merging [#4901](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4901?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.01%**\n\n```diff\n@@                2.x      #4901   diff @@\n==========================================\n  Files           586        586          \n  Lines         37389      37399    +10   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5621       5624     +3   \n==========================================\n+ Hits          35769      35785    +16   \n+ Misses          678        677     -1   \n+ Partials        942        937     -5   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [75e9bfa...f3c4c27](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/75e9bfa3bd1e0c084d20ed671d33d05d5ff0f8ab...f3c4c27acb96b84c29c60b184bccb8a927d281bc?src=pr)"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-12-03T21:41:40Z","description":"For scan without seed this PR\r\n* prevents multiple terminal events being emitted when the scan function throws\r\n* prevents processing of a later `onNext` if the previous `onNext` processing resulted in an error emission\r\n* ensures post terminal errors are reported to `RxJavaPlugins` error handler\r\n\r\nFor scan with seed (forgot this one in the last PR)\r\n* ensures post terminal errors are reported to `RxJavaPlugins` error handler","id":"193314086","title":"2.x: FlowableScan - prevent multiple terminal emissions","opened_on":"2016-12-03T21:17:21Z","closed_by":"akarnokd"},{"number":"4899","reopenOn":null,"comments":[{"date":"2016-12-03T11:35:49Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4899?src=pr) is 95.60% (diff: 100%)\n> Merging [#4899](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4899?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.19%**\n\n```diff\n@@                2.x      #4899   diff @@\n==========================================\n  Files           586        586          \n  Lines         37381      37389     +8   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5618       5621     +3   \n==========================================\n- Hits          35812      35746    -66   \n- Misses          653        691    +38   \n- Partials        916        952    +36   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [846afd3...e55459b](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/846afd353fd519bb8d2ee5b49efa050d8a0366b4...e55459b0b23fe0f75ad1ce4b55db9c2469496215?src=pr)"},{"date":"2016-12-03T11:52:58Z","author":"davidmoten","text":"updated PR with `onNext` protection and test (had forgotten to commit)"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-12-03T16:28:31Z","description":"This PR\r\n* prevents multiple terminal events being emitted when the scan function throws\r\n* prevents processing of a later `onNext` if the previous `onNext` processing resulted in an error emission\r\n* increases coverage to 100% of `FlowableScanSeed`\r\n\r\n","id":"193281473","title":"2.x: FlowableScanSeed - prevent multiple terminal events","opened_on":"2016-12-03T11:24:48Z","closed_by":"akarnokd"},{"number":"4889","reopenOn":null,"comments":[{"date":"2016-11-28T11:07:50Z","author":"akarnokd","text":"Thanks, this is a bug with `first` in both `Flowable` and `Observable`. I'll post a fix promptly."},{"date":"2016-11-28T12:06:49Z","author":"akarnokd","text":"Closing via https:\/\/github.com\/ReactiveX\/RxJava\/commit\/8429dc7671e2b26b6048ab47fa59e286dd77bf0c ."}],"opened_by":"dittos","reopen":false,"closed_on":"2016-11-28T12:06:49Z","description":"Following code prints `completed`, instead of expected `error`.\r\n\r\n```java\r\nObservable.empty().firstOrError().toObservable()\r\n                .subscribe(\r\n                        v -> {},\r\n                        e -> System.out.println(\"error\"),\r\n                        () -> System.out.println(\"completed\")\r\n                );\r\n```\r\n\r\nBut this code works fine (prints `error`):\r\n\r\n```java\r\nSingle.error(new Exception()).toObservable()\r\n                .subscribe(\r\n                        v -> {},\r\n                        e -> System.out.println(\"error\"),\r\n                        () -> System.out.println(\"completed\")\r\n                );\r\n```","id":"191963253","title":"2.x: Converting `firstOrError` to Observable swallows error","opened_on":"2016-11-28T10:00:50Z","closed_by":"akarnokd"},{"number":"4884","reopenOn":null,"comments":[{"date":"2016-11-25T16:00:04Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4884?src=pr) is 84.21% (diff: 93.10%)\n> Merging [#4884](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4884?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will decrease coverage by **0.04%**\n\n```diff\n@@                1.x      #4884   diff @@\n==========================================\n  Files           287        288     +1   \n  Lines         17803      17808     +5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2696       2698     +2   \n==========================================\n- Hits          15000      14997     -3   \n- Misses         1952       1960     +8   \n  Partials        851        851          \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [8fff67d...0c98869](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/8fff67d91f4d4740c0b1fa55ba238249242f2bb2...0c988692ece3830d2ff8ee152604b2612be601f8?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-11-28T08:07:53Z","description":"The default periodic scheduling code accessed the current worker time as milliseconds which prevents running microsecond and nanosecond scale unit tests with TestScheduler as its internal nanosecond resolution time is always converted, losing precision.\r\n\r\nThis PR introduces the internal `SchedulePeriodicHelper` class, moves the default scheduling code into a static method and defines a `NowNanoSupplier` interface that is now implemented by TestSchedulerWorker to return the current nano time. The default `Worker.schedulePeriodically` delegates to this static method and given a `null` `noNanoSupplier` the `Worker.now()` is converted to nanoseconds as usual.\r\n\r\nRelated: #4883","id":"191728860","title":"1.x: enable TestScheduler with nanosecond periodic scheduling","opened_on":"2016-11-25T15:52:08Z","closed_by":"akarnokd"},{"number":"4883","reopenOn":null,"comments":[{"date":"2016-11-25T01:41:46Z","author":"piotrturski","text":"with `MICROSECONDS` also doesn't work"},{"date":"2016-11-25T06:51:47Z","author":"akarnokd","text":"Did you try with 2.x?"},{"date":"2016-11-26T14:04:46Z","author":"piotrturski","text":"nope, i stick to 1.x, on 2.x it doesn't even compile (after fixing imports) so i haven't tried"},{"date":"2016-12-05T11:23:47Z","author":"akarnokd","text":"Closing via #4884."}],"opened_by":"piotrturski","reopen":false,"closed_on":"2016-12-05T11:23:47Z","description":"when millisecond resolution is used, everything works correctly. but the same test fails when all units are changed to nanosecond. the following test fails but should pass\r\n\r\n``` \r\nimport org.junit.Test;\r\nimport rx.Observable;\r\nimport rx.observers.TestSubscriber;\r\nimport rx.schedulers.TestScheduler;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class NanosecondTest {\r\n\r\n    @Test\r\n    public void shoud_schedule_correctly_with_nanosecond_resolution() {\r\n\r\n        TestScheduler scheduler = new TestScheduler();\r\n        TestSubscriber<Long> testSubscriber = new TestSubscriber<>();\r\n\r\n        TimeUnit unit = TimeUnit.NANOSECONDS; \/\/ change to TimeUnit.MILLISECONDS and test will pass\r\n\r\n        Observable.interval(30, unit, scheduler).subscribe(testSubscriber);\r\n        scheduler.advanceTimeTo(60, unit);\r\n\r\n        testSubscriber.assertValues(0L, 1L);\r\n    }\r\n}\r\n```\r\n\r\n`compile 'io.reactivex:rxjava:1.2.2'`","id":"191609621","title":"TestScheduler and\/or TestSubscriber doesn't work for nanoseconds","opened_on":"2016-11-25T01:29:03Z","closed_by":"akarnokd"},{"number":"4877","reopenOn":null,"comments":[{"date":"2016-11-23T13:12:36Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4877?src=pr) is 95.77% (diff: 100%)\n> Merging [#4877](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4877?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.09%**\n\n```diff\n@@                2.x      #4877   diff @@\n==========================================\n  Files           581        581          \n  Lines         37212      37212          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5601       5601          \n==========================================\n+ Hits          35602      35638    +36   \n+ Misses          669        647    -22   \n+ Partials        941        927    -14   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [e5ae0b9...98163ec](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/e5ae0b95dbd46ed1ca088c73262ff2473fd12de9...98163ec37280ff58b5bde8dda8e3a804b2f35a37?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-11-23T15:00:05Z","description":"This PR adds the missing calls to `RxJavaPlugins.onAssembly` on a few operators.","id":"191262980","title":"2.x: Apply missing RxJavaPlugins.onAssembly on ops","opened_on":"2016-11-23T12:53:04Z","closed_by":"akarnokd"},{"number":"4873","reopenOn":null,"comments":[{"date":"2016-11-22T17:21:22Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4873?src=pr) is 95.75% (diff: 100%)\n> Merging [#4873](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4873?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.03%**\n\n```diff\n@@                2.x      #4873   diff @@\n==========================================\n  Files           581        581          \n  Lines         37214      37212     -2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5601       5601          \n==========================================\n+ Hits          35624      35634    +10   \n+ Misses          656        650     -6   \n+ Partials        934        928     -6   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [37bde8c...d7e8e4f](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/37bde8c87a9bb0daf34a9037ebc3541fc7a17ce3...d7e8e4ff63a6d581b3b1fb459a8a88123e9b875a?src=pr)"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-11-22T17:30:15Z","description":"`TestObserver` replaced the upstream's `Disposable` with the disposed-sentinel when it got a terminal event (unlike `TestSubscriber`) and there seems to be a need for triggering `dispose` in some upstream even after that. This PR changes this behavior and also updates unit tests that expect `isDisposed()` true without actually calling `dispose()`.\r\n\r\nRelated #4872 ","id":"191067143","title":"2.x: TestObserver shouldn't clear the upstream disposable on terminated","opened_on":"2016-11-22T17:07:35Z","closed_by":"akarnokd"},{"number":"4872","reopenOn":null,"comments":[{"date":"2016-11-22T16:51:25Z","author":"akarnokd","text":"Apparently `TestObserver` disconnects from the upstream on `onComplete` but `TestSubscriber` doesn't so this might be some residue. I'll post a PR to fix this.\r\n\r\nGenerally though, some operators disconnect in a similar fashion so calling dispose has no effect after they complete."},{"date":"2016-11-22T17:30:51Z","author":"akarnokd","text":"Closing via #4873"}],"opened_by":"vanniktech","reopen":false,"closed_on":"2016-11-23T08:27:18Z","description":"The following test case fails:\r\n\r\n```java\r\nfinal AtomicBoolean atomicBoolean = new AtomicBoolean();\r\n\r\nassertThat(atomicBoolean.get()).isFalse();\r\n\r\nCompletable.complete()\r\n    .doOnDispose(() -> atomicBoolean.set(true))\r\n    .test()\r\n    .assertResult()\r\n    .dispose();\r\n\r\nassertThat(atomicBoolean.get()).isTrue(); \/\/ Fails\r\n```\r\n\r\nIn my opinion this is a bit misleading and probably should not be the case. Is this working as intended?","id":"191044476","title":"Completable.doOnDipose() not called when disposing with TestObserver","opened_on":"2016-11-22T15:51:27Z","closed_by":"akarnokd"},{"number":"4849","reopenOn":null,"comments":[{"date":"2016-11-14T19:25:42Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4849?src=pr) is 84.28% (diff: 91.66%)\n\n> Merging [#4849](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4849?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.14%**\n\n``` diff\n@@                1.x      #4849   diff @@\n==========================================\n  Files           285        285          \n  Lines         17763      17765     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2691       2691          \n==========================================\n+ Hits          14947      14974    +27   \n+ Misses         1956       1938    -18   \n+ Partials        860        853     -7   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [dc63e53...fb3d0e8](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/dc63e5350d08f08b4c1229df812f4a0a19f1083e...fb3d0e81bce9183272913e33dd5e0aa7b1a021ce?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-11-14T19:42:38Z","description":"This PR fixes the hang in `Completable.concat(Observable)` and `Completable.merge(Observable)` mainly due to using `subscribe` instead of `unsafeSubscribe`. The underlying problem was that `SafeSubscriber` unsubscribed the dowstream consumer which cancelled the outstanding elements of `range`.\r\n\r\nIn addition, I've upgraded the `concat(Observable)` to use an up-to-date concatenation algorithm and more compact memory footprint.","id":"189199681","title":"1.x: fix Completable.concat & merge hanging in async situations","opened_on":"2016-11-14T19:17:59Z","closed_by":"akarnokd"},{"number":"4848","reopenOn":null,"comments":[{"date":"2016-11-14T17:54:57Z","author":"akarnokd","text":"What version are you using?\n"},{"date":"2016-11-14T18:04:00Z","author":"dbakr","text":"Well, left the PC and will be back in an hour but its either 1.2.1 or 1.2.2\nnot sure i refreshed my gradle deps in the ide today.\nlet me check precisely and tell for sure later tonight\n\nOn Nov 14, 2016 19:55, \"David Karnok\" notifications@github.com wrote:\n\n> What version are you using?\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/issues\/4848#issuecomment-260409259,\n> or mute the thread\n> https:\/\/github.com\/notifications\/unsubscribe-auth\/AMkHwI4e5zwF-DBY4ueT_1J2hr3KfFp_ks5q-KCMgaJpZM4KxlWC\n> .\n"},{"date":"2016-11-14T18:11:28Z","author":"akarnokd","text":"Thought so. This setup works with 2.x and it prints all 5+5 \"Processing\". In 1.2.2 it only prints up to 4 and somehow misses 5. This looks like a bug, I'll investigate it further and post a fix soon.\n"},{"date":"2016-11-14T18:11:46Z","author":"dbakr","text":"I can say for sure now and its the latest version, 1.2.2\n\nOn Nov 14, 2016 20:03, \"Derar Bakr\" derar.bakr@gmail.com wrote:\n\n> Well, left the PC and will be back in an hour but its either 1.2.1 or\n> 1.2.2 not sure i refreshed my gradle deps in the ide today.\n> let me check precisely and tell for sure later tonight\n> \n> On Nov 14, 2016 19:55, \"David Karnok\" notifications@github.com wrote:\n> \n> > What version are you using?\n> > \n> > \u2014\n> > You are receiving this because you authored the thread.\n> > Reply to this email directly, view it on GitHub\n> > https:\/\/github.com\/ReactiveX\/RxJava\/issues\/4848#issuecomment-260409259,\n> > or mute the thread\n> > https:\/\/github.com\/notifications\/unsubscribe-auth\/AMkHwI4e5zwF-DBY4ueT_1J2hr3KfFp_ks5q-KCMgaJpZM4KxlWC\n> > .\n"},{"date":"2016-11-14T19:18:20Z","author":"akarnokd","text":"See #4849\n"},{"date":"2016-11-14T19:43:43Z","author":"akarnokd","text":"Closing via #4849\n"},{"date":"2016-11-14T19:49:22Z","author":"dbakr","text":"Wow, that was quick :)\nThanks a lot!!\n\nCould please take a look at the version of concat which takes Iterable,\nisn't it affected too?\n\nOn Nov 14, 2016 21:44, \"David Karnok\" notifications@github.com wrote:\n\n> Closed #4848 https:\/\/github.com\/ReactiveX\/RxJava\/issues\/4848.\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/issues\/4848#event-858335291, or mute\n> the thread\n> https:\/\/github.com\/notifications\/unsubscribe-auth\/AMkHwFrn5f9vbFu4Lhg1zARqAcsow74Tks5q-LoLgaJpZM4KxlWC\n> .\n"}],"opened_by":"dbakr","reopen":false,"closed_on":"2016-11-14T19:43:43Z","description":"Hi\r\n\r\nLoving playing with new Completables and Singles! But seems that we have found a bug running them on our production server,\r\nand after fighting for 30 minutes with and not being able to find the exact cause, we have written a simple test which is attached here and proves the issue.\r\n\r\nBy executing it you can see that old good Observables.concat works perfectly, but it's younger brother Completable.concat does not.\r\n\r\nWe observe that it ubsubscribes somewhere in the chain from child completables, and by executing the test several times you can see that sequence is uneven and order of processing\/ubsubscribed messages changes from time to time.\r\n\r\nThe file attached:\r\n\r\n[Test.zip](https:\/\/github.com\/ReactiveX\/RxJava\/files\/589964\/Test.zip)\r\n\r\nI believe it's not how it should work - I expect that all child completables complete before they are unsubscribed from by the upstream operator.\r\n\r\nThe sample code that does not work as I expect:\r\n\r\n`\r\n\r\n        System.out.println(\"Testing Completable.concat\");\r\n        System.out.println();\r\n        Completable.concat(\r\n                Observable.range(1, 5).map(integer -> Completable.fromAction(() -> {\r\n                    try {\r\n                        System.out.println(\"Processing \" + integer + \"...\");\r\n                        Thread.sleep(100);\r\n                        System.out.println(\"Processing \" + integer + \" finished\");\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                })\r\n                        .doOnUnsubscribe(() -> System.out.println(\"Unsubscribed from \" + integer))\r\n                        .subscribeOn(Schedulers.io()).observeOn(Schedulers.computation()))\r\n                        .doOnUnsubscribe(() -> System.out.println(\"Unsubscribed from parent observable\"))\r\n        ).subscribe(() -> {\r\n                    System.out.println(\"Finished Completable.concat\");\r\n                }, Throwable::printStackTrace\r\n        );\r\n \r\n\r\n`","id":"189173659","title":"Completable.concat(Obsevable<Completable>..) unsubscribes  from child completables not in time","opened_on":"2016-11-14T17:27:39Z","closed_by":"akarnokd"},{"number":"4841","reopenOn":null,"comments":[{"date":"2016-11-12T12:32:17Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4841?src=pr) is 84.18% (diff: 50.00%)\n\n> Merging [#4841](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4841?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.12%**\n\n``` diff\n@@                1.x      #4841   diff @@\n==========================================\n  Files           287        287          \n  Lines         17856      17868    +12   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2704       2706     +2   \n==========================================\n+ Hits          15011      15043    +32   \n+ Misses         1973       1961    -12   \n+ Partials        872        864     -8   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [2cdf1c0...c310906](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2cdf1c071cb7a69295fefa381f37504af76d2e83...c310906c55922b2a79691aaec5f257b3bdb2dd78?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-11-12T18:31:35Z","description":"When certain operators crash, they attach the current value to the exception via `OnErrorThrowable.addValueAsLastCause`, however, the value may not be serializable and the Throwable itself is, that causes a serialization exception.\r\n\r\nThis PR replaces such values with their `String.valueOf` representation or the crash message if `toString` failed on that object.\r\n\r\nThis was reported in #4562 with the suggestion of making the internal field `transient`. The problem with that is that upon deserialization, the field is null and there is no way of knowing if the original value was really null or just not serializable. Using `String.valueOf` at least gives a chance to know it was non-null and gets across some information about the original value.","id":"188909079","title":"1.x: replace non-serializable value of OnNextValue with its toString","opened_on":"2016-11-12T12:24:44Z","closed_by":"akarnokd"},{"number":"4830","reopenOn":null,"comments":[{"date":"2016-11-10T08:31:53Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4830?src=pr) is 84.13% (diff: 71.42%)\n\n> Merging [#4830](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4830?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will decrease coverage by **<.01%**\n\n``` diff\n@@                1.x      #4830   diff @@\n==========================================\n  Files           287        287          \n  Lines         17852      17856     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2704       2704          \n==========================================\n+ Hits          15021      15024     +3   \n+ Misses         1964       1963     -1   \n- Partials        867        869     +2   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [bebdec6...eb8f4fe](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/bebdec6a52955ea478a992cebbd527364cb5b6a4...eb8f4feccc00e797c21edfe3e33bc056e55a1e3f?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-11-10T14:22:25Z","description":"DoAfterTerminate was intended to call the callback after either onCompleted or onError but somehow missed that behavior in 1.x.\r\n\r\nRelated: #4822","id":"188446467","title":"1.x: Completable.doAfterTerminate to run after onError as well","opened_on":"2016-11-10T08:22:19Z","closed_by":"akarnokd"},{"number":"4826","reopenOn":null,"comments":[{"date":"2016-11-09T22:48:07Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4826?src=pr) is 84.19% (diff: 87.83%)\n\n> Merging [#4826](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4826?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.15%**\n\n``` diff\n@@                1.x      #4826   diff @@\n==========================================\n  Files           287        287          \n  Lines         17828      17835     +7   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2702       2702          \n==========================================\n+ Hits          14983      15016    +33   \n+ Misses         1968       1953    -15   \n+ Partials        877        866    -11   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [d6bc923...6186a70](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d6bc9237338f26853a99149751342f54e5ba9b18...6186a7028ad3fb2910f38b155bb7ca7508a13b33?src=pr)\n"}],"opened_by":"abersnaze","reopen":false,"closed_on":"2016-11-09T22:55:03Z","description":"In using this in production we found a bug where some actions were dropped.  I've tracked it down to the premature onCompleted and unsubscription of the completable that represents the scheduled action causes the future to get canceled before it is started.\r\n\r\nThe fix was to delay the onCompleted until the action was truly done.\r\n\r\nI did the PR as two commits because the first one is changing all the tabs to spaces! Look at the second commit for the actual functional difference.","id":"188370998","title":"Schedule when bug fix","opened_on":"2016-11-09T22:37:59Z","closed_by":"akarnokd"},{"number":"4822","reopenOn":null,"comments":[{"date":"2016-11-08T14:28:54Z","author":"akarnokd","text":"`Completable` is in `@Beta` still so you can post a PR that updates some names and adds the call to that callback for `onError`. There is no need to introduce a new operator as `doAfterTerminate` is supposed to work like that.\n"},{"date":"2016-11-11T14:43:50Z","author":"StanislavChumarin","text":"Looks like this issue was resolved.\n"}],"opened_by":"StanislavChumarin","reopen":false,"closed_on":"2016-11-11T14:43:50Z","description":"Completable.doAfterTerminate is called only \"after this Completable completes normally\" but that is differ from Observable\/Single implementation of same operation.\r\n\r\nI think that this method must be reimplemented to be similar to those in Observable\/Single and current implementation to be renamed to `doAfterCompleted`. \r\n\r\nI know that there is `doOnTerminate` (same operation was deprecated in Observable). I just what to have predictable API with need to dig into documentation word by word.","id":"187999739","title":"1.2.2 Please implement Completable.doAfterTerminate to be called after onError also","opened_on":"2016-11-08T14:04:36Z","closed_by":"StanislavChumarin"},{"number":"4819","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-11-07T18:58:50Z","description":"`Observable.repeatWhen` was not properly signalling an upstream `onError` case. The `Flowable.repeatWhen` works as expected.","id":"187789656","title":"2.x: Observable.repeatWhen fix for onError","opened_on":"2016-11-07T18:26:21Z","closed_by":"akarnokd"},{"number":"4818","reopenOn":null,"comments":[{"date":"2016-11-07T17:25:46Z","author":"lucas34","text":"Use TakeUntil() or takeWhile() http:\/\/reactivex.io\/documentation\/operators\/takeuntil.html\n"},{"date":"2016-11-07T17:38:15Z","author":"ychescale9","text":"Thanks but TakeUntil() and takeWhile() are different operators for different use cases. I'm wondering why\/how repeatWhen behaves differently in 2.x.\n"},{"date":"2016-11-07T17:42:26Z","author":"akarnokd","text":"Thanks for reporting. This is a bug with `Observable.repeatWhen` (`Flowable.repeatWhen` works). I'll post a fix soon.\n"},{"date":"2016-11-07T18:27:11Z","author":"akarnokd","text":"See #4819.\n"},{"date":"2016-11-07T19:02:03Z","author":"akarnokd","text":"Closing via #4819\n"}],"opened_by":"ychescale9","reopen":false,"closed_on":"2016-11-07T19:02:03Z","description":"In 2.X repeatWhen can't seem to be terminated (onError) by throwing an exception from the observable:\r\n```\r\nprivate int count = 0;\r\nprivate Observable<Integer> getTestObservable() {\r\n    return Observable.fromCallable(new Callable<Integer>() {\r\n        @Override\r\n        public Integer call() throws Exception {\r\n            count++;\r\n            if (count == 5) {\r\n                throw new Exception(\"Some exception\");\r\n            }\r\n            return count;\r\n        }\r\n    });\r\n}\r\n\r\n@Test\r\npublic void testRepeatWhen() {\r\n    getTestObservable()\r\n            .repeatWhen(new Function<Observable<Object>, ObservableSource<?>>() {\r\n                @Override\r\n                public ObservableSource<?> apply(Observable<Object> objectObservable) throws Exception {\r\n                    return objectObservable.delay(1, TimeUnit.SECONDS);\r\n                }\r\n            })\r\n            .subscribe(new Observer<Integer>() {\r\n                @Override\r\n                public void onSubscribe(Disposable d) {\r\n                    System.out.println(\"onSubscribe\");\r\n                }\r\n\r\n                @Override\r\n                public void onNext(Integer value) {\r\n                    System.out.println(\"onNext: \" + value);\r\n                }\r\n\r\n                @Override\r\n                public void onError(Throwable e) {\r\n                    System.out.println(\"onError\");\r\n                }\r\n\r\n                @Override\r\n                public void onComplete() {\r\n                    System.out.println(\"onComplete\");\r\n                }\r\n            });\r\n}\r\n```\r\nOutput:\r\n```\r\nonSubscribe\r\nonNext: 1\r\nonNext: 2\r\nonNext: 3\r\nonNext: 4\r\nonNext: 6\r\nonNext: 7\r\n...\r\n```\r\nWhen the exception is thrown, neither onNext nor onError is called on the subscription, then repeatWhen continues.\r\n\r\nThis behavior is different to the equivalence in 1.x.\r\n\r\nHow can repeatWhen be terminated in 2.x?\r\n\r\nThanks.","id":"187758099","title":"2.x: terminating repeatWhen","opened_on":"2016-11-07T16:27:33Z","closed_by":"akarnokd"},{"number":"4791","reopenOn":null,"comments":[{"date":"2016-10-31T21:39:42Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4791?src=pr) is 83.94% (diff: 100%)\n\n> Merging [#4791](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4791?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will decrease coverage by **0.05%**\n\n``` diff\n@@                1.x      #4791   diff @@\n==========================================\n  Files           286        286          \n  Lines         17752      17754     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2701       2702     +1   \n==========================================\n- Hits          14911      14903     -8   \n- Misses         1972       1975     +3   \n- Partials        869        876     +7   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [5747017...9888936](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/57470176b1f1d68904544fce92de3f52ea645300...9888936ecdfe0beb3f0c5528f9f21e70e2565f22?src=pr)\n"}],"opened_by":"ortex","reopen":false,"closed_on":"2016-11-01T14:32:04Z","description":"#4762","id":"186402559","title":"1.x: Add null check to Observable.switchIfEmpty","opened_on":"2016-10-31T21:29:26Z","closed_by":"akarnokd"},{"number":"4783","reopenOn":null,"comments":[{"date":"2016-10-31T12:44:50Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4783?src=pr) is 95.72% (diff: 91.66%)\n\n> Merging [#4783](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4783?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.14%**\n\n``` diff\n@@                2.x      #4783   diff @@\n==========================================\n  Files           570        570          \n  Lines         36713      36717     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5555       5554     -1   \n==========================================\n- Hits          35200      35149    -51   \n- Misses          617        646    +29   \n- Partials        896        922    +26   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [3300d19...02aa31c](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/3300d19ea0c168a210bf7816503d7805ac93dc49...02aa31c228267f4099c78641f19b2514c1b0a85b?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-31T14:05:56Z","description":"The `Observer` that is subscribing to the `Observable` returned by the handler function was not properly linked to the disposing of the end Observer. This PR fixes it by making that `Observer` do async `Disposable` management and make sure the end `Observer` receives a disposable list with both the main and the handler `Disposable`s.\n\nThe `Flowable` versions worked properly but added unit tests to them regardless.\n\nReported in #4782.\n","id":"186152024","title":"2.x: fix Observable.repeatWhen & retryWhen not disposing the inner","opened_on":"2016-10-30T18:06:47Z","closed_by":"akarnokd"},{"number":"4782","reopenOn":null,"comments":[{"date":"2016-10-30T16:05:37Z","author":"nsk-mironov","text":"The same issue with `retryWhen`:\n\n``` java\npublic class RetryWhenTest {\n  @Test\n  public void shouldDisposeInnerObservable() {\n    final PublishSubject<String> subject = PublishSubject.create();\n    final Disposable disposable = Observable.error(new RuntimeException(\"Leak\"))\n        .retryWhen(errors -> errors.switchMap(ignore -> subject))\n        .subscribe();\n\n    assertTrue(subject.hasObservers());\n    disposable.dispose();\n    assertFalse(subject.hasObservers());\n  }\n}\n```\n"},{"date":"2016-10-30T17:42:12Z","author":"akarnokd","text":"Thanks. I'll investigate the reasons and post a fix. The `Flowable` variants seem to work.\n"},{"date":"2016-10-30T18:38:54Z","author":"akarnokd","text":"See #4783\n"},{"date":"2016-11-03T08:49:52Z","author":"akarnokd","text":"Closing via #4783\n"}],"opened_by":"nsk-mironov","reopen":false,"closed_on":"2016-11-03T08:49:52Z","description":"The following test case fails with `RxJava-2.0.0`, but works fine with `1.2.1`:\n\n``` java\npublic class RepeatWhenTest {\n  @Test\n  public void shouldDisposeInnerObservable() {\n    final PublishSubject<String> subject = PublishSubject.create();\n    final Disposable disposable = Observable.just(\"Leak\")\n        .repeatWhen(completions -> completions.switchMap(ignore -> subject))\n        .subscribe();\n\n    assertTrue(subject.hasObservers());\n    disposable.dispose();\n    assertFalse(subject.hasObservers());\n  }\n}\n```\n","id":"186144550","title":"[2.0.0] repeatWhen\/retryWhen memory leak","opened_on":"2016-10-30T15:59:13Z","closed_by":"akarnokd"},{"number":"4770","reopenOn":null,"comments":[{"date":"2016-10-26T07:43:58Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4770?src=pr) is 95.70% (diff: 100%)\n\n> Merging [#4770](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4770?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.09%**\n\n``` diff\n@@                2.x      #4770   diff @@\n==========================================\n  Files           570        570          \n  Lines         36711      36713     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5555       5555          \n==========================================\n+ Hits          35101      35136    +35   \n+ Misses          667        646    -21   \n+ Partials        943        931    -12   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [07d24c2...1f12ee6](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/07d24c2ecc61eea94b6d646e02ddd9799b42de7c...1f12ee63aa30d771009ee8651bee91937bf6edf1?src=pr)\n"},{"date":"2016-10-26T16:22:17Z","author":"akarnokd","text":"options:\n- ignore the issue\n- teach users to have `create(..., MISSING).subscribeOn().onBackpressureDrop()` instead\n- add explicit parameter to subscribeOn() and teach users\n- add more extensive lookup\n\nThis impacts only those who have busy loop inside `create` instead of using `generate`. Users converting other async API or callback style sources are not affected as those don't block the create().\n"},{"date":"2016-10-26T16:45:47Z","author":"tilal6991","text":"This seems like a patchwork fix for what is a deeper problem which really should be fixed in a more user-visible manner. It's is very possible that users are using other operators between create and subscribeOn and hardcoding to create seems to be simply deferring the problem to those other cases.\n"},{"date":"2016-10-26T16:48:53Z","author":"akarnokd","text":"Blocking and backpressure don't play nice together. Another fix could forcefully include a `Scheduler` parameter into `create` and as such can't be overridden by applying another `subscribeOn`.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-26T17:16:04Z","description":"When running a blocking emission in `Flowable.create` with `subscribeOn`, the default behavior of `subscribeOn` is to schedule downstream requests onto the same thread. Unfortunately, the blocking emission prevents the backing threadpool the `create` from accumulating that request amount leading to either buffer bloat or dropped emissions till the very end of the sequence.\n\nThis PR introduces a `nonScheduledRequests` parameter to `subscribeOn` that simply calls the upstream's `request()` from the caller's thread without scheduling it. The parameter is not exposed to the surface API but the `subscribeOn` operator does an `instanceof` check to see if the upstream type is `FlowableCreate`.\n\nNote that this requires a direct upstream `create` and any intermediate operator re-enables the default behavior. It is possible to traverse the upstream graph to locate a `FlowableCreate` but it has relatively high cost and thus penalizing all `subscribeOn` usages.\n\nRelated: #4735\n","id":"185316259","title":"2.x: allow subscribeOn to work with blocking create","opened_on":"2016-10-26T07:27:16Z","closed_by":"akarnokd"},{"number":"4766","reopenOn":null,"comments":[{"date":"2016-10-25T12:55:36Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4766?src=pr) is 95.66% (diff: 92.12%)\n\n> Merging [#4766](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4766?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.26%**\n\n``` diff\n@@                2.x      #4766   diff @@\n==========================================\n  Files           570        570          \n  Lines         36784      36711    -73   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5570       5555    -15   \n==========================================\n+ Hits          35094      35120    +26   \n+ Misses          735        662    -73   \n+ Partials        955        929    -26   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [318bf43...084725c](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/318bf43269c8534d1790b7968251f8f5eaed02d4...084725c02c910afb424839dd0532163451669a8e?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-25T14:44:40Z","description":"This is the last part of my dedicated coverage improvement run.\n- Update code paths and remove unnecessary and unused parts.\n- Fix `skipUntil` lifecycle and concurrency properties.\n- Fix `concatMapEager` error management.\n- `Flowable.scan(T, BiFunction)` now emits the initial value only when the upstream signals an event. This has the effect that even if there is a downstream request, the initial value won't get emitted. This change reduces the overhead of the operator greatly.\n","id":"185105090","title":"2.x: cleanup, fixes and coverage 10\/25","opened_on":"2016-10-25T12:37:41Z","closed_by":"akarnokd"},{"number":"4763","reopenOn":null,"comments":[{"date":"2016-10-24T22:54:29Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4763?src=pr) is 95.27% (diff: 90.47%)\n\n> Merging [#4763](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4763?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.38%**\n\n``` diff\n@@                2.x      #4763   diff @@\n==========================================\n  Files           570        570          \n  Lines         36840      36784    -56   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5588       5570    -18   \n==========================================\n+ Hits          34956      35045    +89   \n+ Misses          870        767   -103   \n+ Partials       1014        972    -42   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [3634c92...cb2ce8e](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/3634c92cb6a8199b8022ffb3bd8e2a65da9c18f0...cb2ce8eba5949aa317c5470421431007b5d2799d?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-25T07:51:05Z","description":"- better coverage of `Flowable` operators\n- cleanup of operator internals\n- better coverage of standard Schedulers.\n- rewrite of `takeUntil` to avoid `onSubscribe()` races.\n","id":"184966207","title":"2.x: cleanup & coverage 10\/24-2","opened_on":"2016-10-24T21:59:30Z","closed_by":"akarnokd"},{"number":"4762","reopenOn":null,"comments":[{"date":"2016-10-24T18:36:22Z","author":"akarnokd","text":"Would you like to submit a PR?\n"},{"date":"2016-10-24T18:39:06Z","author":"dbakr","text":"I'm not ready to provide a PR - probably just a simple null verification on the switchIfEmpty creation.\nI think its worth a deeper investigation by someone from the core team.\n"},{"date":"2016-10-24T18:48:36Z","author":"akarnokd","text":"I don't have the capacity to investigate this right now. Indeed there is a null check missing in `Observable.switchIfEmpty()`.\n"},{"date":"2016-10-28T23:47:51Z","author":"moontails","text":"@akarnokd so what would this entail? Does it just need a null check and throw an NPE?\n"},{"date":"2016-10-29T07:30:24Z","author":"akarnokd","text":"The fix is trivial, yes. Figuring out why the NPE never popped out from the internals is another story.\n"},{"date":"2016-11-07T08:18:22Z","author":"akarnokd","text":"Closing via #4791\n"}],"opened_by":"dbakr","reopen":false,"closed_on":"2016-11-07T08:18:22Z","description":"The following code consists obvious error: null is passed to switchIfEmpty (actually it's a common mistake to use switchIfEmpty instead of defaultIfEmpty).\nBut the problem is that the consequent NPE is not emitted to subscribers. Actually, none of the subscirber's methods is called: neither onNext, nor onError or onCompleted. This code does not produce any output to the system.out!\n\nThat of course could be fixed by simple null verification on the switchIfEmpty operator creation.\nBut probably its worth looking more deep into the sequence of producers in this chain, and something could be improved?\nThis situation caused by the described behavior, when no Observable's events are raised on the event loop,  was quite difficult to find and costed us few nervous cells :)\n\nI guess its worth investigating and fixing.\n\n```\n\/\/ problematic code\n\nObservable.just(null)\n        .filter(Objects::nonNull)\n        .flatMap(o -> Observable.just(1))\n        .switchIfEmpty(null)\n        .subscribe(o -> System.out.println(o)\n                , Throwable::printStackTrace\n                , () -> System.out.println(\"completed\"));\n\n```\n","id":"184919218","title":"No subscriber methods are called at all, when having npe because of illegal switchIfEmpty usage","opened_on":"2016-10-24T18:32:01Z","closed_by":"akarnokd"},{"number":"4761","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-24T15:17:16Z","description":"- Remove unused or unnecessary code paths.\n- Fix cancellation bugs in `Flowable` operators.\n- Unify `MapNotification`, `Materialize`, `OnErrorReturn` last element backpressure under the same helper class.\n- Move `FlowableBlockingIterator` into `FlowableBlockingIterable`.\n- Reuse parts of `FlowableSequenceEqual` in `FlowableSequenceEqualSingle`.\n","id":"184852733","title":"2.x: cleanup, fixes, coverage 10\/24-1","opened_on":"2016-10-24T14:14:20Z","closed_by":"akarnokd"},{"number":"4751","reopenOn":null,"comments":[{"date":"2016-10-21T23:00:03Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4751?src=pr) is 93.74% (diff: 73.91%)\n\n> Merging [#4751](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4751?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.04%**\n\n``` diff\n@@                2.x      #4751   diff @@\n==========================================\n  Files           570        570          \n  Lines         37067      37073     +6   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5648       5651     +3   \n==========================================\n- Hits          34764      34754    -10   \n- Misses         1171       1183    +12   \n- Partials       1132       1136     +4   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [777b4c1...36a7c6f](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/777b4c1a9fec37ed15e56b4da5348f29cd5fcdf9...36a7c6f6b37e2f7c13958278cc659404f3d46c18?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-22T07:40:18Z","description":"`Flowable.concatMapEager`'s drain loop when encountering a finished inner jumped back to the beginning of the loop but disregarded the potentially changed request amount and just stopped emitting. The fix is to use the typical request management approach of reading the current request at the beginning of the loop and then committing the emission amount before trying to leave the loop.\n\nRelated: #4620\n\nIn addition `TestHelper.assertError` has been changed to attach the whole unexpected exception to the `AssertionError`. \n","id":"184584956","title":"2.x: fix Flowable.concatMapEager hang due to bad request management","opened_on":"2016-10-21T22:37:56Z","closed_by":"akarnokd"},{"number":"4747","reopenOn":null,"comments":[{"date":"2016-10-21T17:58:16Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4747?src=pr) is 93.79% (diff: 95.58%)\n\n> No coverage report found for **2.x** at 98d0b7f.\n> \n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [98d0b7f...0a7db2a](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/98d0b7f2ec63544890d029282dc2ff3f611b987a...0a7db2abb0b67a2d37068e59ac4552b4cdc981da?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-21T18:13:49Z","description":"Fix `distinctUntilChanged` to store the selected key instead of the input value.\n\nReported in #4743 \n","id":"184531429","title":"2.x: distinctUntilChanged to store the selected key instead of the value","opened_on":"2016-10-21T17:05:14Z","closed_by":"akarnokd"},{"number":"4743","reopenOn":null,"comments":[{"date":"2016-10-21T19:18:01Z","author":"akarnokd","text":"Fixed via #4747\n"}],"opened_by":"nsk-mironov","reopen":false,"closed_on":"2016-10-21T19:18:01Z","description":"``` java\npublic class Main {\n  static class Header {\n    String name = \"key\";\n    String value = \"one\";\n  }\n\n  public static void main(String[] args) {\n    final Header header = new Header();\n    final BehaviorSubject<Header> subject = BehaviorSubject.createDefault(header);\n\n    subject.distinctUntilChanged(new Function<Header, Object>() {\n      @Override\n      public Object apply(final Header header) throws Exception {\n        return header.value;\n      }\n    }).subscribe(new Consumer<Header>() {\n      @Override\n      public void accept(final Header header) throws Exception {\n        System.out.println(\"Name = \" + header.name + \", Value = \" + header.value);\n      }\n    });\n\n    header.value = \"two\";\n    subject.onNext(header);\n  }\n}\n```\n\nOutput:\n\n```\nName = key, Value = one\n```\n\nExpected output:\n\n```\nName = key, Value = one\nName = key, Value = two\n```\n\nThe same code used to work as expected with 2.0.0-RC4 and all previous RxJava versions.\n","id":"184502733","title":"[2.0.0-RC5] distinctUntilChanged doesn't work nicely with mutable objects","opened_on":"2016-10-21T14:42:38Z","closed_by":"akarnokd"},{"number":"4742","reopenOn":"2016-10-21T12:31:09Z","comments":[{"date":"2016-10-21T12:25:24Z","author":"akarnokd","text":"There seems to be a problem between GitHub and Travis at the moment.\n"},{"date":"2016-10-21T13:38:02Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4742?src=pr) is 93.95% (diff: 93.15%)\n\n> Merging [#4742](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4742?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.40%**\n\n``` diff\n@@                2.x      #4742   diff @@\n==========================================\n  Files           569        570     +1   \n  Lines         37148      37064    -84   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5666       5648    -18   \n==========================================\n+ Hits          34750      34822    +72   \n+ Misses         1271       1136   -135   \n+ Partials       1127       1106    -21   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [14a954c...e3ca3ee](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/14a954cd969b0c86e3e3c28be9e7f7257e15e62f...e3ca3ee902876fa6288c5a3f0e09a5aa1f96ce9c?src=pr)\n"}],"opened_by":"akarnokd","reopen":true,"closed_on":"2016-10-21T15:47:07Z","description":"- fix `Flowable.materialize()` terminal signal emission in face of backpressure\n- fix `Flowable.onErrorReturn()` terminal signal emission in face of backpressure\n- cleanup `Flowable.publish()` and enable operator fusion on its input\n- fix `Flowable.flatMapSingle()` and `Flowable.flatMapMaybe()` termination detection\n- compact `Flowable.blockingSubscribe()` and `Observable.blockingSubscribe()`\n- compact `Flowable.subscribeOn()`\n","id":"184469893","title":"2.x: coverage, fixes, cleanup 10\/21-1","opened_on":"2016-10-21T12:06:49Z","closed_by":"akarnokd"},{"number":"4740","reopenOn":null,"comments":[{"date":"2016-10-21T01:49:51Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4740?src=pr) is 83.95% (diff: 100%)\n\n> Merging [#4740](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4740?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.06%**\n\n``` diff\n@@                1.x      #4740   diff @@\n==========================================\n  Files           286        286          \n  Lines         17753      17756     +3   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2701       2701          \n==========================================\n+ Hits          14893      14907    +14   \n+ Misses         1985       1975    -10   \n+ Partials        875        874     -1   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [1f65cbb...f4d2f25](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/1f65cbbceea6d152b8a0f5914eea82eba4686c48...f4d2f25ce2f217d0926ec1626eb40939cb4406b9?src=pr)\n"}],"opened_by":"pyricau","reopen":false,"closed_on":"2016-10-22T17:58:53Z","description":"#4737\n","id":"184380454","title":"1.x: Error when tracking exception with unknown cause","opened_on":"2016-10-21T01:38:39Z","closed_by":"akarnokd"},{"number":"4738","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-20T20:39:15Z","description":"I cut this short so there is time for the **2.0.0-RC release preparations**.\n- Introduce `SimplePlainQueue` where `poll` doesn't throw, avoiding the need for try-catches where the queue is one of the standard lock-free queues.\n- Fix `FlatMap` error, cancellation and resource management.\n- Coverage of some `Flowable` operators\n- Removal of impossible and unused code paths.\n","id":"184323033","title":"2.x: coverage, fixes, cleanup 10\/20-2","opened_on":"2016-10-20T19:46:45Z","closed_by":"akarnokd"},{"number":"4737","reopenOn":null,"comments":[{"date":"2016-10-20T17:12:37Z","author":"pyricau","text":"Or... well, this is going to be funky, but I guess we could also recreate an entirely new exception that has exactly the same stacktrace but an unset cause.\n"},{"date":"2016-10-20T17:31:03Z","author":"akarnokd","text":"I don't see any other way than catcing ISE and signalling to the hooks. Care to submit a PR?\n"},{"date":"2016-10-20T18:09:07Z","author":"pyricau","text":"on it.\n"},{"date":"2016-10-25T13:21:22Z","author":"akarnokd","text":"Closing via #4740.\n"}],"opened_by":"pyricau","reopen":false,"closed_on":"2016-10-25T13:21:22Z","description":"[AssemblyStackTraceException#attachTo](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/exceptions\/AssemblyStackTraceException.java) method does this:\n\n```\n    \/**\n     * Finds an empty cause slot and assigns itself to it.\n     * @param exception the exception to start from\n     *\/\n    public void attachTo(Throwable exception) {\n        Set<Throwable> memory = new HashSet<Throwable>();\n\n        for (;;) {\n            if (exception.getCause() == null) {\n                exception.initCause(this);\n                return;\n            }\n\n            exception = exception.getCause();\n            if (!memory.add(exception)) {\n                \/\/ in case we run into a cycle, give up and report this to the hooks\n                RxJavaHooks.onError(this);\n                return;\n            }\n        }\n    }\n```\n\nThis assumes that there are two types of exceptions: either it doesn't have a cause and we can set one, or there is a cycle in the chain and it bails.\n\nHowever, if you look at the JDK Throwable implementation, you'll see this:\n\n```\npublic class Throwable  {\n\n    \/**\n     * The throwable that caused this throwable to get thrown, or null if this\n     * throwable was not caused by another throwable, or if the causative\n     * throwable is unknown.  If this field is equal to this throwable itself,\n     * it indicates that the cause of this throwable has not yet been\n     * initialized.\n     *\/\n    private Throwable cause = this;\n\n   public Throwable(String message, Throwable cause) {\n        fillInStackTrace();\n        detailMessage = message;\n        this.cause = cause;\n    }\n\n    \/**\n     * Initializes the <i>cause<\/i> of this throwable to the specified value.\n     * (The cause is the throwable that caused this throwable to get thrown.)\n     *\n     * <p>This method can be called at most once.  It is generally called from\n     * within the constructor, or immediately after creating the\n     * throwable.  If this throwable was created\n     * with {@link #Throwable(Throwable)} or\n     * {@link #Throwable(String,Throwable)}, this method cannot be called\n     * even once.\n     *\n     * @param  cause the cause (which is saved for later retrieval by the\n     *         {@link #getCause()} method).  (A {@code null} value is\n     *         permitted, and indicates that the cause is nonexistent or\n     *         unknown.)\n     * @return  a reference to this {@code Throwable} instance.\n     * @throws IllegalArgumentException if {@code cause} is this\n     *         throwable.  (A throwable cannot be its own cause.)\n     * @throws IllegalStateException if this throwable was\n     *         created with {@link #Throwable(Throwable)} or\n     *         {@link #Throwable(String,Throwable)}, or this method has already\n     *         been called on this throwable.\n     *\/\n    public synchronized Throwable initCause(Throwable cause) {\n        if (this.cause != this)\n            throw new IllegalStateException(\"Can't overwrite cause with \" +\n                                            Objects.toString(cause, \"a null\"), this);\n        if (cause == this)\n            throw new IllegalArgumentException(\"Self-causation not permitted\", this);\n        this.cause = cause;\n        return this;\n    }\n```\n\nSo, if you do `new Throwable(\"\", null)`, then the cause is set, and it is null. `Throwable.getCause()` will return null, but `Throwable.initCause()` will throw. And we just saw that `attachTo` does this:\n\n```\n            if (exception.getCause() == null) {\n                exception.initCause(this);\n                return;\n            }\n```\n\nThis was introduced when fixing #4212 .\n\nThis is going to be tricky to fix, because there is no easy to know \"this exception does have a cause and it is set to null\".\n\nIt's ugly, but we could catch `IllegalStateException` when calling `initCause()`. And even then, I'm not sure what we should do. Reporting to `RxJavaHooks.onError();` seems wrong, this isn't necessarily an incorrect exception.\n\nFYI, Retrofit 1 has this exact issue ([RetrofitError](https:\/\/github.com\/square\/retrofit\/blob\/parent-1.9.0\/retrofit\/src\/main\/java\/retrofit\/RetrofitError.java))\n","id":"184285940","title":"AssemblyStackTraceException doesn't account for unknown causes","opened_on":"2016-10-20T17:02:27Z","closed_by":"akarnokd"},{"number":"4736","reopenOn":null,"comments":[{"date":"2016-10-20T14:40:52Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4736?src=pr) is 92.98% (diff: 91.16%)\n\n> Merging [#4736](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4736?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **1.13%**\n\n``` diff\n@@                2.x      #4736   diff @@\n==========================================\n  Files           569        569          \n  Lines         37209      37197    -12   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5672       5674     +2   \n==========================================\n+ Hits          34177      34587   +410   \n+ Misses         1757       1436   -321   \n+ Partials       1275       1174   -101   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [869c855...b8b5e0b](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/869c8554ac1ed46fb005074c20e5432e74cc255e...b8b5e0b670569a08e9cc25807cf5db983395007d?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-20T15:31:32Z","description":"- Finished covering `Observable` operators to a reasonable level (the remaining are either impossible or only reachable by probabilistic race)\n- Synced operator coverage between `Observable` and `Flowable`\n- Started covering `Flowable` operators\n- Cleaning up a few `Flowable` operators (cache, concatMap)\n- fix `onBackpressureBuffer(long, Action, BufferOverflowStrategy)` return type\n- fix `concatMapDelayError` wrong barrier mode selected\n","id":"184242477","title":"2.x: cleanup, fixes, coverage 10\/20-1","opened_on":"2016-10-20T14:17:39Z","closed_by":"akarnokd"},{"number":"4735","reopenOn":null,"comments":[{"date":"2016-11-12T18:38:50Z","author":"akarnokd","text":"This was resolved in 2.x by making sure a `subscribeOn` after `create` doesn't reschedule downstream requests.\n"},{"date":"2017-01-02T14:07:16Z","author":"bobvanderlinden","text":"I think I'm running into this problem as well. `fromEmitter` suddenly stops emitting `onNext` items whereas the emitter itself is still being called.\r\n\r\nI was using a single-thread-scheduler for the emitter, so I thought (from your explanation) that moving to a threadpool would resolve the problem. It apparently does not for my case. I'm probably misunderstanding what is going on behind the scenes.\r\n\r\nDo you have any suggestions on how to workaround this issue (without moving to 2.x)."},{"date":"2017-01-02T14:12:19Z","author":"akarnokd","text":"@bobvanderlinden Yes, use the NONE policy and apply `onBackpressureXXX` *after* `subscribeOn`."},{"date":"2017-01-02T14:19:29Z","author":"bobvanderlinden","text":"@akarnokd That works like a charm! Thanks a lot!"},{"date":"2017-02-11T18:08:07Z","author":"akarnokd","text":"Closing via #5091 for 1.x  and #4770 for 2.x."}],"opened_by":"akarnokd","reopen":false,"closed_on":"2017-02-11T18:08:07Z","description":"This affects both 1.x and 2.x.\n\nThere is a question on [StackOverflow](http:\/\/stackoverflow.com\/questions\/40145203\/rxjava-observable-fromemitter-odd-backpressure-behaviour) where the example program hangs after it delivered the default bufferSize elements until the `fromEmitter` source completes.\n\nThe problem is that `subscribeOn` schedules the downstream's replenishing `request` on the same thread that is busy\/sleeping and has no opportunity to update its internal requested amount. We had similar problems with `onBackpressureBlock` which had to be dropped.\n\nWe could introduce a `subscribeOn` mode in which it doesn't reschedule the `request` from downstream but it will confuse some and make wonder others.\n","id":"184171943","title":"fromEmitter same-pool deadlock","opened_on":"2016-10-20T08:59:44Z","closed_by":"akarnokd"},{"number":"4730","reopenOn":null,"comments":[{"date":"2016-10-19T15:03:04Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4730?src=pr) is 91.51% (diff: 93.33%)\n\n> Merging [#4730](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4730?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **1.70%**\n\n``` diff\n@@                2.x      #4730   diff @@\n==========================================\n  Files           571        571          \n  Lines         37276      37229    -47   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5678       5674     -4   \n==========================================\n+ Hits          33480      34071   +591   \n+ Misses         2289       1819   -470   \n+ Partials       1507       1339   -168   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [e28dc4b...7f80d60](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/e28dc4ba7a7ccc0c396761bde60d6a735775b753...7f80d60932f4f10d04d50b5aafd6dfa96ddda032?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-19T15:47:22Z","description":"- Explain `Observable.observeOn` unboundedness\n- improve `Observable` operator coverage\n- copy test methods over to `Flowable` operators\n- apply fixes to `Flowable` operators\n- add missing calls to `RxJavaPlugins.onError()`\n- add more time to RS TCK test of `observeOn`\n","id":"183982669","title":"2.x: coverage, fixes, cleanup, copy to Flowable 10\/19-1","opened_on":"2016-10-19T14:45:14Z","closed_by":"akarnokd"},{"number":"4723","reopenOn":null,"comments":[{"date":"2016-10-18T16:02:38Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4723?src=pr) is 90.00% (diff: 96.07%)\n\n> Merging [#4723](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4723?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.82%**\n\n``` diff\n@@                2.x      #4723   diff @@\n==========================================\n  Files           570        571     +1   \n  Lines         37234      37241     +7   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5672       5671     -1   \n==========================================\n+ Hits          33205      33518   +313   \n+ Misses         2439       2236   -203   \n+ Partials       1590       1487   -103   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [19d83c1...440d60f](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/19d83c148eea5cf789761020638d36b3fee015b3...440d60f1b9477bfd3d9c0a424c3cb6c2eac94b8a?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-18T16:20:47Z","description":"- improve coverage of more `Observable` operators\n- reduce allocation of `ConnectableObservable.connect(Consumer)` and `ConnectableFlowable.connect(Consumer)`\n- enable fusion on `Observable.observeOn`\n- fix fusion of `Observable.just`\n- remove `flatMapIterable(Function, int)` overload and have `flatMapIterable(Function)` use the flatten operator.\n- fix `Observable.replay()` potential emission before `onSubscribe` call\n","id":"183719130","title":"2.x: coverage, fixes, enhancements, cleanup 10\/18-1","opened_on":"2016-10-18T15:23:19Z","closed_by":"akarnokd"},{"number":"4720","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-17T21:44:09Z","description":"The variance of the `retryWhen` operator doesn't infere properly with java 8. This PR removes the `? extends` from the function's input `Observable`.\n\nReported in: https:\/\/twitter.com\/HansWurst315\/status\/788108336285753344\n","id":"183532429","title":"2.x: remove variance from the input source of retryWhen","opened_on":"2016-10-17T21:27:33Z","closed_by":"akarnokd"},{"number":"4718","reopenOn":null,"comments":[{"date":"2016-10-17T16:31:20Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4718?src=pr) is 89.06% (diff: 100%)\n\n> Merging [#4718](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4718?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.15%**\n\n``` diff\n@@                2.x      #4718   diff @@\n==========================================\n  Files           570        570          \n  Lines         37268      37268          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5685       5685          \n==========================================\n- Hits          33251      33194    -57   \n- Misses         2438       2476    +38   \n- Partials       1579       1598    +19   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [e255de7...b2ed8d3](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/e255de7db02c715d7441d63e774d8c3f34d40c06...b2ed8d3d77956b862640e8583024a98e8e5fc6cc?src=pr)\n"}],"opened_by":"vanniktech","reopen":false,"closed_on":"2016-10-17T17:30:04Z","description":"- returning null as a Collection in the callable didn't go to onError\n- adopted flowable & observable\n","id":"183459082","title":"2.x: Distinct Operator - delegate null Collection down to onError","opened_on":"2016-10-17T16:08:10Z","closed_by":"akarnokd"},{"number":"4716","reopenOn":null,"comments":[{"date":"2016-10-17T09:33:12Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4716?src=pr) is 84.09% (diff: 100%)\n\n> Merging [#4716](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4716?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **<.01%**\n\n``` diff\n@@                1.x      #4716   diff @@\n==========================================\n  Files           288        288          \n  Lines         17986      17987     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2746       2745     -1   \n==========================================\n+ Hits          15125      15127     +2   \n- Misses         1981       1983     +2   \n+ Partials        880        877     -3   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [1ac5834...bdbd69f](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/1ac583435308aa354a2f82101cb4815313f2cfd8...bdbd69f6ce7e63d2e43e0fb360d321080b5adf2e?src=pr)\n"},{"date":"2016-10-25T13:13:04Z","author":"marwinxxii","text":"Hi everyone,\n\nSeems like `subscribe(SingleSubscriber)` overload has the same problem, because `Single.just(1).subscribe(new SingleSubscriber<Integer>(){...}).isUnsubscribed()` returns `false`.\n\nI checked version 1.2.2-SNAPSHOT. In 1.2.0 it returns `true` as expected.\n"},{"date":"2016-10-25T13:18:12Z","author":"akarnokd","text":"@marwinxxii Single has no notion of `SafeSingleSubscriber` and the internals got changed to improve performance. Therefore, you are responsible calling `unsubscribe` in your implementation of `onSuccess` and `onCompleted`.\n"},{"date":"2016-10-25T14:49:23Z","author":"marwinxxii","text":"Sorry, I missed this part in PR description.\n\nMay be this should be added to SingleSubscriber documentation (or may be `Single.subscribe(SingleSubscriber)`?\n"},{"date":"2016-10-25T14:51:25Z","author":"akarnokd","text":"PR welcome to change the docs.\n"},{"date":"2016-10-25T22:32:57Z","author":"marwinxxii","text":"Done - #4769\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-17T17:16:45Z","description":"The lambda version didn't report `isUnsubscribed()` as before because of the removal of the `SafeSubscriber` wrapping. This PR makes sure it reports consistently again.\n\nRepored in: #4715\n\nNote that there is no `unsafeSubscribe(SingleSubscriber)` so a regular `subscribe(SingleSubscriber)` by default won't report `isUnsubscribed() == true` unless the implementation of `onSuccess` and `onError` - controlled by the user - doesn't call `unsubscribe` on itself.\n","id":"183355633","title":"1.x: fix subscribe(Action1 [, Action1]) to report isUnsubscribed","opened_on":"2016-10-17T08:34:02Z","closed_by":"akarnokd"},{"number":"4715","reopenOn":null,"comments":[{"date":"2016-10-17T08:19:38Z","author":"akarnokd","text":"There were internal changes to `Single` that got rid of the `SafeSubscriber` and with it the reporting on `isUnsubscribed`. If you don't call `unsubscribe` it doesn't report `true` on termination. I'll try to hunt down such cases.\n"},{"date":"2016-10-17T18:39:53Z","author":"akarnokd","text":"Closing via #4716\n"}],"opened_by":"chibatching","reopen":false,"closed_on":"2016-10-17T18:39:53Z","description":"I updated from 1.2.0 to 1.2.1.\n\nUntil 1.2.0, `Subscription#isUnsubscribed` return `true` after `onSuccess`.\nBut from 1.2.1, `Subscription#isUnsubscribed` keeps `false` even if `onSuccess` \/ `onError` is called.\n\nIs this a expected behavior change? If so, sorry to file rude issue.\n\nThis can reproduce with below simple code. \n\n``` java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        final Subscription subscription = Single.create(new Single.OnSubscribe<Boolean>() {\n            @Override\n            public void call(SingleSubscriber<? super Boolean> singleSubscriber) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    singleSubscriber.onSuccess(true);\n                }\n            }\n        })\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(\n                        new Action1<Boolean>() {\n                            @Override\n                            public void call(Boolean aBoolean) {\n                                Toast.makeText(MainActivity.this, \"success\", Toast.LENGTH_SHORT).show();\n                            }\n                        },\n                        new Action1<Throwable>() {\n                            @Override\n                            public void call(Throwable throwable) {\n                                Toast.makeText(MainActivity.this, \"error\", Toast.LENGTH_SHORT).show();\n                            }\n                        }\n                );\n\n        findViewById(R.id.check_subscription_button).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                boolean status = subscription.isUnsubscribed();\n                Toast.makeText(MainActivity.this, \"unsubscribed status: \" + status,\n                        Toast.LENGTH_SHORT).show();\n            }\n        });\n    }\n}\n```\n\nThanks\n","id":"183349691","title":"Subscription#isUnsubscribed of Single keep false after onSuccess\/onError","opened_on":"2016-10-17T08:01:57Z","closed_by":"akarnokd"},{"number":"4714","reopenOn":null,"comments":[{"date":"2016-10-16T14:42:34Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4714?src=pr) is 89.08% (diff: 86.53%)\n\n> Merging [#4714](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4714?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **1.44%**\n\n``` diff\n@@                2.x      #4714   diff @@\n==========================================\n  Files           569        570     +1   \n  Lines         37124      37268   +144   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5655       5685    +30   \n==========================================\n+ Hits          32536      33199   +663   \n+ Misses         2910       2476   -434   \n+ Partials       1678       1593    -85   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [788873e...428027f](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/788873e29511758ae5ccb84133e53c86f9caac38...428027f60024c5c27626475c060b6c5f196c4330?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-17T06:58:52Z","description":"- copy the recent unit tests from `Observable` to `Flowable`\n- fix the same bugs\n- perform the same cleanups\n- compact the same operators\n- factor out fusion method and constants to `QueueFuseable`\n- have `Flowable.toList(Callable)` return `Single`\n","id":"183269965","title":"2.x: test sync from Observable to Flowable 10\/16-1","opened_on":"2016-10-16T14:29:41Z","closed_by":"akarnokd"},{"number":"4712","reopenOn":null,"comments":[{"date":"2016-10-15T23:04:32Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4712?src=pr) is 87.82% (diff: 96.25%)\n\n> Merging [#4712](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4712?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.73%**\n\n``` diff\n@@                2.x      #4712   diff @@\n==========================================\n  Files           568        569     +1   \n  Lines         37061      37124    +63   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5648       5655     +7   \n==========================================\n+ Hits          32277      32603   +326   \n+ Misses         3083       2864   -219   \n+ Partials       1701       1657    -44   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [fe4acf2...d2cea35](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/fe4acf2a68b8f86b5bab4ca27695627ad32201d6...d2cea35d2e02bc77791c1ade1abc0cedacca4366?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-16T09:23:22Z","description":"- more `Observable` coverage\n- make `Observable.sequenceEqual` return `Single<Boolean>`\n- reimplement `Observable.distinct()`\n- fix `Observable.combineLatest` error management\n- remove or compact unused code paths\n- fix `Observable.flatMap` maxConcurrency behavior with scalars, use of unbounded queue\n- fix `Observable.timeInterval` not saving the `Disposable` \n","id":"183237474","title":"2.x: coverage, cleanup, fixes 10\/15-2","opened_on":"2016-10-15T22:47:40Z","closed_by":"akarnokd"},{"number":"4708","reopenOn":null,"comments":[{"date":"2016-10-15T16:50:34Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4708?src=pr) is 87.19% (diff: 95.52%)\n\n> Merging [#4708](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4708?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.98%**\n\n``` diff\n@@                2.x      #4708   diff @@\n==========================================\n  Files           567        568     +1   \n  Lines         37154      37061    -93   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5680       5648    -32   \n==========================================\n+ Hits          32032      32316   +284   \n+ Misses         3360       3042   -318   \n+ Partials       1762       1703    -59   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [d250ae7...45eaba1](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d250ae7e90424f56cc267a96435a10eec99a8dcc...45eaba108aebe34a0fcf018e0b0a8766533f3230?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-15T17:17:54Z","description":"- improve coverage of `Observable` operators\n- remove unnecessary code paths\n- fix `publish(Function)` latecommer behavior\n- remove `bufferSize` overloads of `publish` as there is no need to buffer anything for an `Observable`\n- simplify `Observable.publish`\n","id":"183218848","title":"2.x: coverage, fixes, cleanup 10\/15-1","opened_on":"2016-10-15T16:36:13Z","closed_by":"akarnokd"},{"number":"4707","reopenOn":null,"comments":[{"date":"2016-10-15T12:36:42Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4707?src=pr) is 86.34% (diff: 100%)\n\n> Merging [#4707](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4707?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.12%**\n\n``` diff\n@@                2.x      #4707   diff @@\n==========================================\n  Files           567        567          \n  Lines         37154      37154          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5680       5680          \n==========================================\n+ Hits          32034      32082    +48   \n+ Misses         3355       3312    -43   \n+ Partials       1765       1760     -5   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [212db45...dcd8ff5](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/212db455ba1d7e2a84da20ae272a6c4bce183ea3...dcd8ff5b85e814b4f8febf0116c1cca68ae33db2?src=pr)\n"}],"opened_by":"vanniktech","reopen":false,"closed_on":"2016-10-15T12:44:59Z","description":"- fixes Flowable.elementAt on an empty source \n- sync tests between Observable & Flowable elementAt\n","id":"183206906","title":"2.x: Fix Flowable.elementAt on empty sources. Plus sync tests","opened_on":"2016-10-15T12:22:03Z","closed_by":"akarnokd"},{"number":"4692","reopenOn":null,"comments":[{"date":"2016-10-12T01:24:38Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4692?src=pr) is 83.53% (diff: 98.17%)\n\n> Merging [#4692](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4692?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.67%**\n\n``` diff\n@@                2.x      #4692   diff @@\n==========================================\n  Files           566        567     +1   \n  Lines         37564      37618    +54   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5782       5790     +8   \n==========================================\n+ Hits          31124      31423   +299   \n+ Misses         4406       4196   -210   \n+ Partials       2034       1999    -35   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [6ad74b3...7421090](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6ad74b366ae6cea0260974d49642883840281bc0...7421090fb449e8fad911614961fd8fa41698a7a2?src=pr)\n"},{"date":"2016-10-12T07:04:52Z","author":"akarnokd","text":"It was sitting in the Travis job queue.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-12T07:04:56Z","description":"- cover remaining `Maybe` operators\n- cover `Single` operators\n- cover some of the `Completable` operators\n- fix missing `onSubscribe` calls\n- compact a few operator implementations\n- fix the order of inner Throwables on certain `CompositeException` emissions\n","id":"182387602","title":"2.x: coverage, fixes and cleanup 10\/11-2","opened_on":"2016-10-11T22:11:31Z","closed_by":"akarnokd"},{"number":"4686","reopenOn":null,"comments":[{"date":"2016-10-10T08:17:55Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4686?src=pr) is 82.04% (diff: 100%)\n\n> No coverage report found for **2.x** at 5209ba3.\n> \n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [5209ba3...b6490ea](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5209ba343df1cba3cbd75dabaa4af4eb268b3af4...b6490ea6533bcbe470d23da4899c521830699e73?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-10T16:11:05Z","description":"A non-delayed error set the cancellation flag and thus any subsequent drain would just quit instead of delivering the error.\n\n(And while I'm at it, I'll try to figure out a way to not get killed by OOMKiller).\n\nReported in #4684.\n","id":"181954346","title":"2.: Fix flatMapX over-cancellation in case of an inner error","opened_on":"2016-10-10T07:53:11Z","closed_by":"akarnokd"},{"number":"4684","reopenOn":null,"comments":[{"date":"2016-10-09T09:50:34Z","author":"akarnokd","text":"Does `Single.fromCallable` work on its own?\n"},{"date":"2016-10-09T09:56:59Z","author":"falcon71","text":"Yes, if I subscribe just to the Single.fromCallable, onError gets called. \nI noticed that innerError and dispose get called on ObservableFlatMapSingle, before drainLoop just returns because the cancelled flag is set.\n"},{"date":"2016-10-09T10:00:03Z","author":"akarnokd","text":"Yes, that's a bug.\n"},{"date":"2016-10-09T10:37:15Z","author":"akarnokd","text":"I can't fix this today but perhaps you or @vanniktech can do it. Just don't have the code call dispose but inline the cleanup code or factor that out into a method everybody calls. Note that this is likely affecting all 4 flatMapX.\n"},{"date":"2016-10-10T16:11:22Z","author":"akarnokd","text":"Closing via #4686\n"}],"opened_by":"falcon71","reopen":false,"closed_on":"2016-10-10T16:11:25Z","description":"Try the following code:\n\n```\npublic static void main(final String[] args) {\n        Observable.fromArray(new String[]{\"1\",\"a\",\"2\"}).flatMapSingle(new Function<String, SingleSource<Integer>>() {\n            @Override\n            public SingleSource<Integer> apply(final String s) throws NumberFormatException {\n                \/\/return Single.just(Integer.valueOf(s)); \/\/This works\n                return Single.fromCallable(new Callable<Integer>() {\n                    @Override\n                    public Integer call() throws NumberFormatException {\n                        return Integer.valueOf(s);\n                    }\n                });\n            }\n        }).subscribe(new Observer<Integer>() {\n            @Override\n            public void onSubscribe(final Disposable d) {\n                System.out.println(\"Subscribe\");\n            }\n\n            @Override\n            public void onNext(final Integer value) {\n                System.out.println(\"Value: \" + value);\n            }\n\n            @Override\n            public void onError(final Throwable e) {\n                System.out.println(\"Error: \" + e);\n            }\n\n            @Override\n            public void onComplete() {\n                System.out.println(\"Complete\");\n            }\n        });\n    }\n```\n\nThe program will only output the Value 1, the NumberFormatException gets lost. If I were to use Single.just, the exception gets printed correctly.\n","id":"181877722","title":"2.0.0 RC4 Errors get lost with flatMapSingle and Single.fromCallable","opened_on":"2016-10-09T09:44:52Z","closed_by":"akarnokd"},{"number":"4681","reopenOn":null,"comments":[{"date":"2016-10-07T09:37:35Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4681?src=pr) is 82.15% (diff: 0.00%)\n\n> Merging [#4681](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4681?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.17%**\n\n``` diff\n@@                2.x      #4681   diff @@\n==========================================\n  Files           565        565          \n  Lines         37426      37426          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5746       5746          \n==========================================\n+ Hits          30682      30749    +67   \n+ Misses         4666       4608    -58   \n+ Partials       2078       2069     -9   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [27e8dad...5e3ce8e](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/27e8dade8bcb29cf4a6a4cc3aee296533c259cad...5e3ce8e86d85d5e89c1f16fcd193e7f9fb6f75cb?src=pr)\n"},{"date":"2016-10-07T09:47:57Z","author":"akarnokd","text":"You may have to check the build and restart it a few times if it fails with `jacocoTestReport`.\n"}],"opened_by":"vanniktech","reopen":false,"closed_on":"2016-10-07T09:48:01Z","description":"This will fix #4680\n- elementAtOrError(1) on an empty source just leaves the new Single hanging without signalling onError()\n- elementAt(1) on an empty source just leaves the Maybe hanging without signalling onComplete()\n- I also noticed that elementAt() with a default value on an empty source did not work either.\n","id":"181615330","title":"2.x: Fix Flowable + Single elementAt and elementAtOrError operators on empty sources","opened_on":"2016-10-07T08:49:50Z","closed_by":"akarnokd"},{"number":"4680","reopenOn":null,"comments":[{"date":"2016-10-07T08:31:18Z","author":"akarnokd","text":"Sure.\n"},{"date":"2016-10-07T09:48:28Z","author":"akarnokd","text":"Closing via #4681\n"}],"opened_by":"vanniktech","reopen":false,"closed_on":"2016-10-07T09:48:28Z","description":"`elementAtOrError(1)` on an empty source just leaves the new Single hanging without signalling `onError()`:\n\n``` java\nObservable.empty()\n    .elementAtOrError(1)\n    .test()\n    .assertFailure(NoSuchElementException.class);\n```\n\n`elementAt(1)` on an empty source just leaves the Maybe hanging without signalling `onComplete()`:\n\n```\nObservable.empty()\n    .elementAt(1)\n    .test()\n    .assertResult();\n```\n\nJust tested this against RC4. Happy to fix this.\n","id":"181610209","title":"2.x: ElementAt Operators in Observable and Flowable don't behave correctly on empty sources","opened_on":"2016-10-07T08:20:55Z","closed_by":"akarnokd"},{"number":"4678","reopenOn":null,"comments":[{"date":"2016-10-06T20:41:41Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4678?src=pr) is 82.18% (diff: 66.66%)\n\n> Merging [#4678](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4678?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.13%**\n\n``` diff\n@@                2.x      #4678   diff @@\n==========================================\n  Files           565        565          \n  Lines         37414      37426    +12   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5746       5746          \n==========================================\n+ Hits          30698      30759    +61   \n+ Misses         4626       4586    -40   \n+ Partials       2090       2081     -9   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [4562e69...9dd11ef](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/4562e69dea4ec1cbde22833a562602f97e175990...9dd11efa863c3e34b6e7f89b6c68ab509aedb116?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-06T20:55:18Z","description":"I forgot to synchronize the offer part of the new flatMapX operators (since of course, Spsc is for single producer only but here there could be concurrent non fast-path queueing of values). \n\n(There is an MpscLinkedArrayQueue in JCTools but I'm not confident in it and don't want to use MpscLinkedQueue due to the node allocation.)\n","id":"181502461","title":"2.x: fix flatMapX calling SpscLinkedArrayQueue.offer concurrently","opened_on":"2016-10-06T19:19:09Z","closed_by":"akarnokd"},{"number":"4666","reopenOn":null,"comments":[{"date":"2016-10-04T14:00:03Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4666?src=pr) is 82.31% (diff: 77.19%)\n\n> Merging [#4666](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4666?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **1.21%**\n\n``` diff\n@@                2.x      #4666   diff @@\n==========================================\n  Files           556        557     +1   \n  Lines         36420      36402    -18   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5576       5568     -8   \n==========================================\n+ Hits          29539      29965   +426   \n+ Misses         4869       4438   -431   \n+ Partials       2012       1999    -13   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [df94c0d...247b6c7](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/df94c0d23b8f06ec861c2533313555cc6f8afdcb...247b6c776a79b835f89891230fb291b5db31bb72?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-10-04T16:51:30Z","description":"- Improve coverage\n- remove unused, unnecessary or impossible code paths\n- fix order of inner exceptions in the reported `CompositeException` in various operators\n- `Maybe.ignoreElement()` now returns `Completable`\n","id":"180896459","title":"2.x: coverage and cleanup 10\/04-1","opened_on":"2016-10-04T13:41:51Z","closed_by":"akarnokd"},{"number":"4654","reopenOn":null,"comments":[{"date":"2016-10-01T09:30:50Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4654?src=pr) is 77.86% (diff: 100%)\n\n> Merging [#4654](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4654?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.09%**\n\n``` diff\n@@                2.x      #4654   diff @@\n==========================================\n  Files           559        559          \n  Lines         36654      36654          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5625       5625          \n==========================================\n- Hits          28577      28542    -35   \n- Misses         6050       6075    +25   \n- Partials       2027       2037    +10   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [5ad1c04...a6a6fd6](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5ad1c046da45a69817b643eb0c6602ddab1b112c...a6a6fd62cedfa6d532d36738379545e7d00d721c?src=pr)\n"}],"opened_by":"hzsweers","reopen":false,"closed_on":"2016-10-01T09:42:59Z","description":"Resovles #4653\n\nSee http:\/\/stackoverflow.com\/a\/32955708\/61158\n","id":"180447268","title":"Upcast ConcurrentHashMap to Map to avoid compatibility issue","opened_on":"2016-10-01T09:16:22Z","closed_by":"akarnokd"},{"number":"4653","reopenOn":null,"comments":[{"date":"2016-10-01T09:02:42Z","author":"hzsweers","text":"Interestingly, if I breakpoint this line, the rest of the app appears to run just fine and isn't blocked. As soon as I let it pass though, it crashes.\n"},{"date":"2016-10-01T09:03:49Z","author":"akarnokd","text":"Java 8 changed the return type of `keySet` and it trips AnimalSniffer as well. In theory, by compiling with javac 7, there should be no binding to Java 8's type there.\n"},{"date":"2016-10-01T09:06:13Z","author":"hzsweers","text":"doesn't that come at the expense of being able to target Java 8 entirely though?\n"},{"date":"2016-10-01T09:07:02Z","author":"akarnokd","text":"Let's see if http:\/\/stackoverflow.com\/a\/32955708\/61158 works for us as well.\n"},{"date":"2016-10-01T09:07:53Z","author":"akarnokd","text":"While you are at this, could you post a PR with the fix above?\n"},{"date":"2016-10-01T09:13:36Z","author":"hzsweers","text":"Looks like that fixed it when I test locally, will upload a PR in a sec\n"},{"date":"2016-10-01T09:46:29Z","author":"akarnokd","text":"Closing via #4654.\n"}],"opened_by":"hzsweers","reopen":false,"closed_on":"2016-10-01T09:46:29Z","description":"If I have an Android app targeting source compatibility 1.8, I get the following exception at runtime on a 7.0 device:\n\n```\nFATAL EXCEPTION: RxSchedulerPurge-1\n     Process: io.sweers.catchup.debug, PID: 29250\n     java.lang.NoSuchMethodError: No virtual method keySet()Ljava\/util\/concurrent\/ConcurrentHashMap$KeySetView; in class Ljava\/util\/concurrent\/ConcurrentHashMap; or its super classes (declaration of 'java.util.concurrent.ConcurrentHashMap' appears in \/system\/framework\/core-libart.jar)\n         at io.reactivex.internal.schedulers.SchedulerPoolFactory$1.run(SchedulerPoolFactory.java:69)\n         at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:428)\n         at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:278)\n         at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:273)\n         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n         at java.lang.Thread.run(Thread.java:761)\n```\n\nThe exact line is:\n\n``` java\nfor (ScheduledThreadPoolExecutor e : new ArrayList<ScheduledThreadPoolExecutor>(POOLS.keySet())) {  \/\/ CHM.keySet returns KeySetView in Java 8+; false positive here\n```\n\nWhen I look at it in the debugger, it is indeed a KeySetView, but I'm not sure what the issue is here. Let me know if this would be better served posting in RxAndroid.\n\nCC @JakeWharton \n","id":"180446739","title":"2.x: Possible 6.x\/Android compatibility issue","opened_on":"2016-10-01T09:00:37Z","closed_by":"akarnokd"},{"number":"4645","reopenOn":null,"comments":[{"date":"2016-09-29T23:46:14Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4645?src=pr) is 77.82% (diff: 65.38%)\n\n> Merging [#4645](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4645?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **<.01%**\n\n``` diff\n@@                2.x      #4645   diff @@\n==========================================\n  Files           562        562          \n  Lines         36708      36724    +16   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5634       5636     +2   \n==========================================\n+ Hits          28564      28579    +15   \n- Misses         6101       6103     +2   \n+ Partials       2043       2042     -1   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [d08266b...27c29f8](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d08266bb95e8cddbb9ba5cf39afbe08e16525d1a...27c29f8ff3917b5310cd3d52c1464a77951a3722?src=pr)\n"}],"opened_by":"VictorAlbertos","reopen":false,"closed_on":"2016-09-30T07:01:49Z","description":"This PR addresses #4640\n","id":"180188525","title":"2.x Signal NPE ObservableAmb FlowableAmb","opened_on":"2016-09-29T23:32:44Z","closed_by":"akarnokd"},{"number":"4641","reopenOn":null,"comments":[{"date":"2016-09-29T20:39:07Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4641?src=pr) is 84.56% (diff: 100%)\n\n> Merging [#4641](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4641?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.08%**\n\n``` diff\n@@                1.x      #4641   diff @@\n==========================================\n  Files           274        274          \n  Lines         17766      17766          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2727       2727          \n==========================================\n+ Hits          15009      15024    +15   \n+ Misses         1889       1878    -11   \n+ Partials        868        864     -4   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [2b47efe...d66196a](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2b47efee292099ea7f27a606a421e22aca76dc2e...d66196a56215813e3e1a786ee1f703215725631f?src=pr)\n"},{"date":"2016-09-30T17:38:21Z","author":"akarnokd","text":"\/cc @dlew\n"},{"date":"2016-09-30T18:37:03Z","author":"dlew","text":"LGTM. Thanks for doing this.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-09-30T18:39:25Z","description":"Before the introduction of `RxJavaHooks`, the `SafeSubscriber._onError` called the original error handler with the exception it received which was by default an empty handler. The default `RxJavaHooks.onError` behavior, however is to signal errors to the uncaught exception handler of the caller thread which leads to unnecessary logging or app crashes even though the error itself is to be handled properly.\n\nThis PR restores the `SafeSubscriber._onError` to skip the `RxJavaHooks` and call the original handler directy so old tracking code should still get all safe error while newer hooking doesn't get called.\n\nRelated: #4332.\n","id":"180154364","title":"1.x: SafeSubscriber not to call RxJavaHooks before delivering the original error.","opened_on":"2016-09-29T20:29:26Z","closed_by":"akarnokd"},{"number":"4640","reopenOn":null,"comments":[{"date":"2016-09-29T20:35:02Z","author":"akarnokd","text":"Yes, they should be signalling NPE. Since traversing the Iterable happens way before the subscription, you could just end the traversal via `EmptySubscription.error(npe, s)` right there and not even subscribe to any non-null source.\n"},{"date":"2016-09-29T20:44:57Z","author":"VictorAlbertos","text":"Perfect, and I'll add some test to cover this scenario. \n\nShould I use the same PR to address both this issue and #4633?\n"},{"date":"2016-09-29T20:54:51Z","author":"akarnokd","text":"It's up to you; if there is no conflicting changes, you can do it separately.\n"}],"opened_by":"VictorAlbertos","reopen":false,"closed_on":"2016-09-30T10:42:13Z","description":"I was working on #4633 and I found this behaviour, which is not consistent with the current implementation of Maybe::ambIterable, Single::ambIterable and Completable::ambIterable.\n\nThe next tests throws NP\n\n``` java\n@Test\npublic void Verify_Flowable_Amb_Iterable() throws InterruptedException {\n  List<Flowable<String>> flowables = Arrays.asList(null, null, null);\n  Flowable.amb(flowables).test();\n}\n\n@Test\npublic void Verify_Observable_Amb_Iterable() throws InterruptedException {\n  List<Observable<String>> observables = Arrays.asList(null, null, null);\n  Observable.amb(observables).test();\n}\n```\n\nBut for Maybe, Single and Completable the exception is catched and passed to the pipeline error.\n\nBecase I'm using Flowable::amb(Iterable) and Observable::amb(Iterable) as a model to merge Maybe::ambIterable, Single::ambIterable and Completable::ambIterable into a single amb operator, I thought that Flowable::amb(Iterable) and Observable::amb(Iterable) should catch the error too. Doing something like [this](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/2.x\/src\/main\/java\/io\/reactivex\/internal\/operators\/completable\/CompletableAmbIterable.java#L130). \n","id":"180151272","title":"2.x Flowable::amb(Iterable) and Observable::amb(Iterable) throw NP","opened_on":"2016-09-29T20:17:16Z","closed_by":"VictorAlbertos"},{"number":"4619","reopenOn":null,"comments":[{"date":"2016-09-28T07:25:20Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4619?src=pr) is 78.12% (diff: 68.75%)\n\n> Merging [#4619](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4619?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **<.01%**\n\n``` diff\n@@                2.x      #4619   diff @@\n==========================================\n  Files           557        557          \n  Lines         36296      36284    -12   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5567       5566     -1   \n==========================================\n- Hits          28359      28346    -13   \n+ Misses         5926       5925     -1   \n- Partials       2011       2013     +2   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [534fc67...f94dfad](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/534fc6762cf05b6e8d1c3a22e70feb5a5c3fe615...f94dfada42173abf0f0c45b913e483b5b271d55f?src=pr)\n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2016-09-28T08:12:14Z","description":"Right now CompositeExcpetion has several issues:\n- `CompositeException(Throwable... exceptions)` doesn't deduplicate exceptions and flatten CompositeExceptions like `CompositeException(Iterable<? extends Throwable> errors)`\n- If using `CompositeException(Iterable<? extends Throwable> errors)` to create CompositeException, `suppress` cannot be used.\n- `suppress` doesn't update `cause`.\n- `suppress` doesn't deduplicate exceptions and flatten CompositeExceptions.\n- `suppress` and `Throwable.addSuppressed` are pretty confusing for Java 7+ users. Without looking at the implementation, it's hard to figure out the differences.\n\nThis PR made the following changes:\n- Remove `CompositeException.suppress` so that it's easy to make CompositeException thread-safe.\n  - This may cause some performance lost in some path rarely happening, e.g., an excpetion is thrown from `onError`, but that's not a big deal.\n  - Since `suppress` is removed, it doesn't make sense to create an empty CompositeException, so `isEmpty` is removed and defense codes are added.\n- Defense codes for bad exceptions.\n- Deduplicate excepctions and flatten CompositeExceptions for `CompositeException(Throwable... exceptions)`.\n","id":"179678680","title":"2.x: Make CompositeExcpetion thread-safe like 1.x and also fix some issues","opened_on":"2016-09-28T04:41:39Z","closed_by":"akarnokd"},{"number":"4601","reopenOn":null,"comments":[{"date":"2016-09-25T17:09:55Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4601?src=pr) is 78.20% (diff: 100%)\n\n> Merging [#4601](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4601?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.03%**\n\n``` diff\n@@                2.x      #4601   diff @@\n==========================================\n  Files           552        552          \n  Lines         36277      36282     +5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5602       5604     +2   \n==========================================\n+ Hits          28358      28375    +17   \n+ Misses         5909       5891    -18   \n- Partials       2010       2016     +6   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [0b2deb1...ed78069](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/0b2deb1093d7498b90f6ef3ceb7e4d6bdeed4c31...ed78069615aa50d93c8dad77adbe3128d569e880?src=pr)\n"}],"opened_by":"vanniktech","reopen":false,"closed_on":"2016-09-25T17:17:46Z","description":"","id":"179096025","title":"2.x: Sync behaviour between UnicastProcessor & UnicastSubject + add a few test cases","opened_on":"2016-09-25T16:56:30Z","closed_by":"akarnokd"},{"number":"4592","reopenOn":null,"comments":[{"date":"2016-09-23T21:09:44Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4592?src=pr) is 78.15% (diff: 66.66%)\n\n> Merging [#4592](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4592?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.10%**\n\n``` diff\n@@                2.x      #4592   diff @@\n==========================================\n  Files           552        552          \n  Lines         36247      36254     +7   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5594       5595     +1   \n==========================================\n+ Hits          28293      28335    +42   \n+ Misses         5944       5913    -31   \n+ Partials       2010       2006     -4   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [7791076...53032a9](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7791076a21d8b3d4462b320188f8263da59f2c0e...53032a951efb75112a12a8c21422c87e254236cd?src=pr)\n"},{"date":"2016-09-23T21:18:11Z","author":"akarnokd","text":"Leave this as is and I'll think about it.\n"}],"opened_by":"vanniktech","reopen":false,"closed_on":"2016-09-23T21:18:16Z","description":"","id":"178971569","title":"2.x: UnicastSubject fix onTerminate","opened_on":"2016-09-23T20:55:57Z","closed_by":"akarnokd"},{"number":"4590","reopenOn":null,"comments":[{"date":"2016-09-23T12:34:10Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4590?src=pr) is 78.14% (diff: 45.45%)\n\n> Merging [#4590](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4590?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.06%**\n\n``` diff\n@@                2.x      #4590   diff @@\n==========================================\n  Files           552        552          \n  Lines         36220      36247    +27   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5594       5594          \n==========================================\n+ Hits          28282      28326    +44   \n+ Misses         5927       5914    -13   \n+ Partials       2011       2007     -4   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [c5e38ce...051df13](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/c5e38ce3630288e38a78a20f1daeac0526184560...051df13544fc97fccaac78a64313194f10eec63f?src=pr)\n"},{"date":"2016-09-23T15:55:15Z","author":"akarnokd","text":"`TestHelper` has a few generic test methods to check `Maybe` and `Single`. The same pattern could be extended to test these without duplicating that long method. I was planning that as part of another run of coverage improvements but I'm behind with performance work too.\n"}],"opened_by":"vanniktech","reopen":false,"closed_on":"2016-09-23T15:55:22Z","description":"For the first one that I found I even wrote a test. Then I started noticing more missing spots. If wanted I could port that one test to every operator that I touched. Though I didn't really find tests testing that errors are propagated through the Plugin API.\n","id":"178862200","title":"2.x: Report errors from onError to Plugin when done","opened_on":"2016-09-23T12:18:41Z","closed_by":"akarnokd"},{"number":"4583","reopenOn":null,"comments":[{"date":"2016-09-22T18:44:44Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4583?src=pr) is 78.04% (diff: 70.00%)\n\n> Merging [#4583](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4583?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.02%**\n\n``` diff\n@@                2.x      #4583   diff @@\n==========================================\n  Files           552        552          \n  Lines         36156      36184    +28   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5574       5584    +10   \n==========================================\n+ Hits          28209      28239    +30   \n- Misses         5924       5925     +1   \n+ Partials       2023       2020     -3   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [6e99ad0...37c2e45](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6e99ad0a5f37ecbb9bb752aebe03bca99adbf03c...37c2e4520d81f8b61e3bb8ce0f74aaf0136032f2?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-09-22T19:07:56Z","description":"exception msg across\n\nReported on [Stackoverflow](http:\/\/stackoverflow.com\/questions\/39622458\/flowableemitter-doesnt-signal-error-when-onnext-got-null).\n\nThere was no proper null check in the various emitters. I've also unified the message pattern across all `create()` emitters.\n","id":"178685036","title":"2.x fix Flowable.create() not reporting null values properly, unify","opened_on":"2016-09-22T18:26:51Z","closed_by":"akarnokd"},{"number":"4562","reopenOn":null,"comments":[{"date":"2016-09-15T19:35:41Z","author":"JakeWharton","text":"We can mark the value as transient in the exception.\n\nOn Thu, Sep 15, 2016 at 3:29 PM saharh notifications@github.com wrote:\n\n> when throwing a runtime exception during OnNext, the exception is wrapped\n> within OnErrorThrowable$OnNextValue, which features access to the value\n> emitted in OnNext. this feature comes at a cost - If one would wish to\n> serialize\/deserialize the exception or any object containing that\n> exception, one would also be required to have the type of item emitted by\n> OnNext also implement Serializable (which could lead to whole hierarchy of\n> objects be serializable). While the original runtime exception thrown is\n> serializable, the OnErrorThrowable$OnNextValue which includes reference to\n> the onnext emitted item, isn't.\n> This leads to java.io.NotSerializableException thrown when trying to\n> serialize the exception:\n> \n> ```\n>                                                                      Caused by: java.io.NotSerializableException: com.example.sample.SomeUnserializableObject\n>                                                                         at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1344)\n>                                                                         at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)\n>                                                                         at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)\n>                                                                         at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)\n>                                                                         at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)\n>                                                                         at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)\n>                                                                         at java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1054)\n>                                                                         at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1384)\n>                                                                         at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)\n>                                                                         at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)\n>                                                                         at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)\n>                                                                         at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)\n>                                                                         at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)\n>                                                                         at java.lang.Throwable.writeObject(Throwable.java:436)\n>                                                                         at java.lang.reflect.Method.invoke(Native Method)\n>                                                                         at java.io.ObjectO\n> ```\n> \n> I dont see any way around it other than avoiding throwing of\n> RuntimeException during onNext, and instead move to flatmap and return\n> Observable.error(exception).\n> \n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/issues\/4562, or mute the thread\n> https:\/\/github.com\/notifications\/unsubscribe-auth\/AAEEEd3gv1EWHy9yKNEmMMtIbHjEAqpjks5qqZyhgaJpZM4J-QSY\n> .\n"},{"date":"2016-09-18T15:15:23Z","author":"rzsombor","text":"I must ask: what's your use case where you want to serialize exceptions? Are passing them over to some other process maybe?\n"},{"date":"2016-09-19T14:41:39Z","author":"saharh","text":"It is a rather rare use case, but i do pass a result which might include an exception between activities in android, which requires the object to be serializable\n"},{"date":"2016-11-12T12:29:27Z","author":"akarnokd","text":"See #4841\n"},{"date":"2016-11-12T18:31:58Z","author":"akarnokd","text":"Closing via #4841\n"}],"opened_by":"saharh","reopen":false,"closed_on":"2016-11-12T18:31:58Z","description":"when throwing a runtime exception during OnNext, the exception is wrapped within OnErrorThrowable$OnNextValue, which features access to the value emitted in OnNext. this feature comes at a cost - If one would wish to serialize\/deserialize the exception or any object containing that exception, one would also be required to have the type of item emitted by OnNext also implement Serializable (which could lead to whole hierarchy of objects be serializable). While the original runtime exception thrown is serializable, the OnErrorThrowable$OnNextValue which includes reference to the onnext emitted item, isn't.\nThis leads to java.io.NotSerializableException thrown when trying to serialize the exception:\n\n```\nCaused by: java.io.NotSerializableException: com.example.SomeUnserializableObject\n        at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1344)\n        at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)\n        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)\n        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)\n        at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)\n        at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)\n        at java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1054)\n        at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1384)\n        at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)\n        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)\n        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)\n        at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)\n        at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)\n        at java.lang.Throwable.writeObject(Throwable.java:436)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at java.io.ObjectO\n```\n\nI dont see any way around it other than avoiding throwing of RuntimeException during onNext, and instead move to flatmap and return Observable.error(exception).\n","id":"177266840","title":"throwing a Serializable RuntimeException in OnNext requires OnNext value to be Serializable as well","opened_on":"2016-09-15T19:29:35Z","closed_by":"akarnokd"},{"number":"4536","reopenOn":null,"comments":[{"date":"2016-09-12T17:12:24Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4536?src=pr) is 78.72% (diff: 100%)\n\n> Merging [#4536](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4536?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **<.01%**\n\n``` diff\n@@                2.x      #4536   diff @@\n==========================================\n  Files           527        527          \n  Lines         35142      35142          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5457       5457          \n==========================================\n+ Hits          27663      27665     +2   \n  Misses         5509       5509          \n+ Partials       1970       1968     -2   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [56d5586...2dc0132](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/56d5586f5ed8b08576418f6e8c8a2ea9c39ccb46...2dc01325efd52211e52befa59dbaed20f006b741?src=pr)\n"},{"date":"2016-09-12T17:21:48Z","author":"akarnokd","text":"Thanks!\n"}],"opened_by":"nsk-mironov","reopen":false,"closed_on":"2016-09-12T17:21:50Z","description":"","id":"176428000","title":"Observable.timeout\/Flowable.timeout should unsubscribe from underlying subscription on dispose","opened_on":"2016-09-12T16:58:32Z","closed_by":"akarnokd"},{"number":"4525","reopenOn":null,"comments":[{"date":"2016-09-10T11:24:55Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4525?src=pr) is 78.71% (diff: 100%)\n\n> Merging [#4525](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4525?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **<.01%**\n\n``` diff\n@@                2.x      #4525   diff @@\n==========================================\n  Files           515        515          \n  Lines         34643      34644     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5431       5431          \n==========================================\n+ Hits          27268      27269     +1   \n+ Misses         5409       5408     -1   \n- Partials       1966       1967     +1   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [44c5705...4a972f2](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/44c5705b45af3733d8180cd47cdc16146ad9dda2...4a972f2ad4ec11397d6eee147b44bb3e6ab050bb?src=pr)\n"},{"date":"2016-09-10T11:43:03Z","author":"vanniktech","text":"This should be it now\n"},{"date":"2016-09-10T11:43:27Z","author":"akarnokd","text":"Single has exactly 1 and Maybe at most 1 item, so there is only 1 latest that can happen thus there is no difference between combineLatest and zip for these sources.\n"},{"date":"2016-09-10T11:43:43Z","author":"akarnokd","text":":+1:\n"},{"date":"2016-09-10T11:47:30Z","author":"vanniktech","text":"Yup I immediately noticed it after I wrote my comment :D that's also why I deleted it\n"}],"opened_by":"vanniktech","reopen":false,"closed_on":"2016-09-10T12:13:54Z","description":"Fixes #4524\n\nTest for combineLatest fill follow\n","id":"176174536","title":"2.x: Fix Generics T[] in Zip & CombineLatest","opened_on":"2016-09-10T11:12:38Z","closed_by":"akarnokd"},{"number":"4524","reopenOn":null,"comments":[{"date":"2016-09-10T06:55:46Z","author":"akarnokd","text":"Totally possible. Can you post a small unit test that fails?\n"},{"date":"2016-09-10T08:19:19Z","author":"dynaxis","text":"``` Java\n    @Test\n    public void zipIterableOfObservables() {\n        List<Observable<Integer>> observables =\n                new ArrayList<Observable<Integer>>();\n        observables.add(Observable.just(1, 2, 3));\n        observables.add(Observable.just(1, 2, 3));\n\n        Observable.zip(observables, new Function<Integer[], Integer>() {\n            @Override\n            public Integer apply(Integer[] o) throws Exception {\n                int sum = 0;\n                for (int i : o) {\n                    sum += i;\n                }\n                return sum;\n            }\n        }).test().assertResult(2, 4, 6);\n    }\n```\n\nPlease note that if we use lambda as a zipper, it eventually generates what the above test has.\n"},{"date":"2016-09-10T08:27:16Z","author":"dynaxis","text":"FYI, the following works and it's what is generated with the 1.x signature:\n\n``` Java\n    @Test\n    public void zipIterableOfObservables() {\n        List<Observable<Integer>> observables =\n                new ArrayList<Observable<Integer>>();\n        observables.add(Observable.just(1, 2, 3));\n        observables.add(Observable.just(1, 2, 3));\n\n        Observable.zip(observables, new Function<Object[], Object>() {\n            @Override\n            public Object apply(Object[] o) throws Exception {\n                int sum = 0;\n                for (Object i : o) {\n                    sum += (Integer) i;\n                }\n                return sum;\n            }\n        }).test().assertResult(2, 4, 6);\n    }\n```\n"},{"date":"2016-09-10T09:00:20Z","author":"akarnokd","text":"Thanks. The underlying problem is that we can't do `new T[n]` and such lambdas cast the bridge `Object apply(Object[])` argument to `Integer[]` which fails since `zip` and `combineLatest` use `Object[]` internally.\n\nCurrently I can't write a PR. @vanniktech could you change all `? super T[]` signatures back to `? super Object[]` and add unit tests like above to verify there is no `ClassCastException` in a PR?\n"},{"date":"2016-09-10T10:38:21Z","author":"vanniktech","text":"Sure 👍 \n"},{"date":"2016-09-12T14:27:45Z","author":"akarnokd","text":"Closing via #4525.\n"},{"date":"2016-09-23T15:11:10Z","author":"dynaxis","text":"BTW, why use array instead of `List` there? Any reason? If `List` is used, then at least it seems safe with generics, doesn't it?\n"},{"date":"2016-09-23T15:49:59Z","author":"akarnokd","text":"Using array has reduced allocation cost and less indirection.\n"}],"opened_by":"dynaxis","reopen":false,"closed_on":"2016-09-12T14:27:45Z","description":"http:\/\/reactivex.io\/RxJava\/2.x\/javadoc\/io\/reactivex\/Observable.html#zip-java.lang.Iterable-io.reactivex.functions.Function-\n\nThe `zipper` signature is `Function<? super T[]>, ? extends R> zipper`, where use of `T[]` breaks it. Just invoke it with non `Object` T, and a `ClassCastException` is thrown.\n\nI checked with `Single` and `Flowable`, they have different signatures for the comparable `zip` operators. They use `Object[]` where `T[]` is used for `Observable`, which are also consistent with the 1.x zip operator.\n\nI think this is just a bug in the signature.\n","id":"176146041","title":"RxJava2 `Observable.zip` taking `Iterable` and a `zipper` is broken","opened_on":"2016-09-10T01:17:24Z","closed_by":"akarnokd"},{"number":"4516","reopenOn":null,"comments":[{"date":"2016-09-08T22:34:33Z","author":"JakeWharton","text":":+1:\n"},{"date":"2016-09-08T22:36:33Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4516?src=pr) is 78.64% (diff: 96.92%)\n\n> Merging [#4516](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4516?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.36%**\n\n``` diff\n@@                2.x      #4516   diff @@\n==========================================\n  Files           507        507          \n  Lines         34371      34386    +15   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5391       5395     +4   \n==========================================\n+ Hits          26904      27042   +138   \n+ Misses         5480       5374   -106   \n+ Partials       1987       1970    -17   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [1145819...0ee4580](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/1145819b658983807e0cede5ba2c7d5ac1117baa...0ee4580c6235aadd210693bae3cd024add6295df?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-09-08T22:38:06Z","description":"I've forgotten to create a branch so the first part of todays coverage work [landed in 2.x direct](https:\/\/github.com\/ReactiveX\/RxJava\/commit\/1145819b658983807e0cede5ba2c7d5ac1117baa)\n- removed unused methods from various classes\n- compacted `SpscArrayQueue`\n- added null checks to `SpscLinkedArrayQueue.offer()` and `MpscLinkedQueue.offer()`\n- fixed `ResourceObserver` not calling `onStart`\n- Added direct NotificationLite-emission methods to `AppendOnlyLinkedArrayList`, updated `SerializedObserver` and `SerializedSubscriber` to use it directly instead of the former indirection\n- `TestObserver.isDisposed` now reports true if terminal events were received (#4514)\n- `ResourceSubscriber` to use `SubscriptionHelper`'s deferred Subscription\/requesting management\n- added unit tests to cover `DisposableXObserver`s\n- `SerializedObserver` and `SerializedSubscriber` now have proper unit tests each\n\nThis current PR fixes `Single.using` not properly managing the resource and adds unit tests to verify the behavior along with a few extra coverage improvements.\n","id":"175875333","title":"2.x: fix Single.using, add unit tests and coverage","opened_on":"2016-09-08T21:58:10Z","closed_by":"akarnokd"},{"number":"4514","reopenOn":null,"comments":[{"date":"2016-09-08T16:29:04Z","author":"akarnokd","text":"It's a small inconsistency. I'll fix that in my next cleanup\/coverage PR.\n"},{"date":"2016-09-08T19:49:48Z","author":"akarnokd","text":"Closing via https:\/\/github.com\/ReactiveX\/RxJava\/commit\/1145819b658983807e0cede5ba2c7d5ac1117baa\n"},{"date":"2017-03-10T14:52:05Z","author":"maksim-m","text":"@akarnokd, with RxJava 2.0.7 the test still fails:\r\n```java\r\n    @Test\r\n    public void observerShouldBeDisposed()  {\r\n        TestObserver observer = new TestObserver();\r\n        Observable.just(\"\").subscribe(observer);\r\n        observer.awaitTerminalEvent();\r\n\r\n        observer.assertNoErrors();\r\n        observer.assertComplete();\r\n        assertTrue(observer.isDisposed());\r\n    }\r\n```"},{"date":"2017-03-10T15:47:37Z","author":"akarnokd","text":"There was a problem with that change and has been reverted in #4873."}],"opened_by":"VictorAlbertos","reopen":false,"closed_on":"2016-09-08T19:49:48Z","description":"With 1.x this test pass:\n\n``` java\n@Test\n  public void subscriberShouldBeUnsubscribed() {\n    rx.observers.TestSubscriber subscriber = new rx.observers.TestSubscriber();\n    rx.Observable.just(\"\").subscribe(subscriber);\n    subscriber.awaitTerminalEvent();\n\n    subscriber.assertNoErrors();\n    subscriber.assertCompleted();\n    subscriber.assertUnsubscribed();\n  }\n```\n\nBut with 2.x this test does not pass:\n\n``` java\n  @Test\n  public void observerShouldBeDisposed()  {\n    TestObserver observer = new TestObserver();\n    Observable.just(\"\").subscribe(observer);\n    observer.awaitTerminalEvent();\n\n    observer.assertNoErrors();\n    observer.assertComplete();\n    assertThat(observer.isDisposed(), is(true));\n  }\n```\n\nI think that dispose is similar to unsubscribe (but maybe I'm wrong). So I was wondering if this is the expected behaviour.\n\n  Thanks.\n","id":"175796955","title":"2.x Should observer be disposed after the source observable has finished emitting items?","opened_on":"2016-09-08T16:15:45Z","closed_by":"akarnokd"},{"number":"4513","reopenOn":null,"comments":[{"date":"2016-09-08T16:03:16Z","author":"JakeWharton","text":":+1:\n"},{"date":"2016-09-08T16:11:41Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4513?src=pr) is 77.91% (diff: 100%)\n\n> Merging [#4513](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4513?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **<.01%**\n\n``` diff\n@@                2.x      #4513   diff @@\n==========================================\n  Files           508        508          \n  Lines         34393      34395     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5387       5387          \n==========================================\n+ Hits          26796      26800     +4   \n- Misses         5597       5600     +3   \n+ Partials       2000       1995     -5   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [939f172...8b55f5d](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/939f172b5fd39fdc83e353fa0b4626a8a61e3ee4...8b55f5dd1b05ebc7a7ea5a63d8f539978bf8de04?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-09-08T16:13:03Z","description":"Both `switchMap` implementations didn't properly cancel the current inner consumer (but instead cancelled the outer 'connection' only).\n\nReported in #4512.\n","id":"175792870","title":"2.x: fix switchMap bad cancellation","opened_on":"2016-09-08T15:58:54Z","closed_by":"akarnokd"},{"number":"4512","reopenOn":null,"comments":[{"date":"2016-09-08T15:39:16Z","author":"nsk-mironov","text":"Looks like `a.cancel()` is missed here:\nhttps:\/\/github.com\/ReactiveX\/RxJava\/blob\/2.x\/src\/main\/java\/io\/reactivex\/internal\/operators\/observable\/ObservableSwitchMap.java#L179\n"},{"date":"2016-09-08T15:43:41Z","author":"akarnokd","text":"Thanks for the feedback. Indeed, that line should be `a.cancel()`. I'll post a fix soon.\n"},{"date":"2016-09-08T16:13:26Z","author":"akarnokd","text":"Closing via #4513.\n"}],"opened_by":"nsk-mironov","reopen":false,"closed_on":"2016-09-08T16:13:26Z","description":"``` java\npublic class SwitchMapBug {\n  public static void main(String[] args) throws Exception {\n    final Disposable disposable = Observable.just(true)\n        .subscribeOn(Schedulers.io())\n        .switchMap(value -> Observable.timer(1000, TimeUnit.MILLISECONDS)\n            .compose(new TraceComposer<>(\"inner\"))\n        )\n        .compose(new TraceComposer<>(\"outer\"))\n        .subscribe();\n\n    Thread.sleep(500);\n    disposable.dispose();\n    Thread.sleep(2000);\n  }\n\n  private static class TraceComposer<T> implements Function<Observable<T>, Observable<T>> {\n    private final String prefix;\n\n    private TraceComposer(final String prefix) {\n      this.prefix = prefix;\n    }\n\n    @Override\n    public Observable<T> apply(Observable<T> observable) throws Exception {\n      return observable\n          .doOnSubscribe(disposable -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doOnSubscribe\"))\n          .doOnDispose(() -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doOnDispose\"))\n          .doOnNext(value -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doOnNext\" + \" \" + value))\n          .doOnError(error -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doOnError\" + \" \" + error))\n          .doOnComplete(() -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doOnComplete\"))\n          .doOnTerminate(() -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doOnTerminate\"))\n          .doAfterTerminate(() -> System.out.println(\"[\" + prefix + \"]\" + \" \" + \"doAfterTerminate\"));\n\n    }\n  }\n}\n```\n\nOutput:\n\n```\n[outer] doOnSubscribe\n[inner] doOnSubscribe\n[outer] doOnDispose\n[inner] doOnNext 0\n[inner] doOnComplete\n[inner] doOnTerminate\n[inner] doAfterTerminate\n```\n\nExpected output:\n\n```\n[outer] doOnSubscribe\n[inner] doOnSubscribe\n[inner] doOnDispose\n[outer] doOnDispose\n```\n","id":"175779564","title":"[RxJava 2.0.0-RC2] Observable.switchMap doesn't unsubscribe from inner Observable","opened_on":"2016-09-08T15:08:12Z","closed_by":"akarnokd"},{"number":"4506","reopenOn":null,"comments":[{"date":"2016-09-08T10:02:09Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4506?src=pr) is 78.00% (diff: 92.85%)\n\n> No coverage report found for **2.x** at 043f37d.\n> \n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [043f37d...c1bdbeb](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/043f37ddc057158788da647ee7a8ebbf172ad21c...c1bdbebdce985072d1dcd4fdc92dbaf56c8f8f3f?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-09-08T10:22:09Z","description":"This PR fixes the operators `refCount` (ensure proper call order to onXXX), disables FindBugs due to out-of-memory kills on Travis and increases the half-time sleep of a flaky unit-test.\n","id":"175708148","title":"2.x: fix operator RefCount, disable FindBugs (due to Travis OOM)","opened_on":"2016-09-08T09:36:00Z","closed_by":"akarnokd"},{"number":"4469","reopenOn":null,"comments":[{"date":"2016-09-03T13:36:14Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4469?src=pr) is 78.18% (diff: 94.44%)\n\n> Merging [#4469](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4469?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **1.17%**\n\n``` diff\n@@                2.x      #4469   diff @@\n==========================================\n  Files           493        493          \n  Lines         33684      33629    -55   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5315       5290    -25   \n==========================================\n+ Hits          25939      26293   +354   \n+ Misses         5690       5370   -320   \n+ Partials       2055       1966    -89   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [f59ce00...52dc276](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/f59ce00934a65b880cbe5b7e06436f85e73187d9...52dc27674d2b13f3645b2be92cb8c93a3cb57b13?src=pr)\n"},{"date":"2016-09-03T14:11:09Z","author":"JakeWharton","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-09-03T14:38:36Z","description":"- enable fusion with `Observable.map`\n- remove impossible branches in some classes\n- add more tests to cover tool classes\n- fix `Observable.range()` entering regular emission if fusion-drain is interrupted\n- fix `FullArbiter` and `ObservableFullArbiter` not cancelling\/disposing the incoming Subscription\/Disposable in some cases\n","id":"174896802","title":"2.x: coverage and fixes 9\/03-2","opened_on":"2016-09-03T13:21:55Z","closed_by":"akarnokd"},{"number":"4468","reopenOn":null,"comments":[{"date":"2016-09-02T22:28:39Z","author":"JakeWharton","text":"👍 \n"},{"date":"2016-09-02T22:53:18Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4468?src=pr) is 76.91% (diff: 79.07%)\n\n> Merging [#4468](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4468?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.89%**\n\n``` diff\n@@                2.x      #4468   diff @@\n==========================================\n  Files           493        493          \n  Lines         33546      33684   +138   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5310       5315     +5   \n==========================================\n+ Hits          25502      25907   +405   \n+ Misses         5980       5711   -269   \n- Partials       2064       2066     +2   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [b15df98...4617b1f](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b15df9899183ecce0f40b132a47be5700a7c7a32...4617b1fcea50b37fee315155c2eebc2bcc168a74?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-09-02T22:53:48Z","description":"- Fixed bugs in `Flowable.sequenceEqual`, `Flowable.zip` when errors are delayed, `Flowable.onBackpressureBuffer` when errors are delayed\n- Fixed mentions of `NbpX` in some places\n- Synchronized unit tests between `Observable` and `Flowable`\n","id":"174858183","title":"2.x: coverage, bugfixes, 9\/03-1","opened_on":"2016-09-02T22:19:28Z","closed_by":"akarnokd"},{"number":"4450","reopenOn":null,"comments":[{"date":"2016-08-31T12:31:27Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4450?src=pr) is 75.82% (diff: 69.75%)\n\n> Merging [#4450](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4450?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.46%**\n\n``` diff\n@@                2.x      #4450   diff @@\n==========================================\n  Files           454        454          \n  Lines         32274      32200    -74   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5209       5178    -31   \n==========================================\n+ Hits          24322      24417    +95   \n+ Misses         5914       5769   -145   \n+ Partials       2038       2014    -24   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [81badc3...0c30b08](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/81badc3aa4732664614c160941eaabbcb668e060...0c30b087277850f637ae156b582bce8858580b17?src=pr)\n"},{"date":"2016-08-31T13:25:41Z","author":"JakeWharton","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-08-31T13:36:00Z","description":"- Improve coverage of internal classes\n- Turn more empty enums into classes with private constructors\n- Fix `Single.subscribeOn` and `Completable.subscribeOn` disposable management.\n- Create a compact `FutureSubscriber` and `FutureObserver` classes, drop their former enums\n- Deprecate `Disposables.from` methods, add `Disposables.fromX` methods where X = argument type\n- Fix error management in `Completable.mergeX` operators.\n- Remove unused methods from internal classes\n","id":"174258427","title":"2.x: fixes, cleanup, coverage 8\/31-1","opened_on":"2016-08-31T12:18:58Z","closed_by":"akarnokd"},{"number":"4448","reopenOn":null,"comments":[{"date":"2016-08-31T07:19:07Z","author":"akarnokd","text":"Thanks for the feedback, there is a state management bugin `Single.subscribeOn` that causes this. I'll post a PR to fix this today; once merged, you may want to switch to the RxJava 2 snapshots to get this fix and dozen others since RC1.\n"},{"date":"2016-08-31T14:20:43Z","author":"akarnokd","text":"Fixed in #4450.\n"},{"date":"2017-02-28T16:25:27Z","author":"bitsydarel","text":"Still getting the same error io.reactivex.exceptions.ProtocolViolationException: Disposable already set!\r\n\r\nsubscriptions.add(mWeatherObservableWithNetwork\r\n                        .subscribeOn(Schedulers.io())\r\n                        .observeOn(AndroidSchedulers.mainThread())\r\n                        .subscribeWith(mWeatherObserver));\r\n\r\nwhen i remove the subscribeOn and ObserveOn, No exception \r\n\r\nUsing rxjava 2.0.6 "},{"date":"2017-02-28T16:38:23Z","author":"akarnokd","text":"@bitsydarel Hi and thanks for using RxJava. In order to help you, could you clarify the following:\r\n\r\n- What is the type of `mWeatherObservableWithNetwork`?\r\n- Did you make sure the RxAndroid 2 doesn't force your project to use RxJava 2.0.1?\r\n- Could you provide the full stacktrace of the `ProtocolViolationException`? It may provide the hints where exactly the unwanted call happens from within RxJava."},{"date":"2017-02-28T16:56:16Z","author":"bitsydarel","text":"@akarnokd \r\n mWeatherObservableWithNetwork = Single<Weather> \r\n \r\nfrom the github of RxAndroid they suggest to use 2.0.6 :\r\nRxAndroid 2.0.1: \r\nRxJava 2.0.6:\r\n\r\nStackTrace : \r\n02-28 18:51:12.241 19971-19971\/com.darelbitsy.dbweather E\/AndroidRuntime: FATAL EXCEPTION: main\r\n                                                                          Process: com.darelbitsy.dbweather, PID: 19971\r\n                                                                          io.reactivex.exceptions.ProtocolViolationException: Disposable already set!\r\n                                                                              at io.reactivex.internal.disposables.DisposableHelper.reportDisposableSet(DisposableHelper.java:156)\r\n                                                                              at io.reactivex.internal.disposables.DisposableHelper.setOnce(DisposableHelper.java:82)\r\n                                                                              at io.reactivex.observers.DisposableSingleObserver.onSubscribe(DisposableSingleObserver.java:32)\r\n                                                                              at io.reactivex.internal.operators.single.SingleObserveOn$ObserveOnSingleObserver.onSubscribe(SingleObserveOn.java:57)\r\n                                                                              at io.reactivex.internal.operators.single.SingleSubscribeOn.subscribeActual(SingleSubscribeOn.java:35)\r\n                                                                              at io.reactivex.Single.subscribe(Single.java:2692)\r\n                                                                              at io.reactivex.internal.operators.single.SingleObserveOn.subscribeActual(SingleObserveOn.java:35)\r\n                                                                              at io.reactivex.Single.subscribe(Single.java:2692)\r\n                                                                              at io.reactivex.Single.subscribeWith(Single.java:2736)\r\n                                                                              at com.darelbitsy.dbweather.ui.CurrentWeatherFragment.lambda$-com_darelbitsy_dbweather_ui_CurrentWeatherFragment_lambda$1(CurrentWeatherFragment.java:257)\r\n                                                                              at com.darelbitsy.dbweather.ui.-$Lambda$0.$m$0(Unknown Source)\r\n                                                                              at com.darelbitsy.dbweather.ui.-$Lambda$0.onRefresh(Unknown Source)\r\n                                                                              at android.support.v4.widget.SwipeRefreshLayout$1.onAnimationEnd(SwipeRefreshLayout.java:189)\r\n                                                                              at android.support.v4.widget.CircleImageView.onAnimationEnd(CircleImageView.java:105)\r\n                                                                              at android.view.ViewGroup.finishAnimatingView(ViewGroup.java:6270)\r\n                                                                              at android.view.View.draw(View.java:16371)\r\n                                                                              at android.view.ViewGroup.drawChild(ViewGroup.java:3735)\r\n                                                                              at android.view.ViewGroup.dispatchDraw(ViewGroup.java:3525)\r\n                                                                              at android.view.View.draw(View.java:16446)\r\n                                                                              at android.view.View.updateDisplayListIfDirty(View.java:15387)\r\n                                                                              at android.view.View.draw(View.java:16188)\r\n                                                                              at android.view.ViewGroup.drawChild(ViewGroup.java:3735)\r\n                                                                              at android.view.ViewGroup.dispatchDraw(ViewGroup.java:3525)\r\n                                                                              at android.view.View.draw(View.java:16446)\r\n                                                                              at android.view.View.updateDisplayListIfDirty(View.java:15387)\r\n                                                                              at android.view.View.draw(View.java:16188)\r\n                                                                              at android.view.ViewGroup.drawChild(ViewGroup.java:3735)\r\n                                                                              at android.view.ViewGroup.dispatchDraw(ViewGroup.java:3525)\r\n                                                                              at android.view.View.draw(View.java:16446)\r\n                                                                              at android.support.v4.view.ViewPager.draw(ViewPager.java:2443)\r\n                                                                              at android.view.View.updateDisplayListIfDirty(View.java:15387)\r\n                                                                              at android.view.View.draw(View.java:16188)\r\n                                                                              at android.view.ViewGroup.drawChild(ViewGroup.java:3735)\r\n                                                                              at android.view.ViewGroup.dispatchDraw(ViewGroup.java:3525)\r\n                                                                              at android.view.View.updateDisplayListIfDirty(View.java:15379)\r\n                                                                              at android.view.View.draw(View.java:16188)\r\n                                                                              at android.view.ViewGroup.drawChild(ViewGroup.java:3735)\r\n                                                                              at android.view.ViewGroup.dispatchDraw(ViewGroup.java:3525)\r\n                                                                              at android.view.View.updateDisplayListIfDirty(View.java:15379)\r\n                                                                              at android.view.View.draw(View.java:16188)\r\n                                                                              at android.view.ViewGroup.drawChild(ViewGroup.java:3735)\r\n                                                                              at android.view.ViewGroup.dispatchDraw(ViewGroup.java:3525)\r\n                                                                              at com.android.internal.policy.PhoneWindow$DecorView.dispatchDraw(PhoneWindow.java:2751)\r\n                                                                              at android.view.View.draw(View.java:16446)\r\n                                                                              at com.android.internal.policy.PhoneWindow$DecorView.draw(PhoneWindow.java:2737)\r\n                                                                              at android.view.View.updateDisplayListIfDirty(View.java:15387)\r\n                                                                              at android.view.ThreadedRenderer.updateViewTreeDisplayList(ThreadedRenderer.java:286)\r\n                                                                              at android.view.ThreadedRenderer.updateRootDisplayList(ThreadedRenderer.java:292)\r\n                                                                              at android.view.ThreadedRenderer.draw(ThreadedRenderer.java:327)\r\n                                                                              at android.view.ViewRootImpl.draw(ViewRootImpl.java:3060)\r\n                                                                              at android.view.ViewRootImpl.performDraw(ViewRootImpl.java:2864)\r\n                                                                              at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2476)\r\n                                                                              at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1366)\r\n                                                                              at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:6758)\r\n                                                                              at android.view.Choreographer$CallbackRecord.run(Choreographer.java:896)\r\n                                                                              at android.view.Choreographer.doCallbacks(Choreographer.java:698)\r\n                                                                              at android.view.Choreographer.doFrame(Choreographer.java:633)\r\n                                                                          \tat android.view.Choreographer$FrameDisplayEventRe\r\n  "},{"date":"2017-02-28T17:04:57Z","author":"akarnokd","text":"Based on the stacktrace of `io.reactivex.observers.DisposableSingleObserver.onSubscribe(DisposableSingleObserver.java:32)` it seems you are reusing a `DisposableSingleObserver`, otherwise the failure would have been issued by `Single.observeOn` by itself. If not, please provide an example of your flow."},{"date":"2017-02-28T18:01:07Z","author":"bitsydarel","text":"That was it, thanks for the help too and for the work, really helping!\r\n\r\nthere was no mention of this behavior in the documentation right?"},{"date":"2017-02-28T21:16:42Z","author":"akarnokd","text":"It was not mentioned explicitly anywhere. I've created #5148 to track the progress on updating the documentation."},{"date":"2017-03-21T12:25:02Z","author":"xiaogu-space","text":"but I also met it like this\r\n![image](https:\/\/cloud.githubusercontent.com\/assets\/8435230\/24147250\/4d58b41c-0e74-11e7-8bc7-93815fc79333.png)\r\n\r\n![image](https:\/\/cloud.githubusercontent.com\/assets\/8435230\/24147280\/737eb150-0e74-11e7-9561-331735db302a.png)\r\n"},{"date":"2017-03-21T12:29:41Z","author":"akarnokd","text":"The provided `XObserver`s and `XSubscriber`s are not reusable; you have to create a fresh one when subscribing to a source."},{"date":"2017-03-21T12:31:40Z","author":"xiaogu-space","text":"@akarnokd thanks"},{"date":"2017-03-21T13:43:59Z","author":"akarnokd","text":"The PR #5210 adds documentation about these."}],"opened_by":"amitshekhariitbhu","reopen":false,"closed_on":"2016-08-31T14:20:43Z","description":"The below code gives the exception - (IllegalStateException: Disposable already set!):\n\n```\nSingle.just(\"Amit\")\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new SingleObserver<String>() {\n                    @Override\n                    public void onSubscribe(Disposable d) {\n                    }\n\n                    @Override\n                    public void onSuccess(String value) {\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n                });\n```\n\nBut when I remove subscribeOn and observeOn like below it works : \n\n```\nSingle.just(\"Amit\")\n                .subscribe(new SingleObserver<String>() {\n                    @Override\n                    public void onSubscribe(Disposable d) {\n                    }\n\n                    @Override\n                    public void onSuccess(String value) {\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n                });\n```\n","id":"174177105","title":"2.x: IllegalStateException: Disposable already set!","opened_on":"2016-08-31T03:37:50Z","closed_by":"akarnokd"},{"number":"4447","reopenOn":null,"comments":[{"date":"2016-08-31T03:19:00Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4447?src=pr) is 84.23% (diff: 100%)\n\n> Merging [#4447](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4447?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.03%**\n\n``` diff\n@@                1.x      #4447   diff @@\n==========================================\n  Files           271        271          \n  Lines         17599      17599          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2683       2683          \n==========================================\n+ Hits          14818      14825     +7   \n+ Misses         1919       1916     -3   \n+ Partials        862        858     -4   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [0ee2e61...c9086eb](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/0ee2e61aa43545a134d9bf210f92df76d3baa045...c9086ebb863910b4ca3f617f117a11e0f1fc9ac1?src=pr)\n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2016-08-31T07:27:17Z","description":"","id":"174174396","title":"Fix withLatestFrom's tparam","opened_on":"2016-08-31T03:09:55Z","closed_by":"akarnokd"},{"number":"4446","reopenOn":null,"comments":[{"date":"2016-08-30T23:27:48Z","author":"JakeWharton","text":"This is the place! We do that everywhere else (e.g., `Observable.fromXxx`), so it seems reasonable.\n"},{"date":"2016-08-31T07:16:24Z","author":"akarnokd","text":"I'll deprecate them and add the postfixed versions in my upcoming PR (among other fixes).\n"},{"date":"2016-08-31T14:08:11Z","author":"akarnokd","text":"Closing via #4450 \n"},{"date":"2016-08-31T14:11:01Z","author":"robeden","text":"Awesome, thanks guys.\n"}],"opened_by":"robeden","reopen":false,"closed_on":"2016-08-31T14:08:11Z","description":"(Sorry if this isn't the best place for this feedback.)\n\nDisposables.from() in 2.0 (RC-1) is annoying to use with a lambda because both Runnable and Action match. Example: \n\n```\nDisposables.from( () -> {} );             \/\/ This won't compile\nDisposables.from( (Runnable) () -> {} );  \/\/ This compiles\n```\n\nPerhaps one form should have different name?\n","id":"174147295","title":"Disposables.from annoying to use with lambda","opened_on":"2016-08-30T23:06:43Z","closed_by":"akarnokd"},{"number":"4441","reopenOn":null,"comments":[{"date":"2016-08-30T08:44:36Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4441?src=pr) is 75.32% (diff: 66.66%)\n\n> Merging [#4441](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4441?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.17%**\n\n``` diff\n@@                2.x      #4441   diff @@\n==========================================\n  Files           454        454          \n  Lines         32271      32274     +3   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5208       5209     +1   \n==========================================\n+ Hits          24249      24309    +60   \n+ Misses         6002       5928    -74   \n- Partials       2020       2037    +17   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [a856572...1617087](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/a856572327528ee05c1d1ab05426343aa0c5224b...16170870a1c3c051cb759b1e82f95c5a78878439?src=pr)\n"},{"date":"2016-08-31T07:28:08Z","author":"akarnokd","text":"Thanks! :+1:\n"}],"opened_by":"matgabriel","reopen":false,"closed_on":"2016-08-31T07:28:20Z","description":"Fix buffered objects not propagated downstream in FlowableOnBackpressureBufferStrategy\nFix drop strategy logic in FlowableOnBackpressureBufferStrategy\nAdd unit test for FlowableOnBackpressureBufferStrategy, copied from FlowableOnBackpressureBufferTest, there is still some work needed to have a better coverage\n","id":"173959463","title":"Fix FlowableOnBackpressureBufferStrategy","opened_on":"2016-08-30T08:30:41Z","closed_by":"akarnokd"},{"number":"4435","reopenOn":null,"comments":[{"date":"2016-08-28T15:10:28Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4435?src=pr) is 75.11% (diff: 94.80%)\n\n> Merging [#4435](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4435?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **1.43%**\n\n``` diff\n@@                2.x      #4435   diff @@\n==========================================\n  Files           453        453          \n  Lines         32373      32399    +26   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5220       5216     -4   \n==========================================\n+ Hits          23852      24337   +485   \n+ Misses         6435       6037   -398   \n+ Partials       2086       2025    -61   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [25e78c5...021a001](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/25e78c553a079bd84a4d8ae827c6dad899de625c...021a00180fa307afa4c3af0648bc32120a72be83?src=pr)\n"},{"date":"2016-08-28T20:21:18Z","author":"JakeWharton","text":"> Turned a few empty enums into classes with private constructor\n\nThis saves methods for Android as well. I wanted to see how many were being added before pressing the issue about this convention, but nice to see there's another motivation for not using enums here.\n"},{"date":"2016-08-28T20:21:22Z","author":"JakeWharton","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-08-28T20:56:08Z","description":"- Add tests\n- fix mistakes in `TestObserver`\n- Combine `DisposableHelper` and its inner `Disposed` enum\n- Compact `NotificationLite` and its inner `Complete` enum\n- Fix NPE in `ListCompositeDisposable` constructor\n- Fix `DeferredScalarObserver` fusion and state management\n- Turned a few empty enums into classes with private constructor: coverage can't cover them 100% otherwise. These empty enums have a constructor in their bytecode which never gets called and thus there's always 10 instructions \/ 2 method calls missing.\n- Removed `TestObserver.awaitDone()`, one should always await with timeout\n","id":"173650688","title":"2.x: cleanup, behavior clarifications, fixes, coverage 8\/28-1","opened_on":"2016-08-28T14:58:43Z","closed_by":"akarnokd"},{"number":"4434","reopenOn":null,"comments":[{"date":"2016-08-27T19:06:36Z","author":"JakeWharton","text":":+1:\n"},{"date":"2016-08-27T19:14:03Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4434?src=pr) is 73.67% (diff: 92.59%)\n\n> Merging [#4434](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4434?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **2.74%**\n\n``` diff\n@@                2.x      #4434   diff @@\n==========================================\n  Files           453        453          \n  Lines         32383      32373    -10   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5233       5220    -13   \n==========================================\n+ Hits          22969      23852   +883   \n+ Misses         7300       6437   -863   \n+ Partials       2114       2084    -30   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [70d36fb...ff7d7ff](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/70d36fbdfcb75e607e7512616205ab6fdd557e96...ff7d7ff67123f4d1f0cd80432d8006c1635b90b3?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-08-27T19:36:36Z","description":"- Remove unused code\n- Improve coverage of `Single`, `Completable` and `Observable`\n- Fix minor bugs in operators\n","id":"173610051","title":"2.x: cleanup, bugfixes, coverage 8\/27-2","opened_on":"2016-08-27T18:53:05Z","closed_by":"akarnokd"},{"number":"4431","reopenOn":null,"comments":[{"date":"2016-08-26T22:01:56Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4431?src=pr) is 70.90% (diff: 87.77%)\n\n> Merging [#4431](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4431?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.51%**\n\n``` diff\n@@                2.x      #4431   diff @@\n==========================================\n  Files           454        453     -1   \n  Lines         32371      32383    +12   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5223       5233    +10   \n==========================================\n+ Hits          22786      22962   +176   \n+ Misses         7447       7303   -144   \n+ Partials       2138       2118    -20   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [0094304...4cce05b](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/0094304aecbbf9cd9b9b6cb1b7fe524a4b2ccb75...4cce05b5d3617517ae6558e84c74de066c2234b0?src=pr)\n"},{"date":"2016-08-26T22:10:55Z","author":"JakeWharton","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-08-26T22:12:01Z","description":"- updated `Single.cache()` to be lock-free, to allocate less and work properly\n- added test coverage to some classes\n- remove unused internal `EmptyObserver`\n- update `PublishSubject` to support cross-cancellation\n- update `TestHelper.race` to use the current thread for one of the tasks\n","id":"173550246","title":"2.x: coverage, fixes, cleanup 8\/27-1","opened_on":"2016-08-26T21:48:29Z","closed_by":"akarnokd"},{"number":"4430","reopenOn":null,"comments":[{"date":"2016-08-26T13:21:19Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4430?src=pr) is 70.49% (diff: 60.29%)\n\n> Merging [#4430](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4430?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.98%**\n\n``` diff\n@@                2.x      #4430   diff @@\n==========================================\n  Files           454        454          \n  Lines         32340      32371    +31   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5217       5223     +6   \n==========================================\n+ Hits          22481      22820   +339   \n+ Misses         7663       7422   -241   \n+ Partials       2196       2129    -67   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [6dbeff4...57eda49](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6dbeff4b58a7fcfdc088751210aa2b84f0831634...57eda4942c9cd020b4e689d884949d4585666a6d?src=pr)\n"},{"date":"2016-08-26T17:43:23Z","author":"JakeWharton","text":":+1:\n"},{"date":"2016-08-26T18:17:47Z","author":"akarnokd","text":"Updated those in the first commit in this PR and all other places that used `Exceptions.propagate`.\n"},{"date":"2016-08-26T18:31:37Z","author":"JakeWharton","text":"Looks good\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-08-26T18:43:05Z","description":"The new tests revealed some bugs (nothing major).\n","id":"173448884","title":"2.x Improve coverage, fix bugs","opened_on":"2016-08-26T13:07:13Z","closed_by":"akarnokd"},{"number":"4428","reopenOn":null,"comments":[{"date":"2016-08-26T06:25:09Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4428?src=pr) is 69.51% (diff: 100%)\n\n> Merging [#4428](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4428?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.02%**\n\n``` diff\n@@                2.x      #4428   diff @@\n==========================================\n  Files           454        454          \n  Lines         32331      32340     +9   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5214       5217     +3   \n==========================================\n+ Hits          22468      22482    +14   \n+ Misses         7664       7653    -11   \n- Partials       2199       2205     +6   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [d37bb20...3b7bea3](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d37bb20a44fae19b572775deb3abf8fac18efffb...3b7bea3d25c0df72f0b3499bc84e9c3b4203b118?src=pr)\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-08-26T06:40:14Z","description":"Post-terminal event handling for `Observable.collect`.\n\nAdded three unit tests that failed on original logic.\n","id":"173377169","title":"2.x: collect - handle post terminal events  - Observable","opened_on":"2016-08-26T06:11:35Z","closed_by":"akarnokd"},{"number":"4427","reopenOn":null,"comments":[{"date":"2016-08-26T04:22:45Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4427?src=pr) is 84.26% (diff: 73.33%)\n\n> Merging [#4427](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4427?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will decrease coverage by **0.12%**\n\n``` diff\n@@                1.x      #4427   diff @@\n==========================================\n  Files           270        270          \n  Lines         17518      17533    +15   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2677       2680     +3   \n==========================================\n- Hits          14785      14775    -10   \n- Misses         1877       1897    +20   \n- Partials        856        861     +5   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [743f164...ed0dae4](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/743f164b1b2f20ed34ae97a48872a0c548375911...ed0dae4a862d32000c37be648fc06ca71adc4848?src=pr)\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-08-26T06:41:31Z","description":"`fromAsync` did not handle post-terminal events properly when overflow occurs.\n\nAdded three unit tests that failed on original logic.\n","id":"173366690","title":"1.x: fromAsync - handle post-terminal events","opened_on":"2016-08-26T04:13:59Z","closed_by":"akarnokd"},{"number":"4421","reopenOn":null,"comments":[{"date":"2016-08-24T19:42:33Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4421?src=pr) is 69.48% (diff: 73.27%)\n\n> Merging [#4421](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4421?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.03%**\n\n``` diff\n@@                2.x      #4421   diff @@\n==========================================\n  Files           454        454          \n  Lines         32372      32323    -49   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5214       5214          \n==========================================\n- Hits          22482      22459    -23   \n+ Misses         7692       7662    -30   \n- Partials       2198       2202     +4   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [35c8da6...b05aa63](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/35c8da6ca2f0c446d9e50d1c5507cc80e5ccb996...b05aa630a9a8eda6007863512395b642cca98a62?src=pr)\n"},{"date":"2016-08-24T19:47:39Z","author":"JakeWharton","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-08-24T20:02:46Z","description":"Changes:\n- fix spelling mistakes\n- more consistent parameter naming scheme based on #1353 (but incomplete, RC2)\n- fix bugs due to wrong variable naming\n- compact logic expressions\n- fix `Completable.doAfterTerminate` not called the right time\n- `onErrorReturnValue` renamed to `onErrorReturnItem`\n\n@DavidMGross once this PR has been merged, it would be great you submitted one that has `\/\/TODO` markers on those lines that need attention. The naming scheme you suggested doesn't come intuitively to me so I may skip many of them without the markers.\n","id":"173037701","title":"2.x: fixes, cleanups, renames","opened_on":"2016-08-24T19:29:58Z","closed_by":"akarnokd"},{"number":"4403","reopenOn":null,"comments":[{"date":"2016-08-22T13:23:07Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4403?src=pr) is 69.30% (diff: 65.89%)\n\n> Merging [#4403](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4403?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.32%**\n\n``` diff\n@@                2.x      #4403   diff @@\n==========================================\n  Files           448        454     +6   \n  Lines         31986      32483   +497   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5108       5204    +96   \n==========================================\n+ Hits          22274      22513   +239   \n- Misses         7568       7775   +207   \n- Partials       2144       2195    +51   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [5b8845d...7cdb19e](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/5b8845d4cfdbc2d563b90ce27db978b7e383d9e0...7cdb19eedab11edfb2af7afcbf3139939493d01a?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-08-23T07:55:26Z","description":"Notable changes:\n- Implement `concatEager` and its variants\n- Implement `onTerminateDetach`\n- Implement `distinctUntilChanged(BiPredicate)`\n- Replace `EmptyDisposable.INSTANCE` with `Disposables.empty()` due to clash with fusion (sending an INSTANCE tells a fusion-enabled source to not expect onNext values yet the test still send those - this was a problem with EmptySubscription.INSTANCE a while back too). Also added javadoc warning about its use\n- add `ObservableScalarXMap` optimization to `Observable.xMap(Function)` and their operator's `subscribeActual`\n- Make `ObservableJust` `ScalarCallable` and sync-fuseable with `ScalarDisposable` (similar to `Flowable.just()`)\n- Make `Observable.bufferSize()` public for convenience.\n- Fix `flatMap` fused `Callable` handling\n- Renamed `Objects` to `ObjectHelper` to avoid accidental bad imports of `java.util.Objects` of Java 8.\n","id":"172445348","title":"2.x: add missing ops, cleanup, fusion fixes","opened_on":"2016-08-22T12:55:12Z","closed_by":"akarnokd"},{"number":"4398","reopenOn":null,"comments":[{"date":"2016-08-21T22:21:57Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4398?src=pr) is 69.63% (diff: 0.00%)\n\n> Merging [#4398](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4398?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.01%**\n\n``` diff\n@@                2.x      #4398   diff @@\n==========================================\n  Files           448        448          \n  Lines         31984      31986     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5107       5108     +1   \n==========================================\n+ Hits          22267      22273     +6   \n+ Misses         7577       7574     -3   \n+ Partials       2140       2139     -1   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [e1cec33...eb2d3bd](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/e1cec337e0778adbc75efe6c226242cb7df62d61...eb2d3bda8e2a37ea966458e0f5b5e8fc2391ba71?src=pr)\n"}],"opened_by":"JakeWharton","reopen":false,"closed_on":"2016-08-22T07:00:34Z","description":"t2 was only initialized if canceling threw an exception. In the happy path it would have never been initialized so when onError threw the call to suppress() would NPE.\n","id":"172343390","title":"2.x: Avoid potential NPE when onError throws.","opened_on":"2016-08-21T21:48:02Z","closed_by":"akarnokd"},{"number":"4397","reopenOn":null,"comments":[{"date":"2016-08-21T15:06:57Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4397?src=pr) is 84.29% (diff: 100%)\n\n> Merging [#4397](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4397?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will decrease coverage by **0.03%**\n\n``` diff\n@@                1.x      #4397   diff @@\n==========================================\n  Files           270        270          \n  Lines         17515      17516     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2677       2677          \n==========================================\n- Hits          14770      14765     -5   \n- Misses         1885       1897    +12   \n+ Partials        860        854     -6   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [1a7de42...d6014ec](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/1a7de42630959085d9bd89d039dce51c02a4214a...d6014ec7ba5b4132b3ce8be91ed47f379d843453?src=pr)\n"},{"date":"2016-08-21T15:27:40Z","author":"akarnokd","text":":+1:  and thanks for the fix.\n"}],"opened_by":"AntonRutkevich","reopen":false,"closed_on":"2016-08-21T15:27:43Z","description":"When throttleFirst was operating on a TestScheduler, it delivered all items passed to it untill TestScheduler's time would change to a non-zero value.\n","id":"172324720","title":"1.x: Fix multiple values produced by throttleFirst with TestScheduler","opened_on":"2016-08-21T14:55:29Z","closed_by":"akarnokd"},{"number":"4382","reopenOn":"2016-08-20T23:21:48Z","comments":[{"date":"2016-08-20T23:07:55Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4382?src=pr) is 69.72% (diff: 0.00%)\n\n> Merging [#4382](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4382?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.04%**\n\n``` diff\n@@                2.x      #4382   diff @@\n==========================================\n  Files           449        449          \n  Lines         32005      32005          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5108       5108          \n==========================================\n+ Hits          22300      22315    +15   \n+ Misses         7566       7557     -9   \n+ Partials       2139       2133     -6   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [f738a85...76bd1d9](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/f738a85c37e8ffd067dc6b6108823d84a837e773...76bd1d967dfdff341b4a5027f1edd20b913a191b?src=pr)\n"}],"opened_by":"JakeWharton","reopen":true,"closed_on":"2016-08-21T00:16:21Z","description":"","id":"172295022","title":"2.x: Correctly dereference subscription before comparing against null.","opened_on":"2016-08-20T22:54:25Z","closed_by":"akarnokd"},{"number":"4364","reopenOn":null,"comments":[{"date":"2016-08-18T07:31:11Z","author":"akarnokd","text":"If you'd make it more concise, that would be great. Also note that most Flowable operators have an Observable counterpart so it would be nice if such changes would contain the fix & tests for both.\n"},{"date":"2016-08-18T14:53:07Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4364?src=pr) is 69.33% (diff: 100%)\n\n> Merging [#4364](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4364?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.05%**\n\n``` diff\n@@                2.x      #4364   diff @@\n==========================================\n  Files           454        454          \n  Lines         32483      32492     +9   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       5204       5207     +3   \n==========================================\n+ Hits          22504      22529    +25   \n+ Misses         7776       7764    -12   \n+ Partials       2203       2199     -4   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [7a1a4af...2931f24](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/7a1a4afad2984fb95265ec0af061fd1e87f0b75b...2931f242aa3d305ce5642be7320620d24b3638df?src=pr)\n"},{"date":"2016-08-19T00:09:24Z","author":"davidmoten","text":"> If you'd make it more concise, that would be great. Also note that most Flowable operators have an Observable counterpart so it would be nice if such changes would contain the fix & tests for both.\n\nCan do.\n"},{"date":"2016-08-22T17:00:10Z","author":"akarnokd","text":"I was trying to avoid this class till now. Will you be able to finish what you wanted till Thursday or may I do it?\n"},{"date":"2016-08-23T00:09:40Z","author":"davidmoten","text":"@akarnokd I rebased but io.reactivex.Optional disappeared and I was using it in tests. I'll add it back in internal test package.\n"},{"date":"2016-08-23T00:11:54Z","author":"davidmoten","text":"@akarnokd the work is done for `Flowable` and I have done the work for `Observable` as well but is on my laptop at home so will finish PR tonight (in about 11 hours time).\n"},{"date":"2016-08-23T02:33:03Z","author":"davidmoten","text":"@akarnokd I'm noticing that RxJava 2.x is really slow to compile (2 minutes) in Eclipse 4.5.1 and 4.6 (say after switching branches). Have you noticed that? Got any tips?\n"},{"date":"2016-08-23T06:54:00Z","author":"akarnokd","text":"Please try without `Optional`. Yes Eclipse is slow if you change `Observable` and `Flowable`, it doesn't like the cycle between the base classes and their implementations. Not sure why, maybe collecting metadata makes is much slower.\n"},{"date":"2016-08-23T11:34:59Z","author":"davidmoten","text":"I've removed `Optional`. Would you like to assess this PR as it stands without the Observable fix that I can do in another PR? You guys are moving fast (as usual) and keeping PRs open a while is a bit of an obstacle.\n"},{"date":"2016-08-23T12:02:31Z","author":"akarnokd","text":":+1:\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-08-23T12:02:34Z","description":"Just looking at moving some recent 1.x bug fixes and tests over to 2.x.\n\nThis is my first PR in 2.x so before I proceed adding more tests from 1.x (to this PR) I want to get some feedback on my approach. In particular in the test `testCollectorFailureDoesNotResultInTwoErrorEmissions` is the `Flowable` creation method ok?\n","id":"171833480","title":"2.x collect - handle post terminal events","opened_on":"2016-08-18T07:16:59Z","closed_by":"akarnokd"},{"number":"4311","reopenOn":null,"comments":[{"date":"2016-08-08T13:19:41Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4311?src=pr) is 84.43% (diff: 100%)\n\n> Merging [#4311](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4311?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will decrease coverage by **0.06%**\n\n``` diff\n@@                1.x      #4311   diff @@\n==========================================\n  Files           268        268          \n  Lines         17476      17478     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2664       2664          \n==========================================\n- Hits          14766      14757     -9   \n- Misses         1851       1863    +12   \n+ Partials        859        858     -1   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [27c782d...970a609](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/27c782dc4536ca318ffe0b698df6e5479e8ae4e9...970a6092c39010fab65c09004c379ec8db0df10a?src=pr)\n"},{"date":"2016-08-08T13:22:35Z","author":"JakeWharton","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-08-08T13:30:49Z","description":"The `ExecutorScheduler` wrapper did not call the `RxJavaHooks.onScheduledAction()` to decorate actions sent to a custom scheduler.\n","id":"169918222","title":"1.x: Schedulers.from() to call RxJavaHooks.onScheduleAction","opened_on":"2016-08-08T13:07:06Z","closed_by":"akarnokd"},{"number":"4310","reopenOn":null,"comments":[{"date":"2016-08-08T11:31:47Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4310?src=pr) is 69.38% (diff: 94.73%)\n\n> Merging [#4310](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4310?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **<.01%**\n\n``` diff\n@@                2.x      #4310   diff @@\n==========================================\n  Files           426        426          \n  Lines         30788      30792     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       4937       4938     +1   \n==========================================\n+ Hits          21365      21366     +1   \n- Misses         7335       7338     +3   \n  Partials       2088       2088          \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [fe2445d...6422b01](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/fe2445d0009f000cb9173cd97a74c0455fed1fc1...6422b01c6f2b75893301a10691c879e596934361?src=pr)\n"},{"date":"2016-08-08T13:47:40Z","author":"JakeWharton","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-08-08T13:53:23Z","description":"This PR fixes the case when a call to request() prevented cancellation of the arbiter if the call never returned, thus locking out the drain loop from the cancellation call.\n\nThe PR makes sure `request()` is only called outside the guarded region.\n\n1.x is not affected because unsubscription and requesting go on separate \"channels\".\n\nThe PR also fixes `FlowableRedo` by serializing the repeat signal `Processor`.\n","id":"169899821","title":"2.x: fix SubscriptionArbiter reentrancy\/cancel bug","opened_on":"2016-08-08T11:19:59Z","closed_by":"akarnokd"},{"number":"4292","reopenOn":null,"comments":[{"date":"2016-08-07T01:01:17Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4292?src=pr) is 69.53% (diff: 100%)\n\n> Merging [#4292](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4292?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.04%**\n\n``` diff\n@@                2.x      #4292   diff @@\n==========================================\n  Files           419        419          \n  Lines         30755      30755          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       4935       4935          \n==========================================\n+ Hits          21372      21387    +15   \n+ Misses         7296       7282    -14   \n+ Partials       2087       2086     -1   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [6b0f1b0...28402ef](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6b0f1b05353cf0c3ef63a1b9923b77721f35227f...28402eff1b92078605e7169cf5950148cd9812e3?src=pr)\n"},{"date":"2016-08-07T01:17:18Z","author":"JakeWharton","text":"Actually I should write a test for this.\n\nOn Sat, Aug 6, 2016, 9:01 PM Codecov notifications@github.com wrote:\n\n> Current coverage https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4292?src=pr\n> is 69.42% (diff: 50.00%)\n> \n> Merging #4292 https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4292?src=pr\n> into 2.x https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr will\n> decrease coverage by _0.06%_\n> \n> # @@                2.x      #4292   diff @@\n> \n>   Files           419        419\n>   Lines         30755      30755\n>   Methods           0          0\n>   Messages          0          0\n>   Branches       4935       4935\n> ==========================================- Hits          21372      21351    -21   - Misses         7296       7318    +22   + Partials       2087       2086     -1\n> \n> Powered by Codecov https:\/\/codecov.io?src=pr. Last update\n> 6b0f1b0...55c0611\n> https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/6b0f1b05353cf0c3ef63a1b9923b77721f35227f...55c0611a679d6c978c142a8b2e5dc6a3be73f2ff?src=pr\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/4292#issuecomment-238056980,\n> or mute the thread\n> https:\/\/github.com\/notifications\/unsubscribe-auth\/AAEEEaFXsndyezWh_5TFp7g_SkLUQRndks5qdS5ggaJpZM4JeZc-\n> .\n"}],"opened_by":"JakeWharton","reopen":false,"closed_on":"2016-08-07T08:20:02Z","description":"Correct annotatoin declaration as well.\n","id":"169773591","title":"2.x: Actually apply custom scheduler when applying future.","opened_on":"2016-08-07T00:44:47Z","closed_by":"akarnokd"},{"number":"4273","reopenOn":null,"comments":[{"date":"2016-08-02T14:54:43Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4273?src=pr) is 69.68% (diff: 78.78%)\n\n> Merging [#4273](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4273?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.14%**\n\n``` diff\n@@                2.x      #4273   diff @@\n==========================================\n  Files           418        419     +1   \n  Lines         30608      30632    +24   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       4933       4935     +2   \n==========================================\n+ Hits          21283      21345    +62   \n+ Misses         7235       7201    -34   \n+ Partials       2090       2086     -4   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [9099f90...eae1d8e](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/9099f90e2281e388385663c37eeaf4b5917987ae...eae1d8ec28f0dbc66099ce2ff57924e2c5a703ec?src=pr)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-08-03T10:09:54Z","description":"- Add `rebatchRequests` which delegates to `observeOn` with the help of an internal `ImmediateThinScheduler` that only executes tasks immediately. Still not planning to expose an immediate scheduler.\n- Fix `FlowableMapNotification`'s type signature, no need to restrict it to return `Publisher<R>` but can go with `R` itself.\n- Make sure `flatMap` doesn't reorder scalars and elements of the same inner source.\n- Change parameter ordering on `mergeDelayError(Iterator)` overloads.\n","id":"168902061","title":"2.x: test sync and missing operators (8\/02)","opened_on":"2016-08-02T14:37:58Z","closed_by":"akarnokd"},{"number":"4270","reopenOn":null,"comments":[{"date":"2016-08-02T01:26:20Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4270?src=pr) is 84.43% (diff: 100%)\n\n> Merging [#4270](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4270?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.03%**\n\n``` diff\n@@                1.x      #4270   diff @@\n==========================================\n  Files           268        268          \n  Lines         17475      17474     -1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2662       2664     +2   \n==========================================\n+ Hits          14750      14755     +5   \n+ Misses         1867       1860     -7   \n- Partials        858        859     +1   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [c95c650...3b74be6](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/c95c6507e542a3082868c44c0c9ccc5f287183d6...3b74be66a31b388eb4f014fcb906039b8f0e6d2d?src=pr)\n"},{"date":"2016-08-02T07:29:12Z","author":"akarnokd","text":":+1:\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-08-02T07:29:15Z","description":"- switched to `OnSubscribe`\n- switched to use `DeferredScalarSubscriberSafe`\n- previous source failed to handle post terminal emissions \n- added 4 unit tests\n","id":"168778538","title":"toMultimap - prevent post terminal emissions, reduce allocations","opened_on":"2016-08-02T01:18:29Z","closed_by":"akarnokd"},{"number":"4268","reopenOn":"2016-08-02T07:27:54Z","comments":[{"date":"2016-08-01T10:42:27Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4268?src=pr) is 69.64% (diff: 63.35%)\n\n> Merging [#4268](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4268?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.22%**\n\n``` diff\n@@                2.x      #4268   diff @@\n==========================================\n  Files           418        418          \n  Lines         30460      30608   +148   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       4898       4933    +35   \n==========================================\n+ Hits          21144      21317   +173   \n+ Misses         7258       7217    -41   \n- Partials       2058       2074    +16   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [3f324c6...d6f49b3](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/3f324c6889b5369b79bdd3dfb8b4854b650a90be...d6f49b3808243a4e9e639745478f0a6125eb47b8?src=pr)\n"},{"date":"2016-08-01T14:42:12Z","author":"JakeWharton","text":"lgtm :+1:\n"},{"date":"2016-08-02T07:47:06Z","author":"akarnokd","text":"Thanks @JakeWharton !\n"}],"opened_by":"akarnokd","reopen":true,"closed_on":"2016-08-02T07:46:54Z","description":"- rename `finallyDo` (deprecated in 1.x) to `doAfterTerminate`\n- upgrade sized `buffer()`, fix backpressure bug\n- add post-complete helper methods\n- fix `toSingle` not complaining about an empty\/longer source\n- `RxJavaPlugins` to reset the base-type lifecycle callbacks as well\n","id":"168606046","title":"2.x: test sync and operator fixes","opened_on":"2016-08-01T09:39:12Z","closed_by":"akarnokd"},{"number":"4252","reopenOn":null,"comments":[{"date":"2016-07-28T22:18:45Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4252?src=pr) is 84.36% (diff: 100%)\n\n> Merging [#4252](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4252?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.03%**\n\n``` diff\n@@                1.x      #4252   diff @@\n==========================================\n  Files           266        267     +1   \n  Lines         17446      17460    +14   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2657       2660     +3   \n==========================================\n+ Hits          14713      14731    +18   \n+ Misses         1873       1867     -6   \n- Partials        860        862     +2   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [888560e...204f26f](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/888560edb055d297822c8e1021fe9ef224e31352...204f26f2d63585bf2bcd21ceea11d9a73b0997dc?src=pr)\n"},{"date":"2016-07-29T07:18:33Z","author":"davidmoten","text":"- Created a new class `DeferredScalarSubscriberSafe` that extends `DeferredScalarSubscriber` and offers the `done` checks. `done` is available as a protected field and `OnSubscribeCollect` uses it in its `onNext` method.\n- Replaced the calls in tests to `RxJavaHooks.setOnError(null)` with calls to `RxJavaHooks.reset()` in this PR and in recent similar PRs for operators `any`, `all` and `reduce`.\n- I'll submit another PR to fix the javadoc of `RxJavaHooks.setOnError` \n"},{"date":"2016-07-29T07:24:05Z","author":"akarnokd","text":":+1:\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-07-29T07:24:11Z","description":"As per discussion in #4242, if an operator maps an `onNext` emission to an `onError` emission downstream then it needs be defensive about another event being sent from upstream even if upstream has been unsubscribed.\n- `DeferredScalarSubscriber` has been updated with a `done` flag\n- moved tests from `ObservableTests` to new class `OnSubscribeCollectTest`\n- added three tests of post error emissions\n- added factory failure test  \n","id":"168077416","title":"collect, DeferredScalarSubscriber - prevent multiple terminal emissions","opened_on":"2016-07-28T11:51:26Z","closed_by":"akarnokd"},{"number":"4251","reopenOn":null,"comments":[{"date":"2016-07-28T07:02:54Z","author":"akarnokd","text":"I thought it supported backpressure. Could you rewrite it by using `DeferredScalarSubscription`?\n"},{"date":"2016-07-28T07:18:22Z","author":"davidmoten","text":"unrelated test failure:\n\n```\nrx.schedulers.ComputationSchedulerTests > testHandledErrorIsNotDeliveredToThreadHandler FAILED\n    java.lang.AssertionError: Handler should not have received anything expected:<0> but was:<1>\n        at org.junit.Assert.fail(Assert.java:88)\n        at org.junit.Assert.failNotEquals(Assert.java:834)\n        at org.junit.Assert.assertEquals(Assert.java:645)\n        at rx.schedulers.SchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(SchedulerTests.java:102)\n        at rx.schedulers.ComputationSchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(ComputationSchedulerTests.java:153)\n```\n"},{"date":"2016-07-28T08:00:10Z","author":"davidmoten","text":"> I thought it supported backpressure. Could you rewrite it by using DeferredScalarSubscription?\n\nSure.\n"},{"date":"2016-07-28T09:23:32Z","author":"davidmoten","text":"What I might do is fix multiple terminal emissions in  `OnSubscribeCollect` first and make necessary `done` changes to `DeferredScalarSubscriber` in that PR. I'll follow that with the backpressure fix for `OperatorToMap`.\n"},{"date":"2016-07-29T08:17:11Z","author":"davidmoten","text":"@akarnokd \n\nIn terms of releasing a value so can be gc'd I thought to modify `DeferredScalarSubscriber` in this method so that the field `this.value` is set to null just before the call to `a.onNext()`:\n\n``` java\nprotected final void complete(R value) {\n        Subscriber<? super R> a = actual;\n        for (;;) {\n            int s = state.get();\n\n            if (s == NO_REQUEST_HAS_VALUE || s == HAS_REQUEST_HAS_VALUE || a.isUnsubscribed()) {\n                return;\n            }\n            if (s == HAS_REQUEST_NO_VALUE) {\n                R v = value; \/\/ <--------------------------------\n                value = null; \/\/ <--------------------------------\n                a.onNext(v);\n                if (!a.isUnsubscribed()) {\n                    a.onCompleted();\n                }\n                state.lazySet(HAS_REQUEST_HAS_VALUE);\n                return;\n            }\n            this.value = value;\n            if (state.compareAndSet(NO_REQUEST_NO_VALUE, NO_REQUEST_HAS_VALUE)) {\n                return;\n            }\n        }\n    }\n```\n\nIs that ok?\n"},{"date":"2016-07-29T08:21:17Z","author":"davidmoten","text":"don't review latest change, just committed so could work on it from another location\n"},{"date":"2016-07-29T08:27:58Z","author":"akarnokd","text":"I'm not sure if it's worth it. Many operators don't really do that because it is also likely the whole chain gets forgotten and GC claims all of them on its own. If you want to make sure there is no leak, use `onTerminateDetach`.\n"},{"date":"2016-07-29T08:30:22Z","author":"akarnokd","text":"Could you rebase the whole thing? Somehow, you picked up changes to master and they show up in the diff.\n"},{"date":"2016-07-29T08:31:39Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4251?src=pr) is 84.39% (diff: 100%)\n\n> Merging [#4251](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4251?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.01%**\n\n``` diff\n@@                1.x      #4251   diff @@\n==========================================\n  Files           267        267          \n  Lines         17460      17460          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2660       2662     +2   \n==========================================\n+ Hits          14732      14735     +3   \n- Misses         1865       1869     +4   \n+ Partials        863        856     -7   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [0577b4c...37da430](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/0577b4c49f744ae6a49505ffeb8937e6a0730f3b...37da4301560988479160d2a40d3fbd46138d10f5?src=pr)\n"},{"date":"2016-07-29T11:19:50Z","author":"davidmoten","text":"- Rebased\n- Rewrote to use `DeferredScalarSubscriberSafe`\n- use singleton of `DefaultMapFactory`\n- moved to `OnSubscribe` to save allocations\n- added backpressure test \n"},{"date":"2016-07-29T11:24:59Z","author":"akarnokd","text":":+1:\n"},{"date":"2016-07-29T22:26:46Z","author":"davidmoten","text":"Good idea, I've updated the PR.\n"},{"date":"2016-07-30T06:57:00Z","author":"akarnokd","text":":+1:\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-07-30T06:57:04Z","description":"As per discussion in #4242, if an operator maps an `onNext` emission to an `onError` emission downstream then it needs be defensive about an `onCompleted` being sent from upstream even if upstream has been unsubscribed.\n\nIncludes three unit tests that failed on the original code. The fix also has the side effect of enabling gc of `map` when the factory fails (`onError` was called on the child, not `this` so `map` was not set to null).\n","id":"168026542","title":"toMap - prevent multiple terminal events, support backpressure","opened_on":"2016-07-28T06:58:04Z","closed_by":"akarnokd"},{"number":"4250","reopenOn":null,"comments":[{"date":"2016-07-28T03:39:49Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4250?src=pr) is 84.24% (diff: 100%)\n\n> Merging [#4250](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4250?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.02%**\n\n``` diff\n@@                1.x      #4250   diff @@\n==========================================\n  Files           266        266          \n  Lines         17426      17433     +7   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2649       2652     +3   \n==========================================\n+ Hits          14676      14686    +10   \n+ Misses         1893       1883    -10   \n- Partials        857        864     +7   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [b72beff...de52c6b](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b72befff08b935ed4652582e17ce658246c12b2c...de52c6b60da220bcd7237658fd0f2d01e90982e5?src=pr)\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-07-28T06:16:16Z","description":"As per discussion in #4242, if an operator maps an `onNext` emission to an `onError` emission downstream then it needs be defensive about an `onCompleted` being sent from upstream even if upstream has been unsubscribed.\n\nIncludes three unit tests that failed on the original code and another that gives coverage of the onBackpressureDrop action being called.\n","id":"168006690","title":"onBackpressureDrop - prevent multiple terminal events","opened_on":"2016-07-28T03:30:33Z","closed_by":"akarnokd"},{"number":"4246","reopenOn":null,"comments":[{"date":"2016-07-27T12:22:34Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4246?src=pr) is 84.30% (diff: 100%)\n\n> Merging [#4246](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4246?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.08%**\n\n``` diff\n@@                1.x      #4246   diff @@\n==========================================\n  Files           266        266          \n  Lines         17426      17434     +8   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2649       2652     +3   \n==========================================\n+ Hits          14676      14697    +21   \n+ Misses         1893       1873    -20   \n- Partials        857        864     +7   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [b72beff...586d9f7](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b72befff08b935ed4652582e17ce658246c12b2c...586d9f7b4e65afe2534e57b172158e55b077504a?src=pr)\n"},{"date":"2016-07-27T21:44:01Z","author":"davidmoten","text":"- Updated with `RxJavaHooks.onError` \n- checked `done` at start of `onNext` \n- added unit tests including coverage of calling `.reduce` on an empty stream\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-07-28T06:15:27Z","description":"As per discussion in #4242, if an operator maps an `onNext` emission to an `onError` emission downstream then it needs be defensive about an `onCompleted` being sent from upstream even if upstream has been unsubscribed.\n\nIncludes a unit test that failed on the original code.\n\nAlso renamed test class to match tested class.\n","id":"167838760","title":"OperatorReduce - prevent multiple terminal events","opened_on":"2016-07-27T12:11:52Z","closed_by":"akarnokd"},{"number":"4245","reopenOn":null,"comments":[{"date":"2016-07-27T11:55:38Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4245?src=pr) is 84.21% (diff: 100%)\n\n> Merging [#4245](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4245?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will decrease coverage by **<.01%**\n\n``` diff\n@@                1.x      #4245   diff @@\n==========================================\n  Files           266        266          \n  Lines         17426      17431     +5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2649       2651     +2   \n==========================================\n+ Hits          14676      14679     +3   \n+ Misses         1893       1890     -3   \n- Partials        857        862     +5   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [b72beff...ed8caed](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/b72befff08b935ed4652582e17ce658246c12b2c...ed8caed2c07f4b586c189d44626a55d602d3683c?src=pr)\n"},{"date":"2016-07-27T21:13:57Z","author":"davidmoten","text":"- Updated with `RxJavaHooks.onError` \n- checked `done` at start of `onNext` \n- added two unit tests for `(onNext, onNext)` and one for `(onNext, onError)` cases\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-07-28T06:14:41Z","description":"As per discussion in #4242, if an operator maps an `onNext` emission to an `onError` emission downstream then it needs be defensive about an `onCompleted` being sent from upstream even if upstream has been unsubscribed.\n\nIncludes a unit test that failed on the original code.\n","id":"167834521","title":"OperatorAny - prevent multiple terminal events","opened_on":"2016-07-27T11:45:20Z","closed_by":"akarnokd"},{"number":"4244","reopenOn":null,"comments":[{"date":"2016-07-27T20:50:32Z","author":"davidmoten","text":"- Updated with `RxJavaHooks.onError` \n- checked `done` at start of `onNext` \n- added unit tests for `(onNext, onNext)` and `(onNext, onError)` cases\n"},{"date":"2016-07-27T21:00:14Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4244?src=pr) is 84.17% (diff: 100%)\n\n> Merging [#4244](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4244?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.03%**\n\n``` diff\n@@                1.x      #4244   diff @@\n==========================================\n  Files           265        265          \n  Lines         17319      17324     +5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2627       2629     +2   \n==========================================\n+ Hits          14572      14583    +11   \n+ Misses         1893       1889     -4   \n+ Partials        854        852     -2   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [1e147fb...473eced](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/1e147fb629c76b39f795ce79791725a52187899f...473ecedd51d016e182c4e48610cd4e0596efe3a3?src=pr)\n"},{"date":"2016-07-27T21:04:44Z","author":"akarnokd","text":":+1:\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-07-27T21:05:29Z","description":"As per discussion in #4242, if an operator maps an `onNext` emission to an `onError` emission downstream then it needs be defensive about an `onCompleted` being sent from upstream even if upstream has been unsubscribed.\n\nIncludes a unit test that failed on the original code.\n","id":"167833234","title":"OperatorAll - prevent multiple terminal events","opened_on":"2016-07-27T11:36:41Z","closed_by":"akarnokd"},{"number":"4241","reopenOn":null,"comments":[{"date":"2016-07-25T19:28:12Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4241?src=pr) is 84.23% (diff: 100%)\n\n> Merging [#4241](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4241?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.02%**\n\n``` diff\n@@                1.x      #4241   diff @@\n==========================================\n  Files           265        265          \n  Lines         17313      17313          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2627       2627          \n==========================================\n+ Hits          14578      14583     +5   \n+ Misses         1885       1880     -5   \n  Partials        850        850          \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [45f6072...05ca826](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/45f607279bdd5cd67d6e342156c8408e1ef63b7f...05ca82638eec15d3cda7dbf62be5eb6d8863bb20?src=pr)\n"},{"date":"2016-07-25T20:04:11Z","author":"artem-zinnatullin","text":"👍\n"},{"date":"2016-07-25T21:09:24Z","author":"davidmoten","text":"Worth a shot, gnarly bug :+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-07-27T21:07:55Z","description":"When the function's returned Observable signals the resubscription in the operator `redo` (which is the base for `repeatWhen` and `retryWhen`). It is possible an asyncronous source triggers the function (and thus the same `Observable`) from another thread while the first is still coming back from the resubscription itself.\n\nThis PR serializes the dispatching `BehaviorSubject` to prevent such concurrent execution of the when chain.\n\nThis may or may not be the source of the failure of #4175 but I can't reproduce the failure with the 1.x branch. \/cc @davidmoten.\n","id":"167442331","title":"Fix retryWhen\/repeatWhen potential concurrent reentry when resubscribing","opened_on":"2016-07-25T19:10:33Z","closed_by":"akarnokd"},{"number":"4231","reopenOn":null,"comments":[{"date":"2016-07-23T08:37:54Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4231?src=pr) is 84.14% (diff: 100%)\n\n> Merging [#4231](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4231?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will decrease coverage by **0.14%**\n\n``` diff\n@@                1.x      #4231   diff @@\n==========================================\n  Files           265        265          \n  Lines         17314      17316     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2627       2627          \n==========================================\n- Hits          14595      14571    -24   \n- Misses         1875       1890    +15   \n- Partials        844        855    +11   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [2284d4f...6afe4e7](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/2284d4ffad2c063e9478b7b685b350fc2c0d49a3...6afe4e7fb002b4f47f1c58137487cb3b718bda43?src=pr)\n"},{"date":"2016-07-23T11:16:56Z","author":"akarnokd","text":":+1: \n\nGiven a misbehaving task, this at least prevents other work to be scheduled on the same pool.\n"}],"opened_by":"csabakos","reopen":false,"closed_on":"2016-07-23T12:24:03Z","description":"\u2026completes before releasing a worker to the pool. Fixes #4230.\n","id":"167174679","title":"CachedThreadScheduler should wait until the previous action (if any) \u2026","opened_on":"2016-07-23T08:28:39Z","closed_by":"akarnokd"},{"number":"4230","reopenOn":null,"comments":[{"date":"2016-07-23T10:01:58Z","author":"akarnokd","text":"Could you give an example of such non-interruptible blocking tasks?\n"},{"date":"2016-07-23T11:04:31Z","author":"csabakos","text":"@akarnokd A concrete example is in the test case that I added in #4231, but in general any task that is carelessly written (swallows `InterruptedException`, or busy looping, etc.) will trigger this issue. \n\nExample:\n\n```\nint numClients = 0;\nfor (Server s : servers) {\n    try {\n        numClients += s.queryNumClients();\n    } catch (Exception e) {\n        \/\/ Assume 0 clients\n    }\n}\nreturn numClients;\n```\n\nThe `InterruptedException` caused by `unsubscribe()` is swallowed and if the next `s.queryNumClients()` blocks for minutes, then this will block the thread for minutes.\n\nWhat's worse is that this may even come from 3rd party code that also uses `Schedulers.io()` and cause extremely hard to debug problems.\n"},{"date":"2016-07-23T11:14:45Z","author":"akarnokd","text":"I see. I'd consider the fix in #4231 as a temporary workaround because such tasks will keep blocking out threads (and leak resources). Generally, this is what `newThread()` is handy for: you get a new thread that can be blocked without the fear of reuse. Send such untrustwothy tasks to newThread() and the rest to io().\n"},{"date":"2016-07-23T12:16:57Z","author":"csabakos","text":"Absolutely, #4231 only prevents other tasks from being blocked by the misbehaving task, it does't prevent the thread (and potentially other resource) leaks.\n\nI believe the thread leak would be present with `newThread()` as well and there is not much we can do about this. There is `Thread.stop()` but it introduces more problems than it solves. Hopefully the misbehaving task will complete eventually and at that point the resources will be freed up. If it never completes then it's a lost thread and the resources are leaked permanently.\n"},{"date":"2016-08-18T01:21:57Z","author":"Armaxis","text":"I happened to face this bug today, was using RxJava 1.1.2. After half an hour of debugging went to check for newer version, and guess what - first bug fix in release notes is exactly the one I was fighting. Pulled latest, everything works like a charm. Thank you guys!\n"}],"opened_by":"csabakos","reopen":false,"closed_on":"2016-07-23T12:24:03Z","description":"Some actions are not interruptible. Since Schedulers.io() reuses threads after unsubscribe, a previous uninterruptible action might block execution of new actions, causing unexpected delays or in some cases, deadlocks.\n","id":"167174506","title":"Schedulers.io() reuses blocked threads","opened_on":"2016-07-23T08:22:17Z","closed_by":"akarnokd"},{"number":"4229","reopenOn":null,"comments":[{"date":"2016-07-22T18:49:40Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4229?src=pr) is 84.20% (diff: 61.53%)\n\n> Merging [#4229](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4229?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.07%**\n\n``` diff\n@@                1.x      #4229   diff @@\n==========================================\n  Files           265        265          \n  Lines         17305      17314     +9   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2624       2627     +3   \n==========================================\n+ Hits          14559      14579    +20   \n+ Misses         1893       1884     -9   \n+ Partials        853        851     -2   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last update [479df31...0101c36](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/479df3195f208888fe8cfc91c9ce8367c5b4cc07...0101c36a13ff32711115d11abd1796206e07ae49?src=pr)\n"},{"date":"2016-07-22T19:38:39Z","author":"akarnokd","text":"This is a medium impact bug so it would be great if it made into tomorrow's release. \/cc @artem-zinnatullin @zsxwing \n"},{"date":"2016-07-22T23:37:51Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-07-23T07:14:43Z","description":"In #3470, a flat cache of Subscribers has been introduced that is versioned and gets only updated if there are new Subscribers coming, old Subscribers leaving _and_ a value comes through - improving performance if lots of Subscribers come and go between main onNext signals. This cache is not cleared but rebuilt therefore child Subscribers unsubscribing were still referenced through it and everything beyond - leading to memory leak on sensitive systems.\n\nThe fix is to cut the link to the child Subscriber in `InnerProducer` on unsubscription. A secondary action also empties the cache if all Subscribers are gone.\n\nReported in #4228 .\n","id":"167106599","title":"1.x: fix replay() retaining reference to the child Subscriber","opened_on":"2016-07-22T18:39:50Z","closed_by":"akarnokd"},{"number":"4228","reopenOn":null,"comments":[{"date":"2016-07-22T17:40:59Z","author":"akarnokd","text":"Do you have your replay in a completed state or with infrequent updates?\n"},{"date":"2016-07-22T17:58:45Z","author":"ntoskrnl","text":"Infinite stream is \"replayed\", so, I guess, it is never in a completed state. \nWhat do you mean by infrequent updates?\n"},{"date":"2016-07-22T18:35:05Z","author":"ntoskrnl","text":"Connectable observable with replay example (no error handling to keep it simple): \n\n``` kotlin\nval dataStream = refreshes.startWith(Unit)\n        .flatMap { model.getData() }\n        .replay(1)\n```\n\nWhen presenter is created we connect to the stream and store subscription until presenter is destroyed:\n\n``` kotlin\nval presenterSubscription = CompositeSubscription()\nval viewSubscription = CompositeSubscription()\n\npresenterSubscription.add(dataStream.connect())\n```\n\nView is attached to presenter:\n\n``` kotlin\n\/\/ subscribe view to the data stream, subscriber has a strong reference to view\nviewSubscription.add(dataStream.subscribe {  view.showContent(it) })\n```\n\nView detached from presenter:\n\n``` kotlin\n\/\/ clear view subscription\n\/\/ after this there should be no strong references to the view\nviewSubscription.clear()\n```\n\nWhen presenter is destroyed (when activity is closed): \n\n``` kotlin\npresenterSubscription.unsubscribe()\n```\n\nThroughout the presenter lifecycle, different instances of view are attached and then detached (for instance, during screen rotation when Activity is recreated). However, after the new view instance is attached, the old instance is still referenced from within OperatorReplay. According to heap dump analysis, each time there exist only two instances of the view \u2013 no matter how I many times I rotate the screen, there are two instances of view: current and only 1 leaked view.\n"},{"date":"2016-07-22T18:42:15Z","author":"ntoskrnl","text":" 👍 \n"},{"date":"2016-07-22T18:42:33Z","author":"akarnokd","text":"Thanks for the report. This is a bug in `replay()`'s internal cache of `Subscriber`s. I've posted a PR #4229 with the fix. A temporary workaround is to use `onTerminateDetach` on the `ConnectableObservable` the `replay()` returns and subscribe through it. \n"},{"date":"2016-07-23T07:15:34Z","author":"akarnokd","text":"Fixed via #4229.\n"}],"opened_by":"ntoskrnl","reopen":false,"closed_on":"2016-07-23T07:15:42Z","description":"We use `replay(1)` a lot in our Android projects. All subscriptions are kept in `CompositeSubscription` and, of course, we always clear it when we don't need it anymore.\n\nEven though we unsubscribe from observable, subscriber won't get collected by GC, because it is referenced by `OperatorReplay`, which prevents Activity or Fragment from being garbage collected. We do need to keep observable alive and resubscribe to it from new Activity instance, but now we can't use replay() as all our Activities are leaked.\n\nRight now we downgraded back to 1.1.5. Alternatively, one can use `publish()` with behavior subject to work around this issue. I believe the issue was introduced in one of the latest versions of the library (perhaps 1.1.6, not sure though).\n","id":"167093308","title":"OperatorReplay leaks its subscribers","opened_on":"2016-07-22T17:26:10Z","closed_by":"akarnokd"},{"number":"4222","reopenOn":null,"comments":[{"date":"2016-07-21T08:32:24Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4222?src=pr) is **68.55%**\n\n> Merging [#4222](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4222?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **<.01%**\n\n``` diff\n@@                2.x      #4222   diff @@\n==========================================\n  Files           411        411          \n  Lines         29486      29490     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       4777       4779     +2   \n==========================================\n+ Hits          20212      20216     +4   \n+ Misses         7252       7251     -1   \n- Partials       2022       2023     +1   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last updated by [4577f1a...d896729](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/4577f1abc585611f83be86efd279c4d135acd0ab...d896729ed17055bf43f0940bf29dca4c000b28e3?src=pr)\n"},{"date":"2016-07-21T12:08:33Z","author":"artem-zinnatullin","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-07-22T08:24:55Z","description":"This PR fixes the `subscribeOn` operator to allow cancellation before the actual subscription to the source takes place - just like how 1.x works.\n","id":"166761884","title":"2.x: subscribeOn allow cancelling before the actual subscription happens (just like 1.x)","opened_on":"2016-07-21T08:14:38Z","closed_by":"akarnokd"},{"number":"4215","reopenOn":"2016-07-20T21:04:40Z","comments":[{"date":"2016-07-19T13:52:01Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4215?src=pr) is **84.27%**\n\n> Merging [#4215](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4215?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.02%**\n\n``` diff\n@@                1.x      #4215   diff @@\n==========================================\n  Files           265        265          \n  Lines         17281      17305    +24   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2617       2624     +7   \n==========================================\n+ Hits          14558      14583    +25   \n+ Misses         1881       1873     -8   \n- Partials        842        849     +7   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last updated by [65c7070...4853282](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/65c7070c2dae6b27cafb2c37f50b884478ba3949...485328223e8de398edda21317ba20c0b1fd2c31c?src=pr)\n"},{"date":"2016-07-19T17:10:35Z","author":"stevegury","text":"👍 \n"},{"date":"2016-07-20T20:56:11Z","author":"artem-zinnatullin","text":"👍 \n"}],"opened_by":"akarnokd","reopen":true,"closed_on":"2016-07-20T21:17:11Z","description":"Modify the assembly tracking logic to not replace the exception flowing through but to attach the tracking exception to the end of the causal chain (if possible).\n\nFixes #4212\n","id":"166326526","title":"1.x: fix assembly tracking replacing original exception","opened_on":"2016-07-19T13:07:01Z","closed_by":"akarnokd"},{"number":"4212","reopenOn":null,"comments":[{"date":"2016-07-19T11:16:13Z","author":"akarnokd","text":"Yeah, in [Java 8](https:\/\/github.com\/reactor\/reactive-streams-commons\/blob\/master\/src\/main\/java\/rsc\/publisher\/PublisherOnAssembly.java#L140) I simply add it as a suppressed exception. In Java 8, you have to find an unused slot of cause in a potentially complicated graph of exceptions and composites.\n"},{"date":"2016-10-20T17:02:41Z","author":"pyricau","text":"This change likely caused #4737\n"}],"opened_by":"artem-zinnatullin","reopen":false,"closed_on":"2016-07-20T21:17:11Z","description":"Problem:\n\nIf user enables assembly tracking then **ALL** exceptions get wrapped into `AssemblyStackTraceException` which breaks all error handling code that expects particular exceptions.\n\nSolution:\n\nDo not change type of original exception and modify its stacktrace directly. I'll work on that soon, both for 1.x and 2.x.\n\n\/\/ Spent an hour today trying to figure out what was causing app misbehave, glad we have `git bisect`, was very surprised to see commit where I enabled assembly tracking\u2026\n","id":"166305576","title":"RxJavaHooks.enableAssemblyTracking() breaks error handling","opened_on":"2016-07-19T11:10:20Z","closed_by":"akarnokd"},{"number":"4209","reopenOn":null,"comments":[{"date":"2016-07-18T07:51:22Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4209?src=pr) is **84.31%**\n\n> Merging [#4209](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4209?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.07%**\n\n``` diff\n@@                1.x      #4209   diff @@\n==========================================\n  Files           265        265          \n  Lines         17281      17291    +10   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2617       2619     +2   \n==========================================\n+ Hits          14558      14579    +21   \n+ Misses         1881       1869    -12   \n- Partials        842        843     +1   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last updated by [65c7070...95daa74](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/65c7070c2dae6b27cafb2c37f50b884478ba3949...95daa741dd56ec24ce6a4ee4ada08b5b0d2133c3?src=pr)\n"},{"date":"2016-07-19T10:34:44Z","author":"davidmoten","text":"Thanks @akarnokd for quick fix. I haven't reviewed yet but I'm keen to see the issue resolved in a release soon (I also was suprised `flatMap` didn't honour individual observable order). \n"},{"date":"2016-07-20T20:33:38Z","author":"davidmoten","text":"reviewed :+1: \n"},{"date":"2016-07-20T20:54:46Z","author":"akarnokd","text":"Updated, thanks @davidmoten !\n"},{"date":"2016-07-20T20:57:53Z","author":"artem-zinnatullin","text":"👍 \n"},{"date":"2016-07-20T20:58:24Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-07-20T21:04:10Z","description":"This PR changes flatmap to make sure there is no element reordering happening on the fast-paths.\n\nRelated: #4206.\n","id":"166035854","title":"1.x: merge\/flatMap to keep scalar\/inner element relative order","opened_on":"2016-07-18T07:40:29Z","closed_by":"akarnokd"},{"number":"4165","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-07-05T08:52:50Z","description":"This was due to bad rewrite of field updater to atomic reference.\n","id":"163794948","title":"2.x: fix wrong reference check in FlattenIterable","opened_on":"2016-07-05T08:16:19Z","closed_by":"akarnokd"},{"number":"4142","reopenOn":null,"comments":[{"date":"2016-06-28T11:33:38Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4142?src=pr) is **81.47%**\n\n> Merging [#4142](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4142?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.23%**\n\n``` diff\n@@                1.x      #4142   diff @@\n==========================================\n  Files           257        257          \n  Lines         16811      16823    +12   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2547       2550     +3   \n==========================================\n+ Hits          13658      13707    +49   \n+ Misses         2247       2218    -29   \n+ Partials        906        898     -8   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last updated by [d66d931...6d5473a](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/d66d9313d8580b56a53b28dba32fb1ccacd606b6...6d5473aaad6f06c3707acbd6ae8f776731503012)\n"},{"date":"2016-06-28T20:06:26Z","author":"akarnokd","text":"Updated.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-06-29T12:47:28Z","description":"This PR adds unit tests for the new `RxJavaHooks` facility and fixes\n- Small mistakes in calling the right hook.\n- Dealing with constant `Completable` sources such as `complete()` and `never()`: they executed the hook on class initialization so they couldn't be properly overridden later via an `onCreate` hook. (This could affect the other constants and will be addressed separately.)\n","id":"162660947","title":"1.x: add RxJavaHooks tests, fix small bugs","opened_on":"2016-06-28T11:14:16Z","closed_by":"akarnokd"},{"number":"4107","reopenOn":null,"comments":[{"date":"2016-06-24T19:04:38Z","author":"JakeWharton","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-06-24T20:31:21Z","description":"The original behavior was somewhat inconsistent: if the target was null before the cancel\/dispose, the method didn't return true indicating a successful swap for the current thread. Now that many `cancelled` flag has been removed, it has to consistently trigger the remaining cleanup actions.\n","id":"162210310","title":"2.x: make sure the helper returns true if the pre-swap value was null","opened_on":"2016-06-24T19:02:58Z","closed_by":"akarnokd"},{"number":"4082","reopenOn":null,"comments":[{"date":"2016-06-23T06:53:40Z","author":"akarnokd","text":"Yes, we should avoid these.\n"},{"date":"2016-07-12T11:17:33Z","author":"akarnokd","text":"I'd like to resolve this; could you point me to the problematic classes and what exactly is leaking?\n"},{"date":"2016-07-12T13:26:19Z","author":"JakeWharton","text":"It's the `createDisposable` methods in `Subscribers` and `Observers` which return `DisposableSubscriber` and `DisposableObserver`.\n"},{"date":"2016-08-10T17:02:33Z","author":"akarnokd","text":"See #4337.\n"},{"date":"2016-08-16T08:45:16Z","author":"akarnokd","text":"I think this has been resolved. Let me know if you find something else (or post a fix PR).\n"}],"opened_by":"JakeWharton","reopen":false,"closed_on":"2016-08-16T08:45:16Z","description":"All of the methods doing this are at present unused. If they're for public consumption we need `DisposableSubscriber` and `NbpDisposableSubscriber` (or equivalent) to be in a public package.\n","id":"161837977","title":"2.x: Subscribers, Observables classes leak internal types into the public API","opened_on":"2016-06-23T04:30:40Z","closed_by":"akarnokd"},{"number":"4072","reopenOn":null,"comments":[{"date":"2016-06-22T16:06:04Z","author":"artem-zinnatullin","text":"👍 \n"},{"date":"2016-06-22T16:18:58Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4072?src=pr) is **69.82%**\n\n> Merging [#4072](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4072?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will decrease coverage by **0.03%**\n\n``` diff\n@@                2.x      #4072   diff @@\n==========================================\n  Files           384        384          \n  Lines         27143      27143          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       4354       4354          \n==========================================\n- Hits          18963      18953    -10   \n- Misses         6255       6271    +16   \n+ Partials       1925       1919     -6   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last updated by [4925f6d...455e27e](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/4925f6d601fc093c4f9031e2d7ce673c00af2512...455e27ec11379ccc112fdb6f47aedb3528996ea6)\n"},{"date":"2016-06-22T16:19:49Z","author":"akarnokd","text":":+1:\n"}],"opened_by":"JakeWharton","reopen":false,"closed_on":"2016-06-22T16:19:54Z","description":"This returns false 100% of the time otherwise.\n","id":"161721681","title":"2.x: Dereference atomic ref before identity comparison.","opened_on":"2016-06-22T16:00:01Z","closed_by":"akarnokd"},{"number":"4058","reopenOn":null,"comments":[{"date":"2016-06-22T07:04:06Z","author":"JakeWharton","text":"There's some actual bug fixes in here too. More than once an AtomicReference was being compared against a Disposable\/Subscription using identity without calling get().\n"},{"date":"2016-06-22T07:04:28Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4058?src=pr) is **69.70%**\n\n> Merging [#4058](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4058?src=pr) into [2.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/2.x?src=pr) will increase coverage by **0.13%**\n\n``` diff\n@@                2.x      #4058   diff @@\n==========================================\n  Files           385        384     -1   \n  Lines         27571      27148   -423   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       4476       4355   -121   \n==========================================\n- Hits          19182      18924   -258   \n+ Misses         6388       6293    -95   \n+ Partials       2001       1931    -70   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last updated by [287286e...fa6d9e4](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/287286e39fcdda7198d91b38184203537e794a9b...fa6d9e4529f8d824c710410f3a1a5924f82fd5e6)\n"},{"date":"2016-06-22T07:13:27Z","author":"JakeWharton","text":"Maybe I made that up. I can't see them now. It's late...\n"},{"date":"2016-06-22T07:19:34Z","author":"akarnokd","text":":+1: Thanks for this heroic work!\n"}],"opened_by":"JakeWharton","reopen":false,"closed_on":"2016-06-22T07:19:38Z","description":"A lot of operators contained their own marker instance and class definition of Disposable or Subscription. This changes almost all of them to use the shared instance provided by their respective helper class. Some duplication still exists but can be cleaned up in a subsequent change.\n","id":"161605925","title":"Use DisposableHelper and SubscriptionHelper to reduce duplication.","opened_on":"2016-06-22T06:48:10Z","closed_by":"akarnokd"},{"number":"4051","reopenOn":null,"comments":[{"date":"2016-06-21T16:22:56Z","author":"codecov-io","text":"## [Current coverage](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4051?src=pr) is **80.49%**\n\n> Merging [#4051](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/pull\/4051?src=pr) into [1.x](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/branch\/1.x?src=pr) will increase coverage by **0.11%**\n\n``` diff\n@@                1.x      #4051   diff @@\n==========================================\n  Files           253        253          \n  Lines         16478      16469     -9   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       2500       2491     -9   \n==========================================\n+ Hits          13244      13256    +12   \n+ Misses         2341       2331    -10   \n+ Partials        893        882    -11   \n```\n\n> Powered by [Codecov](https:\/\/codecov.io?src=pr). Last updated by [535fb75...788f3bd](https:\/\/codecov.io\/gh\/ReactiveX\/RxJava\/compare\/535fb75901bda3ba26edf5c79b0cbfef7a05580b...788f3bd94a7756187ec32a870b6900d6c784454f)\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-06-22T07:43:40Z","description":"Adding the backpressure support to `ReplaySubject` exposed a race condition around the `caughtUp` optimization.\n\nThe problem occurs when the source thread has caught up after `drain()` returned true but at the same time, a concurrent `drain()` starts running (due to a subscribe() process finishing or requesting on top of the previous `Long.MAX_VALUE`). This concurrent drain may think the replay hasn't started yet (by finding `rp.node` null) or seeing that the buffer has more elements (that may get double emitted).\n\nThe current solution is to remove this optimization until we come up with a correct optimization.\n\nRelated: #4028.\n","id":"161478644","title":"1.x: fix ReplaySubject anomaly around caughtUp by removing that optimization","opened_on":"2016-06-21T16:11:46Z","closed_by":"akarnokd"},{"number":"4027","reopenOn":null,"comments":[{"date":"2016-06-18T07:41:28Z","author":"vanniktech","text":":+1:\n"},{"date":"2016-06-18T14:53:13Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-06-18T15:21:06Z","description":"The catch around the predicate didn't actually signal the CompositeException.\n\nDiscovered in #4025\n","id":"160980877","title":"1.x: fix Completable.onErrorComplete(Func1) not relaying function crash","opened_on":"2016-06-17T21:46:19Z","closed_by":"akarnokd"},{"number":"4025","reopenOn":null,"comments":[{"date":"2016-06-17T21:34:55Z","author":"akarnokd","text":"Good catch!\n"},{"date":"2016-06-17T21:46:33Z","author":"akarnokd","text":"See #4027.\n"},{"date":"2016-06-18T15:21:26Z","author":"akarnokd","text":"Closing via #4027\n"}],"opened_by":"vanniktech","reopen":false,"closed_on":"2016-06-18T15:21:26Z","description":"I was just browsing some of the source code to get a better understanding and I stumbled upon [https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/Completable.java#L1666](this line). Isn't there a call to `s.onError(e)` missing?\n","id":"160975941","title":"Question about onError propagation in Completable#onErrorComplete","opened_on":"2016-06-17T21:13:08Z","closed_by":"akarnokd"},{"number":"4023","reopenOn":null,"comments":[{"date":"2016-06-20T16:56:59Z","author":"stevegury","text":"👍 \nWe should mention this change in the next changelog.\n"},{"date":"2016-06-21T08:03:10Z","author":"akarnokd","text":"Definitely. \n\n@zsxwing Thoughts?\n"},{"date":"2016-06-22T20:30:08Z","author":"zsxwing","text":":+1: Agreed that this is a bug fix instead of a broken change.\n"},{"date":"2016-06-22T20:31:00Z","author":"akarnokd","text":"Thanks @zsxwing !\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-06-22T07:44:08Z","description":"In the current master, `replay` only trucates its buffer if an event is received. This means if a subscriber subscribes between two events, the operator may replay old events. This PR skips those events. The operator is now consistent with the recently updated `ReplaySubject`.\n\nThe old behavior was somewhat expected by a few unit tests that have been updated.\n\nRelated: #3917, #3918. \n","id":"160966806","title":"1.x: fix timed replay() replaying old data for late subscribers","opened_on":"2016-06-17T20:17:12Z","closed_by":"akarnokd"},{"number":"4005","reopenOn":null,"comments":[{"date":"2016-06-13T12:08:31Z","author":"artem-zinnatullin","text":"👍 \n"},{"date":"2016-06-15T18:19:55Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-06-15T18:21:27Z","description":"In the spsc queues, the indexes were written before the actual elements and thus a concurrent `isEmpty` check would report a non-empty queue but a `poll` would still return `null`. The fix swaps the two writes.\n\nNote that this an inconsistency in the original JCTools code and not the lack of keeping up with it.\n","id":"159923425","title":"1.x: fix Spsc queues reporting not empty but then poll() returns null","opened_on":"2016-06-13T10:55:47Z","closed_by":"akarnokd"},{"number":"4004","reopenOn":null,"comments":[{"date":"2016-06-13T07:22:52Z","author":"akarnokd","text":"This appears to be a bug with the JCTools queue. The fix is simply swap two operations in 3 places, but before I post the fix, I'll sort this out with JCTools.\n"},{"date":"2016-06-13T10:56:18Z","author":"akarnokd","text":"Fix in #4005.\n"},{"date":"2016-06-17T08:01:21Z","author":"akarnokd","text":"Fix delivered in 1.1.6. Thanks!\n"}],"opened_by":"artem-zinnatullin","reopen":false,"closed_on":"2016-06-17T08:01:21Z","description":"Reported from app version with RxJava 1.1.3, but `OperatorSwitch` was not changed since 1.1.3 so it still looks actual.\n\n``` java\nCaused by java.lang.NullPointerException\nrx.internal.operators.OperatorSwitch$SwitchSubscriber.drain (OperatorSwitch.java:316)\nrx.internal.operators.OperatorSwitch$SwitchSubscriber.childRequested (OperatorSwitch.java:266)\nrx.internal.operators.OperatorSwitch$SwitchSubscriber$2.request (OperatorSwitch.java:124)\nrx.Subscriber.request (Subscriber.java:157)\nrx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call (OperatorObserveOn.java:220)\nrx.internal.schedulers.ScheduledAction.run (ScheduledAction.java:55)\n```\n\nOn the line: [`if (localIndex.get() == inner.id) {`](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/v1.1.3\/src\/main\/java\/rx\/internal\/operators\/OperatorSwitch.java#L316)\n\n`localIndex` is `final`, so looks like `inner` is null.\n\n\/\/ JFYI it was on Samsung with Android 6.0.1.\n","id":"159883215","title":"1.x: NullPointerException in OperatorSwitch","opened_on":"2016-06-13T06:48:26Z","closed_by":"akarnokd"},{"number":"3996","reopenOn":null,"comments":[{"date":"2016-06-07T08:27:38Z","author":"hzsweers","text":"Minor nit, rest of the code looks good 👍 \n\nNice catch, sorry for the inadvertent bug and glad it was a relatively simple fix\n"},{"date":"2016-06-07T08:33:37Z","author":"artem-zinnatullin","text":"👍 \n"},{"date":"2016-06-07T22:50:22Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-06-07T23:06:52Z","description":"The reset shut down all the main schedulers and the helper pools, causing the failure in #3993 .\n\n@hzsweers, you were right with the need for the instance-shutdown method.\n","id":"158864782","title":"1.x: fix reset() shutting down everything other than the schedulers","opened_on":"2016-06-07T08:17:28Z","closed_by":"akarnokd"},{"number":"3977","reopenOn":null,"comments":[{"date":"2016-06-01T07:32:35Z","author":"akarnokd","text":":+1:\n"},{"date":"2016-06-01T23:17:26Z","author":"stevegury","text":"👍 \n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2016-06-01T23:17:38Z","description":"The cause of #3679 is we use a wrong Throwable (its cause has been set) to set the cause and `initCause` will throw an exception. Hence, the cause chain is not created correctly. In this PR, it searches the root cause (which doesn't have a cause) and use it to call `initCause`.\n","id":"157814970","title":"1.x: Use the correct Throwable to set the cause for CompositeException","opened_on":"2016-06-01T03:15:53Z","closed_by":"stevegury"},{"number":"3969","reopenOn":null,"comments":[{"date":"2016-05-27T21:50:15Z","author":"akarnokd","text":"Long running, unrelated tests fail on travis for hours now.\n"},{"date":"2016-05-30T05:58:12Z","author":"zsxwing","text":"Not sure if this is worth to fix (Hundreds of codes to fix a rare case). For merging tons of Observable, I would expect that the user uses the static array version instead of writing a for-loop. In addition, this won't fix this issue totally. E.g., people can add an operator like this and will still get StackOverflowError.\n\n```\n        Observable<Integer> source = Observable.just(1);\n        Observable<Integer> result = source;\n\n        for (int i = 0; i < n; i++) {\n            result = result.mergeWith(source).map(x -> x + 1);\n        }\n```\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-05-31T08:15:30Z","description":"This PR fixes the case when operators of pattern `xWith` chained into a long sequence causes `StackOverflowError` because the subscription call-stack gets deep.\n\nOperators affected and fixes:\n- `Observable.ambWith()`\n- `Observable.mergeWith()`\n- `Observable.concatWith()`\n- `Observable.startWith()`\n- `Observable.zipWith()`\n- `Completable.ambWith()`\n- `Completable.mergeWith()`\n- `Completable.concatWith()`\n- `Completable.startWith()`\n- `Single.zipWith()`\n\nThe PR contains some tidy-up of existing functionality and introducing short operators that delegate to the \"big\" operators for the purpose of identification.\n","id":"157193456","title":"1.x fix long-chained xWith() operator stack overflow","opened_on":"2016-05-27T12:13:43Z","closed_by":"akarnokd"},{"number":"3963","reopenOn":null,"comments":[{"date":"2016-05-25T20:07:36Z","author":"akarnokd","text":"Please add an unit test that shows verifies the expected behavior.\n"},{"date":"2016-05-25T21:02:48Z","author":"premnirmal","text":"Updated\n"},{"date":"2016-06-01T03:17:06Z","author":"zsxwing","text":"@premnirmal This is not correct. I just sent #3977 to fix it. Thanks anyway!\n"},{"date":"2016-06-01T07:35:09Z","author":"akarnokd","text":"Thanks for the contribution. Could you check #3977 and verify it fixes your issue?\n"},{"date":"2016-06-01T13:46:58Z","author":"premnirmal","text":"Thanks @zsxwing , closing\n"}],"opened_by":"premnirmal","reopen":false,"closed_on":"2016-06-01T13:46:58Z","description":"Fixes https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3679 \n","id":"156836118","title":"Composite exception should update cause to match the correct throwable that's first in the chain","opened_on":"2016-05-25T19:54:19Z","closed_by":"premnirmal"},{"number":"3958","reopenOn":null,"comments":[{"date":"2016-05-21T13:21:20Z","author":"akarnokd","text":"Updated javadoc and test.\n"},{"date":"2016-05-21T13:55:09Z","author":"artem-zinnatullin","text":":+1:\n"},{"date":"2016-05-23T21:49:46Z","author":"hzsweers","text":"👍 \n"},{"date":"2016-05-23T23:14:42Z","author":"zsxwing","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-05-23T23:15:32Z","description":"This PR adds the call to `RxJavaObservableExecutionHook.onCreate()` to the `just()` - `ScalarSynchronousObservable` construction.\n\nRelated: #2656.\n","id":"156091871","title":"1.x: just() construction to call the onCreate execution hook","opened_on":"2016-05-21T08:55:34Z","closed_by":"zsxwing"},{"number":"3941","reopenOn":null,"comments":[{"date":"2016-05-16T15:43:26Z","author":"artem-zinnatullin","text":"👍 \n"},{"date":"2016-05-17T19:57:21Z","author":"zsxwing","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-05-17T19:57:36Z","description":"See #3940.\n","id":"154839593","title":"1.x: fix Single.flatMap not composing subscription through","opened_on":"2016-05-14T07:30:11Z","closed_by":"zsxwing"},{"number":"3940","reopenOn":null,"comments":[{"date":"2016-05-14T07:31:13Z","author":"akarnokd","text":"Thanks for reporting. Indeed, this is a bug in `Single.flatMap`. Fix PR in #3941 .\n"}],"opened_by":"RoryKelly","reopen":false,"closed_on":"2016-05-17T19:57:50Z","description":"Not sure this is a correct test, let me know if I can provide any extra information.\n\n```\n    private Subscriber<? super Object> subscriber;\n\n    @Test public void thisTestPasses() throws Exception {\n\n        final Subscription subscribe = Observable.create(subscriber -> {\n            this.subscriber = subscriber;\n        }).subscribeOn(Schedulers.io()).flatMap(o -> Observable.just(\"\")).toSingle().subscribe();\n\n        subscribe.unsubscribe();\n\n        assertThat(subscriber.isUnsubscribed()).isTrue();\n    }\n\n    @Test public void thisTestFails() throws Exception {\n\n        final Subscription subscribe = Observable.create(subscriber -> {\n            this.subscriber = subscriber;\n        }).subscribeOn(Schedulers.io()).toSingle().flatMap(o -> Single.just(\"\")).subscribe();\n\n        subscribe.unsubscribe();\n\n        assertThat(subscriber.isUnsubscribed()).isTrue();\n    }\n```\n","id":"154811546","title":"toSingle() leaks subscriber if followed by flatmap.","opened_on":"2016-05-13T22:21:46Z","closed_by":"zsxwing"},{"number":"3924","reopenOn":null,"comments":[{"date":"2016-05-10T17:30:36Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-05-10T19:51:02Z","description":"This PR fixed the `ObjectPool` dependency on the `Schedulers.computation()` which can be replaced via plugin hooks causing unexpected and long sleeps (i.e., when `computation()` is replaced by `immediate()`).\n\nSee #3923.\n\nI'd also consider removing the `RxRingBuffer` entirely.\n","id":"153869015","title":"1.x: fix RxRingBuffer-pool depending on the computation scheduler","opened_on":"2016-05-09T21:01:40Z","closed_by":"akarnokd"},{"number":"3923","reopenOn":null,"comments":[{"date":"2016-05-09T20:15:43Z","author":"jnlopar","text":"Btw, I can write the PR for this once a decision is made, but I thought it deserved a little discussion of what the right fix is before I jump to an implementation.\n"},{"date":"2016-05-09T20:23:47Z","author":"JakeWharton","text":"This came up recently in another forum to the same effect but I never followed up here. But :+1: to something that doesn't pass through user code in such a dangerous way.\n"},{"date":"2016-05-09T20:33:05Z","author":"akarnokd","text":"Yep, they have a cyclic dependency. I believe the `ObjectPool`s can be switched to `GenericScheduledExecutorService`. Let me write up a PR.\n"},{"date":"2016-05-09T21:02:14Z","author":"akarnokd","text":"See #3924.\n"},{"date":"2016-05-10T20:50:01Z","author":"akarnokd","text":"Fix merged in #3924.\n"}],"opened_by":"jnlopar","reopen":false,"closed_on":"2016-05-10T20:50:01Z","description":"I just helped debug an issue where some Android robolectric tests timed out after upgrading from 1.1.1 to 1.1.5 due to https:\/\/github.com\/ReactiveX\/RxJava\/commit\/ef1d418f43e55eafb1cf9f09d13f37afb5b80b84\n\nAs it turned out, they were replacing the computation scheduler with immediate via RxJavaPlugins. The new commit caused RxRingBuffer.SIZE to load the RxRingBuffer class in any call to observeOn, which in turn created its ObjectPools, which in turn ran their start() which sets up a periodic scheduling on the computation thread. This caused the tests to hang indefinitely because of the repeated SleepingActions triggered by the validation tasks.\n\nSo, since RxRingBuffer can be loaded in various places by Rx internally, that seems to make it a lot more difficult to reliably replace the computation scheduler, particularly with immediate. I recommended against the immediate override in this case, but using a test scheduler wasn't really helping in this scenario either, although I am unfamiliar with that codebase and didn't have time to dive too deep into why. Short term fix for this particular case was to call observeOn with a size constant to sidestep the RxRingBuffer load in these tests, until we can clean up the underlying scheduler plugin overrides. However, I'm wondering if maybe internal scheduling things like this should have their own scheduler? Maybe an internal computation scheduler that could be an additional override in the schedulers hook. That would allow them to run unhindered in most cases despite computation being overridden, but in extreme cases they could be overridden as well.\n","id":"153859544","title":"Should RxRingBuffer's validator really be on the computation scheduler?","opened_on":"2016-05-09T20:14:31Z","closed_by":"akarnokd"},{"number":"3922","reopenOn":null,"comments":[{"date":"2016-05-10T20:47:17Z","author":"akarnokd","text":"Changes applied.\n"},{"date":"2016-05-10T21:23:14Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-05-10T21:23:57Z","description":"The operator `using` didn't call the resource cleanup code if the `observableFactory.call()` code crashed. In addition, a non-eager using didn't call the resource cleanup if one subscribed with `unsafeSubscribe` or the subscription to the generated `Observable` crashed.\n\nRelated: #3921 \n","id":"153783374","title":"1.x: fix using() resource cleanup when factory throws or being non-eager","opened_on":"2016-05-09T14:01:55Z","closed_by":"akarnokd"},{"number":"3921","reopenOn":null,"comments":[{"date":"2016-05-09T14:02:56Z","author":"akarnokd","text":"Thanks for reporting! This is indeed a bug and I've posted a fix PR #3922 for it.\n"},{"date":"2016-05-09T14:54:43Z","author":"dimas","text":"Oh that was quick. Impressive )\nJust out of curiosity - is it kind of implied that thing like \n\n``` java\n subscriber.add(disposeOnceOnly);\n```\n\nalways succeed and cannot throw? As well as doOnTerminate \/ doAfterTerminate.\nIsn't it safer to always do dispose in a big finally block _unless_ unsafeSubscribe was successful? That would probably also simplify exception handling as now you have two identical copy&paste blocks...\n\nSorry if I am asking nonsense - really unfamiliar with the framework right now.\n\nPS: you also have a semicolon following .doAfterTerminate(disposeOnceOnly) on a separate line - probably a typo.\n"},{"date":"2016-05-09T15:29:27Z","author":"akarnokd","text":"The Observable can complete outside the method so the classical imperative try-finally doesn't work.\n"},{"date":"2016-05-09T15:57:45Z","author":"dimas","text":"For the completion outside the method you install these doOnTerminate \/ doAfterTerminate \"callbacks\". I was only talking on what can happen inside OnSubscribeUsing.call method. You already have something like\n\n``` java\n    public void call(final Subscriber<? super T> subscriber) {\n        try {\n            final Resource resource = resourceFactory.call();\n            \/\/ ... do some stuff ...\n            try {\n                \/\/ ... create Observable via factory\n            } catch (Throwable e) {\n                \/\/ ... release resource and do some sophisticated exception handling ...\n                return;\n            }\n            \/\/ ... do some stuff ...\n            \/\/ ... install doOnTerminate \/ doAfterTerminate hooks\n            try {\n                \/\/ ... unsafeSubscribe\n            } catch (Throwable e) {\n                \/\/ ... release resource and do some sophisticated exception handling ...\n                return;\n            }\n\n        } catch (Throwable e) {\n            \/\/ ... some high level exception handling ...\n        }\n    }\n```\n\nSo my concerns here are:\n- you have two try\/catch blocks inside that look very similar to me \n- still exception can (in theory) happen on a line not covered by those blocks - one of \"do some stuff\" ones in the example above\n\nSo I though maybe these inner try\/catch can be avoided completely in favour of one bit try\/catch\/finally\n\n``` java\n    public void call(final Subscriber<? super T> subscriber) {\n        Resource resource = null;\n        try {\n            resource = resourceFactory.call();\n            \/\/ ... do some stuff ...\n            \/\/ ... do some stuff ...\n            \/\/ ... install doOnTerminate \/ doAfterTerminate hooks\n            \/\/ ... unsafeSubscribe\n            subscribed = true;\n        } catch (Throwable e) {\n            \/\/ ... error reporting\n        } finally {\n            if (!subscribed) {\n                \/\/ we are returning with exception so subscribe was not successful, dispose resource\n            }\n        }\n    }\n```\n\nit does not have to be finally block given that you catching Throwable - it is safe to release it in \"catch\".. Just saying...\n"},{"date":"2016-05-10T21:31:11Z","author":"akarnokd","text":"Fixed in #3922. If you think you can clean up the code, PR is welcome.\n"}],"opened_by":"dimas","reopen":false,"closed_on":"2016-05-10T21:31:12Z","description":"Hi.\nI am considering using of RxJava to represent REST API responses so was looking into the sources to understand how stuff works. In the OnSubscribeUsing operator there is something that looks like a logic error to me that may lead to leaking resources.\n\n(I am reporting \"theoretical\" issue, I have not tried actually making it happen. Also, I have almost zero knowledge on how RxJava works so can be really missing something. Sorry about that in advance)\n\nSo in https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/operators\/OnSubscribeUsing.java the call() method allocates resource the first thing and then creates Observable, attaches dispose handler etc. In the end it calls unsafeSubscribe handling for the potential exception.\nBut what if exception happens earlier? Imagine the resource was allocated successfully but observableFactory.call(resource) throws for example. There seems to be nothing to dispose the resource in that case.\n\nAgain. I have no deep understanding of RxJava but it looks to me that resource disposal should be happening in the top level try\/finally block if resource was allocated but doOnTerminate has not been installed yet (or failed to install). I would probably just remove the inner try\/catch and did all the handling at the top level (possibly setting some boolean to indicate that stuff actually started so no cleanup needed).\n\nCheers\n","id":"153765153","title":"Possible resource leak in OnSubscribeUsing","opened_on":"2016-05-09T12:28:28Z","closed_by":"akarnokd"},{"number":"3912","reopenOn":null,"comments":[{"date":"2016-05-05T19:28:13Z","author":"stevegury","text":"👍 \nI think the bug is serious enough that we should release a new version ASAP.\n"},{"date":"2016-05-05T19:29:43Z","author":"akarnokd","text":"Agree. Not sure if you can release with 1.1.4.1 or you have to  roll to 1.1.5.\n"},{"date":"2016-05-05T19:31:07Z","author":"JakeWharton","text":"Does `map` need the same change?\n"},{"date":"2016-05-05T19:32:26Z","author":"akarnokd","text":"No. Map doesn't set the Producer on `this` so no default-request happens.\n"},{"date":"2016-05-05T19:34:34Z","author":"JakeWharton","text":"Ah, that's right. I think I made the same mistake on the first PR, too.\n\nOn Thu, May 5, 2016 at 3:32 PM David Karnok notifications@github.com\nwrote:\n\n> No. Map doesn't set the Producer on this so no default-request happens.\n> \n> \u2014\n> You are receiving this because you commented.\n> \n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/3912#issuecomment-217253734\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-05-05T19:29:46Z","description":"Forgot that `Subscriber` defaults to requesting `Long.MAX_VALUE` unless suppressed and apparently there was no verification of filter's backpressure behavior; the two existing tests didn't really check for the delivery pattern.\n","id":"153298052","title":"1.x: fix filter() default-requesting and thus going unbounded","opened_on":"2016-05-05T18:51:54Z","closed_by":"akarnokd"},{"number":"3911","reopenOn":null,"comments":[{"date":"2016-05-05T19:00:51Z","author":"akarnokd","text":"The log tells that the `logPreAggregation()`'s return value crashed but the cause is missing from your post. There is a backpressure bug in the operator `filter` that can cause `MissingBackpressureException` but not sure this is related to that particular bug.\n"},{"date":"2016-05-05T20:08:56Z","author":"artem-zinnatullin","text":"@FranciscoE-Hudl please report if next patch release resolves your issue, see #3910. Release should be [available soon](https:\/\/github.com\/ReactiveX\/RxJava\/pull\/3913).\n"},{"date":"2016-05-05T21:19:28Z","author":"FranciscoE-Hudl","text":"@akarnokd But it doesn't crash on 1.1.3 and the logging feature has been working fine (?). There's nothing else interesting on the logs, I skipped 40 entries of missing backpressure. Same for the cause throwable.\n\n@artem-zinnatullin okay, will try.\n"},{"date":"2016-05-06T21:07:51Z","author":"FranciscoE-Hudl","text":"@akarnokd @artem-zinnatullin Seems to be fixed in 1.1.5\n"}],"opened_by":"FranciscoE-Hudl","reopen":false,"closed_on":"2016-05-06T21:07:51Z","description":"After updating to RxJava 1.1.4 some of my chains have started throwing MissingBackpressureException for some operations.\n\nCode:\n\n```\nObservable.zip(\n            mFirstObs.first(), mSecondObs.first(), mThirdObs.first(), mFourthObs.first(),\n            zipLatestState())\n    .doOnNext(logPreAggregation())\n    .map(applyAggregation());\n\n\nFunc4<A, B, C, D> zipLatestState() {\n    return (one, two, three, four) -> Quartet.with(one, two, three, four);\n}\n```\n\nError:\n\n```\nrx.exceptions.MissingBackpressureException caused by:\n\nOnError while emitting onNext value: org.javatuples.Quartet.class\n```\n\nStacktrace:\n\n```\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: org.javatuples.Quartet.class\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:192)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorZip$Zip.tick(OperatorZip.java:264)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorZip$Zip$InnerSubscriber.onNext(OperatorZip.java:335)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.internal.producers.SingleProducer.request(SingleProducer.java:65)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.Subscriber.setProducer(Subscriber.java:211)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:111)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:80)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.accept(RelaySubscriptionManager.java:311)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.emitLoop(RelaySubscriptionManager.java:282)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at com.jakewharton.rxrelay.RelaySubscriptionManager$RelayObserver.emitFirst(RelaySubscriptionManager.java:259)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at com.jakewharton.rxrelay.BehaviorRelay$1.call(BehaviorRelay.java:81)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at com.jakewharton.rxrelay.BehaviorRelay$1.call(BehaviorRelay.java:79)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at com.jakewharton.rxrelay.RelaySubscriptionManager.add(RelaySubscriptionManager.java:100)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at com.jakewharton.rxrelay.RelaySubscriptionManager.call(RelaySubscriptionManager.java:59)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at com.jakewharton.rxrelay.RelaySubscriptionManager.call(RelaySubscriptionManager.java:36)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\n05-05 11:15:31.423 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.Observable.unsafeSubscribe(Observable.java:8452)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorZip$Zip.start(OperatorZip.java:214)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:156)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:122)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.util.ScalarSynchronousObservable$WeakSingleProducer.request(ScalarSynchronousObservable.java:268)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.Subscriber.setProducer(Subscriber.java:209)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:79)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:75)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.Observable.unsafeSubscribe(Observable.java:8452)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:145)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorMap$MapSubscriber.onNext(OperatorMap.java:74)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OnSubscribeRefCount$2.onNext(OnSubscribeRefCount.java:124)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorPublish$PublishSubscriber.dispatch(OperatorPublish.java:587)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at rx.internal.operators.OperatorPublish$PublishSubscriber.onNext(OperatorPublish.java:285)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at com.jakewharton.rxbinding.view.ViewClickOnSubscribe$1.onClick(ViewClickOnSubscribe.java:23)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at android.view.View.performClick(View.java:5242)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at android.widget.TextView.performClick(TextView.java:10540)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at android.view.View$PerformClick.run(View.java:21179)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at android.os.Handler.handleCallback(Handler.java:739)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at android.os.Handler.dispatchMessage(Handler.java:95)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at android.os.Looper.loop(Looper.java:145)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at android.app.ActivityThread.main(ActivityThread.java:6873)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at java.lang.reflect.Method.invoke(Native Method)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at java.lang.reflect.Method.invoke(Method.java:372)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1404)\n05-05 11:15:31.428 19767-19767\/com.my.app W\/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1199)\n```\n","id":"153267086","title":"RxJava 1.1.4 regression crash","opened_on":"2016-05-05T16:16:55Z","closed_by":"FranciscoE-Hudl"},{"number":"3910","reopenOn":null,"comments":[{"date":"2016-05-05T18:54:30Z","author":"akarnokd","text":"Thanks for reporting. Fix in #3912.\n"},{"date":"2016-05-05T20:11:33Z","author":"akarnokd","text":"Fix released with 1.1.5. Should be available from maven within a few hours.\n"}],"opened_by":"boris-petrov","reopen":false,"closed_on":"2016-05-05T20:11:33Z","description":"The following code:\n\n``` java\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.Subscription;\n\npublic class Test {\n    public static void main(String[] arguments) throws InterruptedException {\n        new Test().test();\n    }\n\n    void test() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(1);\n\n        Subscription subscription = createBackpressuredObservable()\n            .filter(item -> true)\n            .mergeWith(createBackpressuredObservable())\n            .subscribe(\n                item -> {},\n                e -> {\n                    e.printStackTrace();\n                    latch.countDown();\n                },\n                latch::countDown);\n        latch.await(7, TimeUnit.SECONDS);\n        subscription.unsubscribe();\n    }\n\n    private Observable<Integer> createBackpressuredObservable() {\n        return Observable\n            .<Integer> create(subscriber -> {\n                new Thread(() -> {\n                    while (!subscriber.isUnsubscribed()) {\n                        subscriber.onNext(0);\n                    }\n                    if (!subscriber.isUnsubscribed()) {\n                        subscriber.onCompleted();\n                    }\n                }).start();\n            })\n            .onBackpressureBuffer();\n    }\n}\n```\n\nWorks with RxJava version 1.1.3, but breaks in 1.1.4 with a `rx.exceptions.MissingBackpressureException`. If you remove the `filter` on line 16, it works fine on both versions. I'm not sure I understand everything about how backpressure works, but I think this is a bug. Please correct me if I'm wrong.\n\nAs a side note, the documentation on backpressure, how it is propagated and which operators use reactive pull backpressure internally is really scarce and difficult to follow.\n","id":"153266119","title":"Filter breaks backpressure","opened_on":"2016-05-05T16:11:59Z","closed_by":"akarnokd"},{"number":"3905","reopenOn":null,"comments":[{"date":"2016-05-02T22:27:40Z","author":"stevegury","text":"👍 \n"},{"date":"2016-05-02T22:50:11Z","author":"zsxwing","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-05-02T22:50:48Z","description":"Issue #3892 is a goldmine for missing backpressure problems. This PR fixes the case when `singleOrDefault` encounters an empty source and has to emit some default value. Fixed via setting the `SingleProducer` on the child on termination.\n","id":"152596288","title":"1.x: fix singleOrDefault() backpressure if source is empty","opened_on":"2016-05-02T17:05:26Z","closed_by":"zsxwing"},{"number":"3904","reopenOn":null,"comments":[{"date":"2016-05-01T21:38:07Z","author":"akarnokd","text":"Looks good, :+1:\n\nI wonder, shouldn't we switch to `Exceptions.throwIfFatal` as in `Observable`? Of course, the whole `Completable` needs rechecking.\n"},{"date":"2016-05-01T22:46:05Z","author":"prt2121","text":"Updated to use `Exceptions.throwIfFatal`. Thanks!\n"},{"date":"2016-05-02T05:27:39Z","author":"zsxwing","text":"👍 \n"}],"opened_by":"prt2121","reopen":false,"closed_on":"2016-05-02T07:08:42Z","description":"Fixed https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3860\n","id":"152447266","title":"1.x: Fix Completable swallows OnErrorNotImplementedException","opened_on":"2016-05-01T21:27:53Z","closed_by":"akarnokd"},{"number":"3896","reopenOn":null,"comments":[{"date":"2016-04-29T20:33:53Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-29T20:42:32Z","description":"Found another one.\n","id":"151735367","title":"1.x: OperatorMapPair should unsubscribe on crash eagerly","opened_on":"2016-04-28T20:27:06Z","closed_by":"akarnokd"},{"number":"3895","reopenOn":null,"comments":[{"date":"2016-04-28T20:07:01Z","author":"JakeWharton","text":"LGTM :+1:\n"},{"date":"2016-04-29T20:34:39Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-29T20:42:49Z","description":"Similar issue as in #3890.\n","id":"151729313","title":"1.x: cast() should unsubscribe on crash eagerly","opened_on":"2016-04-28T19:57:36Z","closed_by":"akarnokd"},{"number":"3893","reopenOn":null,"comments":[{"date":"2016-04-28T17:49:26Z","author":"JakeWharton","text":"LGTM :+1:\n"},{"date":"2016-04-29T21:40:15Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-29T21:43:53Z","description":"The `from(Future)` operator was not refitted for backpressure.\n\nReported in: #3892.\n","id":"151699635","title":"1.x: enable backpressure with from(Future).","opened_on":"2016-04-28T17:30:34Z","closed_by":"akarnokd"},{"number":"3892","reopenOn":null,"comments":[{"date":"2016-04-28T17:23:46Z","author":"akarnokd","text":"Looks like `OnSubscribeToObservableFuture` was not refitted with backpressure support and it fires the future's value unconditionally. I'll post a fix for this. Thanks for reporting!\n"},{"date":"2016-04-28T17:31:24Z","author":"akarnokd","text":"See #3893.\n\nWorkaround for now: apply `onBackpressureBuffer()` after the `from(Future)` you are using.\n"},{"date":"2016-04-28T17:32:09Z","author":"vadims","text":"Great, thanks!\n"},{"date":"2016-05-02T16:34:30Z","author":"vadims","text":"I think there might be other operators that need to be retrofitted? \n\n``` java\nNon-fatal Exception: java.lang.IllegalStateException: more items arrived than were requested\n       at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:206)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)\n       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)\n       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:129)\n       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:107)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.onCompleted(OperatorMerge.java:268)\n       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47)\n       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable.unsafeSubscribe(Observable.java:8741)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:209)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)\n       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)\n       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:125)\n       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.emit(OperatorTakeLastOne.java:159)\n       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:125)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)\n       at rx.internal.operators.OperatorMerge$InnerSubscriber.onCompleted(OperatorMerge.java:836)\n       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)\n       at rx.internal.operators.OperatorOnBackpressureBuffer$BufferSubscriber.complete(OperatorOnBackpressureBuffer.java:169)\n       at rx.internal.util.BackpressureDrainManager.drain(BackpressureDrainManager.java:187)\n       at rx.internal.util.BackpressureDrainManager.terminateAndDrain(BackpressureDrainManager.java:114)\n       at rx.internal.operators.OperatorOnBackpressureBuffer$BufferSubscriber.onCompleted(OperatorOnBackpressureBuffer.java:140)\n       at rx.internal.operators.OperatorSubscribeOn$1$1.onCompleted(OperatorSubscribeOn.java:68)\n       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:76)\n       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:43)\n       at rx.Observable.unsafeSubscribe(Observable.java:8741)\n       at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n       at java.lang.Thread.run(Thread.java:818)\n```\n"},{"date":"2016-05-02T16:43:09Z","author":"akarnokd","text":"Do you have a default value on your single() operator?\n"},{"date":"2016-05-02T16:54:34Z","author":"vadims","text":"We call `lastOrDefault` which calls `new OperatorSingle<T>(defaultValue)`.\n"},{"date":"2016-05-02T16:56:44Z","author":"akarnokd","text":"Thanks, found the issue in OperatorSingle, when the default path is taken, the value is emitted without checking for backpressure. I'll post a fix soon.\n"},{"date":"2016-05-02T17:17:32Z","author":"akarnokd","text":"See #3905.\n"},{"date":"2016-05-02T17:53:19Z","author":"vadims","text":"Thanks!\n"},{"date":"2016-05-02T22:51:04Z","author":"zsxwing","text":"Close via #3905\n"}],"opened_by":"vadims","reopen":false,"closed_on":"2016-05-02T22:51:06Z","description":"We're seeing this exception for a small percent of our users. We haven't been able to reproduce this ourselves so providing a sample might not be feasible. Any idea what could be causing this based on the stacktrace alone?\n\n``` java\nNon-fatal Exception: java.lang.IllegalStateException: more items arrived than were requested\n       at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:206)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)\n       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)\n       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:129)\n       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:107)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.onCompleted(OperatorMerge.java:268)\n       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47)\n       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable.unsafeSubscribe(Observable.java:8741)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:209)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)\n       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)\n       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:125)\n       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.emit(OperatorTakeLastOne.java:159)\n       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:125)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)\n       at rx.internal.operators.OperatorMerge$InnerSubscriber.onCompleted(OperatorMerge.java:836)\n       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)\n       at rx.internal.operators.OperatorSubscribeOn$1$1.onCompleted(OperatorSubscribeOn.java:68)\n       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:76)\n       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:43)\n       at rx.Observable.unsafeSubscribe(Observable.java:8741)\n       at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n       at java.lang.Thread.run(Thread.java:818)\n```\n","id":"151695143","title":"java.lang.IllegalStateException: more items arrived than were requested","opened_on":"2016-04-28T17:08:58Z","closed_by":"zsxwing"},{"number":"3890","reopenOn":null,"comments":[{"date":"2016-04-29T20:41:43Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-29T20:44:33Z","description":"In current master, when the function in `map` or `filter` crashes, the error is propagated but the upstream is not immediately unsubscribed but expected to happen eventually due to some other operator or `SafeSubscriber`.\n\nThe fix, and also the restructuring of the unsubscription chain, makes sure the crash also unsubscribes immediately (unless a fatal one).\n\nRelated: [StackOverflow question](http:\/\/stackoverflow.com\/questions\/35343474\/why-does-it-need-onbackpressure-here-for-click-events)\n","id":"151628812","title":"1.x: map() and filter() should unsubscribe on crash eagerly","opened_on":"2016-04-28T12:25:36Z","closed_by":"akarnokd"},{"number":"3886","reopenOn":null,"comments":[{"date":"2016-04-27T14:10:58Z","author":"akarnokd","text":":+1:\n"},{"date":"2016-04-29T05:56:46Z","author":"zsxwing","text":"👍 \n"}],"opened_by":"dlew","reopen":false,"closed_on":"2016-04-29T05:56:57Z","description":"Otherwise, if there's an error in onCompleted, the exception is\nswallowed and unreported.\n\nFixes #3885\n","id":"151394828","title":"throwIfFatal() now throws OnCompletedFailedException","opened_on":"2016-04-27T14:06:23Z","closed_by":"zsxwing"},{"number":"3885","reopenOn":null,"comments":[{"date":"2016-04-27T13:18:58Z","author":"akarnokd","text":"`SafeSubscriber.OnCompleted` rethrows it as `OnCompletedFailedException` which then bounced back to `onError` because `throwIfFatal` doesn't recognize it (only `OnErrorNotImplementedException` and `OnErrorFailedException` are rethrown from this class of failures).\n"},{"date":"2016-04-27T13:26:44Z","author":"dlew","text":"Would a reasonable solution be to add `OnCompletedFailedException` to `throwIfFatal`, then? I could work on that PR if that's all it takes.\n"},{"date":"2016-04-27T13:29:21Z","author":"akarnokd","text":"Yes, go ahead.\n"}],"opened_by":"dlew","reopen":false,"closed_on":"2016-04-29T05:56:57Z","description":"I was fairly surprised by the behavior of this stream:\n\n``` java\nObservable.empty()\n    .subscribe(\n        System.out::println, \n        System.err::println,\n        () -> { throw new RuntimeException(); }\n    );\n```\n\nWhat I expected to see was the thread crashing due to the exception; instead absolutely nothing happens because `onCompleted` swallows the exception entirely.\n","id":"151381463","title":"onCompleted swallows all exceptions","opened_on":"2016-04-27T13:12:40Z","closed_by":"zsxwing"},{"number":"3883","reopenOn":null,"comments":[{"date":"2016-04-29T21:33:12Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-29T21:43:36Z","description":"Resolves #3881.\n\nThe bug is caused by the impedance mismatch between `Observable`'s `Subscriber` and `Single`'s `SingleSubscriber`. The original code called `onNext()` which immediately signalled an `onSuccess` but also caused an unsubscription, preventing a delivery of `onCompleted()` in the inner Single.\n\nThe fix keeps `onSuccess`\/`onError` rails intact  throughout the chain.\n","id":"151343299","title":"1.x: fix multiple chained Single.doAfterTerminate not calling actions","opened_on":"2016-04-27T09:42:51Z","closed_by":"akarnokd"},{"number":"3881","reopenOn":null,"comments":[{"date":"2016-04-27T07:04:25Z","author":"akarnokd","text":"Interesting.\n"},{"date":"2016-04-27T10:23:45Z","author":"akarnokd","text":"Thanks for reporting. See #3883 for a fix.\n"},{"date":"2016-04-27T17:17:55Z","author":"solcott","text":"This works for me.\n"}],"opened_by":"solcott","reopen":false,"closed_on":"2016-04-29T21:43:36Z","description":"I've noticed that when I return a Single from a flatMap and that Single calls doAfterTerminate(Action0) the Action0's call method is never called.  This behaviour is not consistent with what happens when you do the same thing with an Observable.  I am using 1.1.3\n\nWhen I run:\n\n``` java\nSingle.just(\"Test\")\n    .flatMap(s -> \n        Single.just(\"Test2\")\n            .doAfterTerminate(() -> System.out.println(\"singleFlatMapDoAfterTerminate\"))\n        )\n.doAfterTerminate(() -> System.out.println(\"singleDoAfterTerminate\"))\n.subscribe(new TestSubscriber<String>());\n```\n\nI would expect the following to be printed to the console:\n\n> singleDoAfterTerminate\n> singleFlatMapDoAfterTerminate\n\nHowever only the following is printed to the console\n\n> singleDoAfterTerminate\n\nWhen I do the same with an Observable\n\n``` java\nObservable.just(\"Test\")\n    .flatMap(s -> Observable.just(\"Test2\")\n        .doAfterTerminate(() -> System.out.println(\"observableFlatMapDoAfterTerminate\"))\n     )\n.doAfterTerminate(() -> System.out.println(\"observableDoAfterTerminate\"))\n.subscribe(new TestSubscriber<String>());`\n```\n\nI see the following printed to the console:\n\n> observableDoAfterTerminate\n> observableFlatMapDoAfterTerminate\n","id":"151252315","title":"Single not calling doAfterTerminate when used in flatMap","opened_on":"2016-04-26T22:14:37Z","closed_by":"akarnokd"},{"number":"3863","reopenOn":null,"comments":[{"date":"2016-04-17T20:24:01Z","author":"tilal6991","text":"Pretty sure this is what https:\/\/github.com\/ReactiveX\/RxJava\/pull\/3862 is addressing.\n"},{"date":"2016-04-17T23:23:15Z","author":"Hezj","text":"my fault.will close.\n"}],"opened_by":"Hezj","reopen":false,"closed_on":"2016-04-17T23:23:15Z","description":"When trying to pass an Iterable to Observable.from() and it's Iterator.next() throws an exception, the observer subscribed or doOnError() method can't catch the exception\n","id":"148988627","title":"Exceptions thrown by Iterator.next() cannot be caught by the observer whe","opened_on":"2016-04-17T19:47:11Z","closed_by":"Hezj"},{"number":"3862","reopenOn":null,"comments":[{"date":"2016-04-18T07:18:38Z","author":"artem-zinnatullin","text":"👍 \n"},{"date":"2016-04-21T07:30:13Z","author":"davidmoten","text":"L93 no longer needs parameter `n`:\n\n``` java\nvoid slowpath(long n) {\n```\n"},{"date":"2016-04-21T07:33:25Z","author":"davidmoten","text":":+1:  once last comment dealt with\n"},{"date":"2016-04-21T07:36:32Z","author":"akarnokd","text":"Actually, it should be using `n`. Fixed.\n"},{"date":"2016-04-21T07:43:41Z","author":"davidmoten","text":"Yep I see, nice.\n"},{"date":"2016-04-21T19:50:47Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-21T19:58:08Z","description":"The `from(Iterable)` ignored non-fatal exceptions thrown by the `Iterable` and `Iterator`.\n\nApart from wrapping the calls into `try-catch`, the overal emission algorithm has been changed:\n- It calls `hasNext` only once for each available value. Since the subscribe() checks for an outright empty `Iterable`, the drain loop runs only if it wasn't empty and does another `hasNext` check immediately to complete immediately if possible.\n- It uses what I call a fast-flow algorithm to avoid decrementing the requested amount (this) if there were more requests issued during the emission.\n","id":"148905761","title":"1.x: fix from(Iterable) error handling of Iterable\/Iterator","opened_on":"2016-04-17T00:31:52Z","closed_by":"akarnokd"},{"number":"3845","reopenOn":null,"comments":[{"date":"2016-04-08T21:43:42Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-08T21:45:03Z","description":"The serial subscription in the `delaySubscription(Observable)` operator was not chained properly and thus an unsubscription before any events by the other didn't prevent the subscription to the main source.\n\nReported in #3844\n","id":"147024372","title":"1.x: fix delaySubscription(Observable) unsubscription before triggered","opened_on":"2016-04-08T19:56:42Z","closed_by":"akarnokd"},{"number":"3840","reopenOn":null,"comments":[{"date":"2016-04-08T20:06:17Z","author":"zsxwing","text":":+1: \n"},{"date":"2016-04-08T22:02:51Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-08T20:06:27Z","description":"There were two tiny problems with the rewritten `concatMap` operator, mainly due to copy-paste error:\n- When a scalar was concatenated, the `active` field was not set and thus the next prefetched source overwrote it.\n- When the scalar was set on the arbiter, its custom producer didn't check for n > 0 zero causing instant emission always. Generally Producer.request(0) is allowed and should be no-op (unlike RS).\n- When an empty() was encountered as a last source, the it didn't trigger the check for completion afterwards.\n","id":"146663327","title":"1.x: fix concatMap scalar\/empty source behavior","opened_on":"2016-04-07T15:41:42Z","closed_by":"zsxwing"},{"number":"3839","reopenOn":null,"comments":[{"date":"2016-04-08T21:36:33Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-08T21:39:57Z","description":"The counted and timed versions of `takeLast` had a concurrency bug which allowed concurrent emission from the underlying queue that holds onto the values till the upstream completes. When timed correctly, both an `onCompleted()` and a `request()` that went from 0 to n could enter the emit() method and break the internal state of the non-concurrent queue. Note that this queue doesn't have to be concurrent by nature because the operator can emit only _after_ the upstream completes (`offer()` never runs concurrently with `poll()` unlike in `observeOn`).\n\nIn addition, the emission didn't immediately complete if the queue was emptied and requested == 0. In this operator, the fact that the queue became empty is the indicator of completion.\n\nBoth issues can be fixed with the `postCompleteXXX` mechanics in `BackpressureUtils`.\n\nSince the operator has to store `null` values, the `postCompleteXXX` had to be extended with an exit transform overload to allow converting the `NotificationLite` values back to regular `T`\/`null`.\n","id":"146590026","title":"1.x: fix takeLast() backpressure","opened_on":"2016-04-07T11:37:54Z","closed_by":"akarnokd"},{"number":"3838","reopenOn":null,"comments":[{"date":"2016-04-07T10:22:06Z","author":"akarnokd","text":"That producer looks shady and unconventional to my eyes. If the source completes the same time there is a request that transitions from 0 to n, both would end up in the emit() method. Let me write a test that breaks it...\n"},{"date":"2016-04-07T10:42:13Z","author":"akarnokd","text":"Yes, it has concurrency issues + late delivery of onCompleted. Will open a PR to fix it.\n"},{"date":"2016-04-07T11:38:34Z","author":"akarnokd","text":"Fix posted: #3839.\n"},{"date":"2016-04-08T21:43:19Z","author":"akarnokd","text":"Closing via #3839. Thanks for reporting!\n"},{"date":"2016-04-11T02:57:45Z","author":"hzsweers","text":"@akarnokd I think you forgot to hit close ;)\n"}],"opened_by":"cy6erGn0m","reopen":false,"closed_on":"2016-04-11T06:02:31Z","description":"See\n\nrx.internal.operators.OperatorTakeLast\nrx.internal.operators.TakeLastQueueProducer\n\nWhat if there is `OperatorTakeLast.onCompleted` has already started emit loop and there is `TakeLastQueueProducer.request(n)` trying to run this loop as well. Shouldn't it cause concurrent access to `ArrayDeque.poll\/clear`?\n","id":"146568014","title":"Concurrency against ArrayDeque?","opened_on":"2016-04-07T09:59:15Z","closed_by":"akarnokd"},{"number":"3836","reopenOn":null,"comments":[{"date":"2016-04-06T22:13:48Z","author":"stevegury","text":"👍 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-07T06:59:56Z","description":"This PR fixes the producer retention problem and backpressure problem in `switchMap`\/`switchOnNext`.\n\nIn the original, when an inner source completed, its producer was still referenced after it. If there was no new inner source or the next inner source didn't set a new producer, the operator leaked the previous inner source's internals. The fix involves nulling out the producer field when the inner source completes (and is still the current one).\n\nThe original had an additional bug due to a race condition between the request arbitration and switching inner sources. In some cases, the switch didn't properly forward the remaining request amount to the new inner source, causing hangs. In some other cases, both the old and new inner sources were able to emit, causing overflow. The fix involves a new queue-drain loop with some emitter-loop help to work out the state transitions.\n","id":"146281153","title":"1.x: fix switchMap\/switchOnNext producer retention and backpressure","opened_on":"2016-04-06T11:21:34Z","closed_by":"akarnokd"},{"number":"3823","reopenOn":null,"comments":[{"date":"2016-04-03T21:55:11Z","author":"davidmoten","text":":+1:\n"},{"date":"2016-04-04T17:49:54Z","author":"stevegury","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-04T18:11:37Z","description":"Fixes the bug reported in #3435.\n","id":"145431958","title":"1.x: DoAfterTerminate handle if action throws","opened_on":"2016-04-02T23:51:07Z","closed_by":"akarnokd"},{"number":"3822","reopenOn":null,"comments":[{"date":"2016-04-04T18:36:55Z","author":"stevegury","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-04T18:39:52Z","description":"Possible solution to #3749.\n","id":"145428304","title":"1.x: make defensive copy of the properties in RxJavaPlugins","opened_on":"2016-04-02T23:09:11Z","closed_by":"akarnokd"},{"number":"3814","reopenOn":null,"comments":[{"date":"2016-04-06T07:41:07Z","author":"akarnokd","text":"Updated with another fix + test.\n"},{"date":"2016-04-06T09:29:12Z","author":"akarnokd","text":"Closing this and will post a fresh PR with a completely rewritten operator as it has backpressure problems as well (overflow\/hang).\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-04-06T09:29:12Z","description":"There are two cases when the operator `switchOnNext` \/ `switchMap` retained parts of an earlier source through its `Producer` via the arbiter structure:\n- when a backpressure-supporting source was followed by a unsupporting source which never sets a new Producer, keeping the old one there indefinitely\n- when a backpressure-supporting source terminated but was not followed by any other source for longer period of time\n\nThe fix swaps in a null-producer when a new source is encountered and when an old source terminates. The swap is guarded by the current index so outdated events won't interfere with newer sequences.\n\n**Edit**\n\nFixed a `ConcurrentModificationException` because the `queue` wasn't nulled out after assigning it to `localQueue`. Plus, I've added a test to check the async-source and async-inner doesn't cause backpressure exceptions.\n","id":"144914127","title":"1.x: Fix prolonged Producer retention in switchOnNext","opened_on":"2016-03-31T14:14:53Z","closed_by":"akarnokd"},{"number":"3812","reopenOn":null,"comments":[{"date":"2016-03-31T09:25:52Z","author":"davidmoten","text":"I had a quick look at `OperatorSwitch` and didn't pick up on any obvious retention of references. One thing I notice from your test is that you can't assume `System.gc()` is run synchronously and to have a hope of it doing something I imagine you'd need to put a sleep in after it.\n"},{"date":"2016-03-31T09:37:34Z","author":"Thomvis","text":"Thanks for the super quick response!\n\nI re-ran the tests with a 1 and 10 second sleep after each `System.gc()`, but the results were the same.\n\nThe internals of RxJava are still a bit over my head, but looking at the following path from a heap dump, it could have something to do with the arbiter keeping a reference to the producer. Note that this dump is from the real app I'm building, not the reduced test case.\n\n<img width=\"749\" alt=\"screen shot 2016-03-31 at 11 28 02\" src=\"https:\/\/cloud.githubusercontent.com\/assets\/134170\/14171666\/676209ce-f734-11e5-9a13-877343793fa7.png\">\n\nIn the context of the heap dump from the image, I'd expect the OperatorPublish$InnerProducer and below (the last four lines) to not be retained.\n"},{"date":"2016-03-31T11:18:39Z","author":"Thomvis","text":"I've some more evidence which indicates that the operator is not properly releasing a reference to an old observable. The following screenshots were taken while stepping through the test. Please note the following:\n- The field of interest `currentProducer` is highlighted\n- `currentProducer` is `null` until `just` is _fed_ to the operator, after that it contains an `IterableProducer` with id `@1058`\n- The value of `currentProducer` does not change, even if new observables are fed to the operator. Until giving it an observable with two values, the producer remains `@1058`. I would expect the producer to change to the producer of the subsequent observables.\n- Feeding the two-element observable finally results in a new producer (`@1108`)\n\n![1](https:\/\/cloud.githubusercontent.com\/assets\/134170\/14174063\/5588e7fa-f742-11e5-8efd-26875ac83b06.png)\n![2](https:\/\/cloud.githubusercontent.com\/assets\/134170\/14174064\/55a78c0a-f742-11e5-8bad-dc9bfec1b833.png)\n![3](https:\/\/cloud.githubusercontent.com\/assets\/134170\/14174067\/55ac98f8-f742-11e5-9740-e69eb187f94c.png)\n![4](https:\/\/cloud.githubusercontent.com\/assets\/134170\/14174066\/55a9a058-f742-11e5-8f3b-ea8654746bf5.png)\n![5](https:\/\/cloud.githubusercontent.com\/assets\/134170\/14174065\/55a8f6ee-f742-11e5-8740-0140615d258e.png)\n"},{"date":"2016-03-31T13:34:40Z","author":"akarnokd","text":"I guess we could flush the arbiter in case the next source doesn't do backpressure and thus never calls `setProducer()`. However, `just()` does support backpressure since 1.1.1. Are you testing the latest RxJava?\n"},{"date":"2016-03-31T14:15:04Z","author":"akarnokd","text":"Fix in #3814.\n"},{"date":"2016-03-31T19:53:40Z","author":"Thomvis","text":"Thanks so much, this is great. Hope to see the fix in a release soon. \n\nI was testing with 1.1.0, for no good reason other than that we've not upgraded yet. In the real app, the observable that was not getting released was followed by an Observable.empty(), not sure if that one has back pressure so that it would've made a difference.\n\nThanks again!\n"},{"date":"2016-04-05T08:26:26Z","author":"HotIceCream","text":"I had similar problem. I wrote test: https:\/\/gist.github.com\/HotIceCream\/8010c296d6f1ad9fc6882e2dcf2d13d3 with some reflection hack.\n\nI build library from 3814 pull request but test still not passed. Is it different bug? Or it isn't it correct test?\n"},{"date":"2016-04-05T08:38:15Z","author":"akarnokd","text":"@HotIceCream your sources never complete and keep the subscriber active.\n"},{"date":"2016-04-05T08:43:20Z","author":"akarnokd","text":"@HotIceCream your sources never complete and keep the subscriber active.\n"},{"date":"2016-04-05T08:52:07Z","author":"HotIceCream","text":"@akarnokd, yes. But when i use subjects it is correct behavior. I waiting new elements from subject until switchMap called. And when switch map called, from previous observable should producer removed.\n"},{"date":"2016-04-05T08:56:14Z","author":"akarnokd","text":"You are calling cache on the same source you are testing; the switchMap just keeps resubscribing to `o` and thus you always have 1 subscriber to it.\n"},{"date":"2016-04-05T09:13:45Z","author":"HotIceCream","text":"@akarnokd, yes. It is what i want. But inside CachedObservable after each resubscribing in array of producers adding new ReplayProduecer. And it isn't removed until `o` called onComplete (i.e. if using subjects - never). Test create 100 ReplayProduecers.\nMay be it is separate bug?\n"},{"date":"2016-04-05T09:20:28Z","author":"akarnokd","text":"No, its the misunderstanding of the lifecycle of `cache()`. If you do this without the `switchMap`, you'll get 100 subscribers in the subject as well:\n\n``` java\nPublishSubject<Object> ps = PublishSubject.create();\n\nfor (int i = 0; i < 100; i++) {\n    ps.cache().subscribe().unsubscribe();\n}\n```\n\nOnce started, `cache()` can't be stopped. This was a decided tradeoff.\n"},{"date":"2016-04-07T07:26:36Z","author":"akarnokd","text":"Closing via #3836.\n"}],"opened_by":"Thomvis","reopen":false,"closed_on":"2016-04-07T07:26:36Z","description":"Hi & thanks for this amazing library!\n\nFor the past few days I've been confused by some memory leaks that caused by RxJava or, more likely, my misunderstanding of RxJava. I've reduced the issue to a very simple test case that you can find here: https:\/\/gist.github.com\/Thomvis\/18474b51b1b4dff79191f93330ae627e.\n\nThe issue has to do with `switchMap`. I'd expect that when the source Observable emits an onNext event (containing a new Observable), the operator will unsubscribe from the previous Observable and release all references to that Observable. The unsubscribing part is happening, but the releasing is not. Because the Observable is not released, any upstream operators, anonymous inner classes and their captures are also not released and subsequently not garbage collected.\n\nI've read https:\/\/github.com\/ReactiveX\/RxJava\/issues\/1292 and https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3074, but I'm not sure if they're related.\n\nSo what I'm hoping to get from this issue is one of the following:\n- My test is wrong\n- I'm using `switchMap` wrong \/ have wrong assumptions on the memory model\n- (There's a bug in OperatorSwitch)\n\nThanks in advance,\nThomas\n","id":"144834813","title":"OperatorSwitch keeping reference to previous Observable longer than expected","opened_on":"2016-03-31T09:04:02Z","closed_by":"akarnokd"},{"number":"3809","reopenOn":null,"comments":[{"date":"2016-03-29T15:28:25Z","author":"artem-zinnatullin","text":":+1: \n"},{"date":"2016-03-29T15:34:25Z","author":"akarnokd","text":"Wrong test, didn't trigger the code path that goes into the queue. Updated.\n"},{"date":"2016-03-29T15:46:52Z","author":"artem-zinnatullin","text":":+1: \n\n\/\/ New rule: check all PRs locally\u2026\n"},{"date":"2016-03-29T17:15:46Z","author":"zsxwing","text":":+1: \n"},{"date":"2016-03-30T21:13:45Z","author":"stevegury","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-03-29T20:00:07Z","description":"This crash happens on contention where a scalar null value has to go through the scalar-queue which doesn't support nulls and requires NotificationLite transformations. (The drain side had the proper `getValue` in place already.)\n\nReported in #3808.\n","id":"144296662","title":"1.x: fix merge\/flatMap crashing on an inner scalar of null","opened_on":"2016-03-29T15:17:22Z","closed_by":"akarnokd"},{"number":"3808","reopenOn":null,"comments":[{"date":"2016-03-29T15:17:45Z","author":"akarnokd","text":"This is a bug on the entry side of the scalar-queue not encoding the `null` value. Fix posted in #3809.\n"},{"date":"2016-04-02T23:15:56Z","author":"akarnokd","text":"Closing via #3809.\n"}],"opened_by":"dlew","reopen":false,"closed_on":"2016-04-02T23:15:56Z","description":"Take a look at this (admittedly somewhat wonky) sample stream:\n\n``` java\nObservable.range(0, 2)\n    .flatMap(__ -> Observable.just(null))\n    .subscribe(new Subscriber<Object>() {\n      @Override public void onNext(Object o) {\n        System.out.println(\"onNext(\" + o + \")\");\n      }\n\n      @Override public void onError(Throwable e) {\n        e.printStackTrace();\n      }\n\n      @Override public void onStart() {\n        request(1);\n      }\n\n      @Override public void onCompleted() { }\n    });\n```\n\nIn this sample I'm purposefully only requesting one item so that the second one ends up getting queued in the internal `OperatorMerge`. As a result of passing `null` to the queue, though, I end up getting this in `onError`:\n\n``` java\njava.lang.NullPointerException\n    at rx.internal.util.atomic.SpscUnboundedAtomicArrayQueue.offer(SpscUnboundedAtomicArrayQueue.java:71)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.queueScalar(OperatorMerge.java:465)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:437)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:228)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:142)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:54)\n    at rx.internal.operators.OnSubscribeRange$RangeProducer.fastpath(OnSubscribeRange.java:126)\n    at rx.internal.operators.OnSubscribeRange$RangeProducer.request(OnSubscribeRange.java:63)\n    at rx.Subscriber.setProducer(Subscriber.java:211)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OnSubscribeRange.call(OnSubscribeRange.java:38)\n    at rx.internal.operators.OnSubscribeRange.call(OnSubscribeRange.java:26)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.subscribe(Observable.java:8191)\n    at rx.Observable.subscribe(Observable.java:8158)\n    at net.danlew.experiments.Tester.main(Tester.java:39)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\nCaused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: 1\n    at rx.exceptions.OnErrorThrowable.addValueAsLastCause(OnErrorThrowable.java:109)\n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)\n    ... 18 more\n```\n\nI'm running into in more complex code where the requests # is different than the # items pushed and seeing the same problem.\n","id":"144289799","title":"NullPointerException caused by null elements in merge() queue","opened_on":"2016-03-29T14:53:49Z","closed_by":"akarnokd"},{"number":"3794","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":null,"description":"There [was a post](http:\/\/psy-lob-saw.blogspot.hu\/2016\/03\/gc-nepotism-and-linked-queues.html) just recently by @nitsanw warning about the problem called GC nepotism.\n\nThis affects our older copies of the JCTools queues, `MpscLinkedQueue` and `SpscLinkedArrayQueue`. There is an issue, #1735, about shading which would fix it, but that could happen in any time, even after some more small version changes.\n\nIn addition, the issue affects both the bounded versions of `replay()` and `ReplaySubject`. The problem there is that individual subscribers could be at any point in the linked-node sequence we can't just null out links when the operators move their head forward (trimming).\n\nIt might be possible to null out the right node by scanning the known child subscribers and chosing the earliest node any of them knows about. Unfortunately, this also requires back-references between nodes as well as node indexing, taking extra time and extra concurrency considerations.\n","id":"143095963","title":"GC nepotism in linked data structures","opened_on":"2016-03-23T22:25:43Z","closed_by":null},{"number":"3789","reopenOn":null,"comments":[{"date":"2016-03-23T08:07:20Z","author":"akarnokd","text":":+1:\n"},{"date":"2016-03-23T22:17:16Z","author":"stevegury","text":":+1: \n"}],"opened_by":"artem-zinnatullin","reopen":false,"closed_on":"2016-03-23T22:33:02Z","description":"Closes #3784.\n","id":"142819544","title":"1.x: Prevent Single.zip() of zero Singles","opened_on":"2016-03-23T00:29:43Z","closed_by":"akarnokd"},{"number":"3787","reopenOn":null,"comments":[{"date":"2016-03-21T19:22:23Z","author":"artem-zinnatullin","text":":+1: \n"},{"date":"2016-03-23T22:12:49Z","author":"stevegury","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-03-23T22:32:34Z","description":"In 1.1.1, `groupBy` was fixed to properly honor backpressure on the outer `Observable`. The change included a drain loop that emitted `onCompleted()` to the groups only when all `GroupedObservable`s were drained from the main queue. This delayed the group's completion unnecessarily causing the `concat` operator to hang in some source-consumer cases such as #3775.\n\nThis PR fixes the behavior by signalling `onCompleted()` to the groups the moment the main completes. \n\nNote, however, that concatenating groups is eventually prone to hangs due to the groups not completing until the source completes, thus `concat` can't switch to the next source. One should use `flatMap` or `concatMapEager` instead.\n","id":"142437526","title":"1.x: fix GroupBy delaying group completion till all groups were emitted","opened_on":"2016-03-21T18:51:33Z","closed_by":"akarnokd"},{"number":"3784","reopenOn":null,"comments":[{"date":"2016-03-20T13:02:12Z","author":"artem-zinnatullin","text":"What do you expect it to do? Throw error? Single either emits one result or throws error. \n\nLooks like the best we can do is to throw something like `IllegalArgumentException`. \n"},{"date":"2016-03-20T13:33:08Z","author":"akarnokd","text":"Observable.zip just completes if there are no sources. If one converts an empty Observable to single, it produces a NoSuchElementException error.\n"},{"date":"2016-03-20T15:25:25Z","author":"artem-zinnatullin","text":"I'll check this and work on PR soon. \n"}],"opened_by":"Centaur","reopen":false,"closed_on":"2016-03-23T22:33:02Z","description":"``` java\nSingle.zip(new ArrayList<Single<Integer>>(), i -> i)\n          .doAfterTerminate(() -> System.out.println(\"terminated\"))\n          .subscribe();\n```\n\nthis behavior is different from `Observable.zip`\n\n``` java\nObservable.zip(new ArrayList<Observable<Integer>>(), i -> i)\n                   .doAfterTerminate(() -> System.out.println(\"terminated\"))\n                   .subscribe();\n```\n","id":"142159226","title":"Single.zip on empty collection never terminate","opened_on":"2016-03-20T12:33:02Z","closed_by":"akarnokd"},{"number":"3775","reopenOn":null,"comments":[{"date":"2016-03-17T09:37:40Z","author":"akarnokd","text":"Strange. This code works for me on 1.1.1:\n\n``` java\npublic class GroupConcat {\n    static final class AppInfo {\n        String name;\n        LocalDate date;\n        @Override\n        public String toString() {\n            return name + \" @ \" + date;\n        }\n    }\n    public static void main(String[] args) {\n        System.setProperty(\"rx.ring-buffer.size\", \"16\");\n\n        List<AppInfo> list = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 3; j++) {\n                AppInfo ai = new AppInfo();\n                ai.name = i + \" - \" + j;\n                ai.date = LocalDate.of(2016, 3, i + 1);\n                list.add(ai);\n            }\n        }\n\n        Observable<GroupedObservable<String, AppInfo>> o = Observable.from(list)\n        .groupBy(v -> v.date.format(DateTimeFormatter.ofPattern(\"MM\/yyyy\")));\n\n        Observable.concat(o)\n        .subscribe(System.out::println);\n    }\n}\n```\n"},{"date":"2016-03-21T15:46:46Z","author":"yanglw","text":"``` java\npublic class Concat {\n    public static class Student {\n        public String classId;\n        public String name;\n\n        @Override\n        public String toString() {\n            return \"Student{classId='\" + classId + \"', name='\" + name + \"'}\";\n        }\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Student> list = new ArrayList<>();\n        for (int i = 0; i < 20; i++) {\n            Student student = new Student();\n            student.classId = String.valueOf(i % 5);\n            student.name = String.valueOf(i);\n            list.add(student);\n        }\n\n        Observable<GroupedObservable<String, Student>> groupBy =\n                Observable.from(list)\n                          .groupBy(new Func1<Student, String>() {\n                              @Override\n                              public String call(Student student) {\n                                  return student.classId;\n                              }\n                          });\n\n        Observable.concat(groupBy)\n                  .subscribe(new Observer<Student>() {\n                      @Override\n                      public void onCompleted() {\n                          System.out.println(\"Completed\");\n                      }\n\n                      @Override\n                      public void onError(Throwable e) {\n                          System.out.println(\"Error\");\n                      }\n\n                      @Override\n                      public void onNext(Student student) {\n                          System.out.println(student);\n                      }\n                  });\n    }\n}\n```\n\nin RxJava 1.1.1,console print :\n\n```\nStudent{classId='0', name='0'}\nStudent{classId='0', name='5'}\nStudent{classId='0', name='10'}\nStudent{classId='0', name='15'}\n\nProcess finished with exit code 0\n```\n\nin RxJava 1.1.0,console print :\n\n```\nStudent{classId='0', name='0'}\nStudent{classId='0', name='5'}\nStudent{classId='0', name='10'}\nStudent{classId='0', name='15'}\nStudent{classId='1', name='1'}\nStudent{classId='1', name='6'}\nStudent{classId='1', name='11'}\nStudent{classId='1', name='16'}\nStudent{classId='2', name='2'}\nStudent{classId='2', name='7'}\nStudent{classId='2', name='12'}\nStudent{classId='2', name='17'}\nStudent{classId='3', name='3'}\nStudent{classId='3', name='8'}\nStudent{classId='3', name='13'}\nStudent{classId='3', name='18'}\nStudent{classId='4', name='4'}\nStudent{classId='4', name='9'}\nStudent{classId='4', name='14'}\nStudent{classId='4', name='19'}\nCompleted\n\nProcess finished with exit code 0\n```\n\n1.1.1 only print first group, and not call `onCompleted`.\n1.1.0 print all group.\n\nSystem OS : windows 10 64-bit\nJDK Version : Oracle JDK 1.7.0_80 64-bit\nGradle Version : 2.12\nIntelliJ IDEA Version : 14.1.6\n"},{"date":"2016-03-21T17:58:13Z","author":"akarnokd","text":"Yep, this is a bug. The groups don't complete until all groups have been emitted which doesn't happen because concat() prefetches only 2 groups of the 5. I overlooked this case and apparently the unit tests weren't checking for this.\n"},{"date":"2016-03-21T18:52:10Z","author":"akarnokd","text":"See the fix in #3787.\n"},{"date":"2016-03-22T02:39:30Z","author":"yanglw","text":":+1: \n"},{"date":"2016-04-02T23:15:25Z","author":"akarnokd","text":"Closing via #3787.\n"}],"opened_by":"lvzhitingzhou","reopen":false,"closed_on":"2016-04-02T23:15:25Z","description":"Here are the code I\u2018m using to test：\n\n``` java\n        final Observable<GroupedObservable<String, AppInfo>> groupBy = Observable.from(appInfoList)\n                .groupBy(appInfo -> {\n                    SimpleDateFormat sdf = new SimpleDateFormat(\"MM\/yyyy\");\n                    String groupedStr = sdf.format(new Date(appInfo.getLastUpdateTime()));\n                    return groupedStr;\n                });\n        Observable.concat(groupBy)\n                .subscribe(mSubscriber);\n```\n\nand the library is :\n\n```\n    compile 'io.reactivex:rxjava:1.1.1'\n    compile 'io.reactivex:rxandroid:1.1.0'`\n```\n\n I got this result which apparently is not correct,  I only got three results!:\n![device-2016-03-17-151005](https:\/\/cloud.githubusercontent.com\/assets\/10875078\/13838994\/e1f62658-ec52-11e5-93c7-f3c726af5bc8.png)\n\nbut it should be like this as shown on the Rxjava-essential-code.\n![image](https:\/\/cloud.githubusercontent.com\/assets\/10875078\/13839031\/283c1870-ec53-11e5-8da5-57add00c3b35.png)\n\nThis problem never occurs on Version 1.1.0.\n","id":"141500554","title":"concat can't display all the groupedBy observers on version 1.1.1","opened_on":"2016-03-17T07:16:38Z","closed_by":"akarnokd"},{"number":"3774","reopenOn":null,"comments":[{"date":"2016-05-05T09:58:35Z","author":"akarnokd","text":"See #3909 for the proposed javadoc changes.\n"},{"date":"2016-05-13T12:16:26Z","author":"akarnokd","text":"Fix merged in #3909.\n"}],"opened_by":"passsy","reopen":false,"closed_on":"2016-05-13T12:16:26Z","description":"``` java\npublic void testSingleErrorWithRetry() throws Exception {\n    TestSubscriber testSubscriber = new TestSubscriber();\n\n    final RuntimeException myError = new RuntimeException(\"my error\");\n    Single.error(myError)\n            .retryWhen(errorObservable -> Observable.empty())\n            .subscribe(testSubscriber);\n\n    testSubscriber.assertError(myError);\n}\n```\n\nThis test fails with the following exception:\n\n```\njava.lang.AssertionError: Exceptions differ; expected: java.lang.RuntimeException: my error, actual: java.util.NoSuchElementException: Observable emitted no items\n\n    at rx.observers.TestSubscriber.assertError(TestSubscriber.java:464)\n    at com.example.ExampleTest.testSingleErrorWithRetry(ExampleTest.java:77)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    ... 17 more\nCaused by: java.util.NoSuchElementException: Observable emitted no items\n    at rx.internal.operators.OnSubscribeSingle$1.onCompleted(OnSubscribeSingle.java:59)\n    at rx.internal.operators.OnSubscribeRedo$4$1.onCompleted(OnSubscribeRedo.java:326)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1123)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1120)\n    at rx.Observable.unsafeSubscribe(Observable.java:8314)\n    at rx.internal.operators.OnSubscribeRedo$4.call(OnSubscribeRedo.java:323)\n    at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.enqueue(TrampolineScheduler.java:80)\n    at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.schedule(TrampolineScheduler.java:59)\n    at rx.internal.operators.OnSubscribeRedo.call(OnSubscribeRedo.java:320)\n    at rx.internal.operators.OnSubscribeRedo.call(OnSubscribeRedo.java:55)\n    at rx.Observable.unsafeSubscribe(Observable.java:8314)\n    at rx.internal.operators.OnSubscribeSingle.call(OnSubscribeSingle.java:83)\n    at rx.internal.operators.OnSubscribeSingle.call(OnSubscribeSingle.java:29)\n    at rx.Single$1.call(Single.java:93)\n    at rx.Single$1.call(Single.java:73)\n    at rx.Single.subscribe(Single.java:1665)\n    at com.example.ExampleTest.testSingleErrorWithRetry(ExampleTest.java:67)\n    ... 22 more\n```\n\nThis is the correct behavior as written in the documentation \n\n> If that Observable calls `onComplete` or `onError` then retry will call onCompleted or onError on the child subscription.\n\nThe child subscription here is the subscriber in `OnSubscribeSingle#call()` which converts an `Observable` to a `Single`. It throws this error in `onCompleted`.\n\n``` java\n            @Override\n            public void onCompleted() {\n                if (emittedTooMany) {\n                    \/\/ Don't need to do anything here since we already sent an error downstream\n                } else {\n                    if (itemEmitted) {\n                        child.onSuccess(emission);\n                    } else {\n                        child.onError(new NoSuchElementException(\"Observable emitted no items\"));\n                    }\n                }\n            }\n```\n\nThe behavior should be changed. The real child subscription before the `Observable -> Single` conversion is a `SingleSubscriber` which doesn't have the method `onCompleted()`. Better `onError` is called instead with the latest emitted error instead of the current `NoSuchElementException`.\n\nThe docs should be updated to: \n\n> If that Observable calls `onComplete` or `onError` then retry will call `onError` on the child subscription.\n","id":"141361745","title":"Single#retryWhen allows Observable#complete() and throws","opened_on":"2016-03-16T18:30:02Z","closed_by":"akarnokd"},{"number":"3768","reopenOn":null,"comments":[{"date":"2016-03-15T01:09:45Z","author":"artem-zinnatullin","text":":+1: for changes, not sure about test\n"},{"date":"2016-03-15T11:18:41Z","author":"artem-zinnatullin","text":":+1:\n"},{"date":"2016-03-15T23:53:16Z","author":"stevegury","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-03-16T13:50:25Z","description":"This fixes `observeOn` not completing immediately if the downstream requested exactly the remaining amount. The original version required a new request from downstream to trigger the delivery of the terminal event.\n\nThis also fixes the rare failure in `testNoMoreRequestsAfterUnsubscribe` because the unsubscription is now checked in-sequence and doesn't trigger the unwanted replenishment request.\n","id":"140837806","title":"1.x: observeOn - fix in-sequence termination\/unsubscription","opened_on":"2016-03-15T00:49:00Z","closed_by":"akarnokd"},{"number":"3760","reopenOn":null,"comments":[{"date":"2016-03-15T22:12:25Z","author":"stevegury","text":"I have trouble understanding how this solve the problem, could you please elaborate?\nThe only thing I see that we could do to force the FIFO order is to cap the thread number to 1, right?\n"},{"date":"2016-03-15T22:18:36Z","author":"akarnokd","text":"Yes, ExecutorScheduler's worker needs a helper ScheduledExecutorService with a single thread only. But we don't want all ExecutorSchedulers to wait in a single thread for their time to run. This change, similar to how computation scheduler works, hands out single hreaded ScheduledExecutorServices on demand.\n"},{"date":"2016-03-16T17:41:28Z","author":"zsxwing","text":"Nice catch.\n\n> However, there is still the problem when the programmer uses a multi-threaded ScheduledExecutorService with Schedulers.from() when the same issue comes back. A solution to that problem would be to always use the new GenericScheduledExecutorService for delaying timed tasks.\n\nI vote for `always use the new GenericScheduledExecutorService for delaying timed tasks.`. Correctness is more important than performance. Moreover, when people use `schedule(action, time)`, they usually don't want the codes to run as fast as possible, so the performance lost doesn't really matter.\n"},{"date":"2016-03-16T19:45:07Z","author":"stevegury","text":"Agree with @zsxwing that correctness is more important than performance.\n"},{"date":"2016-03-16T21:34:01Z","author":"akarnokd","text":"Right, I'll fix them shortly.\n"},{"date":"2016-03-16T22:31:37Z","author":"akarnokd","text":"Updated.\n"},{"date":"2016-03-16T23:43:33Z","author":"zsxwing","text":":+1: \n"},{"date":"2016-03-17T17:56:39Z","author":"stevegury","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-03-17T17:56:43Z","description":"This PR relates to the failure of `errorThrownIssue1685`.\n\nThe underlying problem was with the `GenericScheduledExecutorService`. By being multi-threaded, tasks scheduled from the same thread one after the other may get reordered because different worker threads inside the pool could pick them up at the same time. In this case, there is no guarantee they keep their FIFO order.\n\n_(I currently have no idea how one can use trampolining for this case; subsequent tasks may have any relative delays in respect to each other.)_\n\nThe solution creates N single threaded `ScheduledExecutorService`s and getInstance() hands one of them out. In turn `ExecutorService` takes one in its worker upfront.\n\nHowever, there is still the problem when the programmer uses a multi-threaded `ScheduledExecutorService` with `Schedulers.from()` when the same issue comes back. A solution to that problem would be to always use the new `GenericScheduledExecutorService` for delaying timed tasks.\n","id":"140690996","title":"1.x: fix ExecutorScheduler and GenericScheduledExecutorService reorder bug","opened_on":"2016-03-14T14:35:37Z","closed_by":"stevegury"},{"number":"3746","reopenOn":null,"comments":[{"date":"2016-03-10T23:06:24Z","author":"akarnokd","text":"There is a bug in the `mapNotification` operator used by that particular `flatMap` overload that's causing the `MissingBackpressureException`. The fix will be part of 1.1.2, no relase date yet.\n"},{"date":"2016-03-11T15:54:34Z","author":"Dirk-c-Walter","text":"I see, thanks for letting me know.\n"}],"opened_by":"Dirk-c-Walter","reopen":false,"closed_on":"2016-03-11T15:54:34Z","description":"So I'm getting MissingBackpressureExceptions, and I have been trying to litter my code with onBackPressureBuffer calls, which cuts down on their numbers but that doesn't seem like an efficient or streamlined solution. On the other hand a stacktrace like the following tells me nothing about where the problem is.\n\n```\nCaused by: rx.exceptions.MissingBackpressureException: null\nat rx.internal.operators.OperatorMapNotification$SingleEmitter.offer(OperatorMapNotification.java:165)\nat rx.internal.operators.OperatorMapNotification$MapNotificationSubscriber.onNext(OperatorMapNotification.java:98)\nat rx.internal.operators.OnSubscribeFromIterable$IterableProducer.slowpath(OnSubscribeFromIterable.java:97)\nat rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:73)\nat rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\nat rx.internal.operators.OperatorMapNotification$MapNotificationSubscriber.setProducer(OperatorMapNotification.java:74)\nat rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)\nat rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\nat rx.Observable$2.call(Observable.java:162)\nat rx.Observable$2.call(Observable.java:154)\nat rx.Observable$2.call(Observable.java:162)\nat rx.Observable$2.call(Observable.java:154)\nat rx.Observable$2.call(Observable.java:162)\nat rx.Observable$2.call(Observable.java:154)\nat rx.Observable$2.call(Observable.java:162)\nat rx.Observable$2.call(Observable.java:154)\nat rx.Observable$2.call(Observable.java:162)\nat rx.Observable$2.call(Observable.java:154)\nat rx.Observable$2.call(Observable.java:162)\nat rx.Observable$2.call(Observable.java:154)\nat rx.Observable.subscribe(Observable.java:8407) \nat rx.Observable.subscribe(Observable.java:8374)\nat rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:433)\n... 8 common frames omitted\n```\n\nIf there was some indication of exactly where in the chain the problem was that would be helpfull. Instead I just know there is an issue somewhere in my stream, and I have not been able to narrow it down. Are there any techniques or teicks that help with that?\n\nJust in case it helps here is the code generating that exception, though I am more interested in being able to solve the general case.\n\n```\n`\/\/'final Collection<String> ids' contains ~500 string ids\n\nrx.Observable\n    .from(ids)\n    .flatMap(\n        (Fnuc1<String, Observable<LoaderValue<V>>>) id -> fetchFromCouchbase(id),\n        (Func1<Throwable, Observable<LoaderValue<V>>>) err -> (Observable<LoaderValue<V>>) handleError(err),\n        () -> (Observable<LoaderValue<V>>) handleCompletion(),\n        100\n    )\n    .timeout(10000, MILLISECONDS) \n    .onBackpressureBuffer(1000, () -> logOverflow())\n    .toList()\n    .toBlocking().single();\n\n\n  private Observable<LoaderValue<V>> fetchFromCouchbase(String id) {\n    if(id == null) {\n    return Observable.<LoaderValue<V>>empty().onBackpressureDrop();\n    }\n    return couchbaseBucket.async().get(id, conf.getCouchbaseDocumentImplClass())\n        .cacheWithInitialCapacity(1)\n        .singleOrDefault(null)\n        .map((Func1<Document, LoaderValue<V>>) val -> transform(id, val));\n  }\n```\n\nhandleCompletion and logOverflow just log that the event happened, handleCompletion returns an empty Observable.\nhandleError logs the error and returns a sentinel value indicating an error occurred.`\n","id":"140033189","title":"How to track down a MissingBackpressureException?","opened_on":"2016-03-10T22:56:06Z","closed_by":"Dirk-c-Walter"},{"number":"3727","reopenOn":null,"comments":[{"date":"2016-02-23T22:46:29Z","author":"akarnokd","text":"2.x is not affected because it does a full queue-drain where the initial value is in the queue already and requests are forwarded to the upstream as they are.\n\n:+1:\n"},{"date":"2016-02-23T23:06:37Z","author":"davidmoten","text":"> 2.x is not affected\n\nThanks @akarnokd \n"},{"date":"2016-02-24T17:46:12Z","author":"stevegury","text":":+1:\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-02-24T17:46:17Z","description":"Changes in 1.1.1. for the `scan` operator introduced a bug in requesting where when the initial request was for max value the `scan` operator requested one less than that value of upstream (which affects fast-path producers).\n\nI believe this bug only affects 1.1.1 (haven't looked at 2.x).\n\nThis PR includes a test that failed on the original code.\n","id":"135886369","title":"scan should pass upstream a request of Long.MAX_VALUE","opened_on":"2016-02-23T22:28:39Z","closed_by":"stevegury"},{"number":"3707","reopenOn":null,"comments":[{"date":"2016-02-15T00:20:22Z","author":"akarnokd","text":"Updated.\n"},{"date":"2016-02-15T00:34:58Z","author":"zsxwing","text":"I see. :+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-15T09:21:25Z","description":"The empty and lambda-based `Completable.subscribe()` returns a `Subscription` whose `isUnsubscribed` should be consistent with the rest of the reactive objects by returning true if the sequence terminated (not just when one truly cancelled it).\n","id":"133529913","title":"1.x: make Completable.subscribe() report isUnsubscribed consistently","opened_on":"2016-02-14T10:48:48Z","closed_by":"akarnokd"},{"number":"3706","reopenOn":null,"comments":[{"date":"2016-02-14T10:37:04Z","author":"akarnokd","text":"`Completable` follows the Reactive-Streams lifecycle where if one receives a terminal event, the associated `Subscription` should be considered cancelled. Those `Completable` operators which hold onto resources should do exactly this so there is no need to call `unsubscribe()`. `CompletableSubscriber` also doesn't have an `add(Subscription)` method so you can't just associate it with resources which would require cleanup like with `rx.Subscriber`.\n\nOtherwise, this example of yours should pass:\n\n``` java\nPublishSubject<String> stringSubject = PublishSubject.create();\nCompletable completable = stringSubject.toCompletable();\nSubscription completableSubscription = completable.subscribe();\nstringSubject.onCompleted();\nassertTrue(completableSubscription.isUnsubscribed());    \/\/ This fails\n```\n\nI forgot about this method, I'll post a PR to make it pass.\n"},{"date":"2016-02-14T11:22:56Z","author":"hzsweers","text":"Ah good to hear! Thanks for the quick response and glad it's a bug and not a feature in that regard :)\n"},{"date":"2016-02-15T03:52:24Z","author":"hzsweers","text":"Should this be labeled as a bug now for the `Completable` issue?\n"},{"date":"2016-02-15T09:22:11Z","author":"akarnokd","text":"Closing via #3707\n"},{"date":"2016-02-15T09:28:09Z","author":"hzsweers","text":":+1: \n"}],"opened_by":"hzsweers","reopen":false,"closed_on":"2016-02-15T09:22:11Z","description":"I've come across a couple of differences in the subscription behavior of `Observable`, `Single`, and `Completable` that I was hoping I could get clarification on or bring up for discussion. The examples specifically revolve around converting an observable to those types and how its events are propagated.\n\nIn a normal `Observable`, an `onCompleted()` event automatically unsubscribes.\n\n``` java\nPublishSubject<String> stringSubject = PublishSubject.create();\nObservable observable = stringSubject.asObservable();\nSubscription observableSubscription = observable.subscribe();\nstringSubject.onCompleted();\nassertTrue(observableSubscription.isUnsubscribed());\n```\n\nThis still holds true in `Single`, but with the added caveat that an `onCompleted` event actually propagates to `onError()` if no event has been emitted prior for `onSuccess()`. This would be sort of ok considering the `Single` contract, but things get a little muddled in the sense that `onSuccess()` does _not_ actually unsubscribe despite being considered a terminal event (or so I thought). What this means is that `onCompleted()` has to be called manually after `onSuccess()`\n\n``` java\nPublishSubject<String> stringSubject = PublishSubject.create();\nSingle single = stringSubject.toSingle();\nSubscription singleSubscription = single.subscribe();\nstringSubject.onNext(\"This is necessary\");\nstringSubject.onCompleted();    \/\/ This is necessary too\nassertTrue(singleSubscription.isUnsubscribed());\n```\n\nThings get more confusing in `Completable`, which offers no auto-unsubscribe after `onComplete()` is called as far as I can tell.\n\n``` java\nPublishSubject<String> stringSubject = PublishSubject.create();\nCompletable completable = stringSubject.toCompletable();\nSubscription completableSubscription = completable.subscribe();\nstringSubject.onCompleted();\nassertTrue(completableSubscription.isUnsubscribed());    \/\/ This fails\n```\n\nThis would imply that you _always_ need to save the subscription and manually unsubscribe in `onComplete()` or `doOnComplete()`.\n\n``` java\nPublishSubject<String> stringSubject = PublishSubject.create();\nCompletable completable = stringSubject.toCompletable();\nfinal CompositeSubscription set = new CompositeSubscription();\nset.add(completable\n        .doOnComplete(new Action0() {\n            @Override\n            public void call() {\n                \/\/ Kludge\n                set.unsubscribe();\n            }\n        })\n        .subscribe());\nstringSubject.onCompleted();\nassertTrue(set.isUnsubscribed());    \/\/ Now it works\n```\n\nI'm not sure if this behavior still holds true when dealing with \"pure\" `Single` and `Completable` subscriptions, I can investigate more if need be.\n\nIt does seem inconsistent to me, or at the very least prone to causing passive leaks or unexpected behavior due to subscriptions living on past \"terminal\" events. Maybe some clarification is needed on what constitutes a \"terminal\" event in `Single` and `Completable`. Would love to get some more insight from the collaborators that have worked on these.\n","id":"133527222","title":"Inconsistent behavior between Observable, Single, and Completable subscriptions when propagating from a source Observable.","opened_on":"2016-02-14T10:10:47Z","closed_by":"akarnokd"},{"number":"3702","reopenOn":null,"comments":[{"date":"2016-02-15T23:53:04Z","author":"zsxwing","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-19T09:49:02Z","description":"The previous algorithm used a 2 element queue but it was possible the drain loop got captured and the queue wasn't enough, causing `MissingBackpressureException`.\n\nThe new algorithm uses the requested field's most significant bit to indicate a completed state. If the terminal events reach it with non-zero request or a post-terminal request finds a zero request amount, the last item is emitted.\n\nIn addition, the upstream's producer may arrive after the first request thus the class includes the usual arbitration logic inlined. If the upstream doesn't set a `Producer` but just emits values, the production\/backpressure checks are bypassed.\n\n```\nrx.internal.operators.OperatorFlatMapTest > testFlatMapTransformsMaxConcurrentNormalLoop FAILED\n    java.lang.AssertionError: Unexpected onError events: 1\n        at rx.observers.TestSubscriber.assertNoErrors(TestSubscriber.java:309)\n        at rx.internal.operators.OperatorFlatMapTest.testFlatMapTransformsMaxConcurrentNormal(OperatorFlatMapTest.java:419)\n        at rx.internal.operators.OperatorFlatMapTest.testFlatMapTransformsMaxConcurrentNormalLoop(OperatorFlatMapTest.java:395)\n        Caused by:\n        rx.exceptions.MissingBackpressureException\n            at rx.internal.operators.OperatorMapNotification$SingleEmitter.offerAndComplete(OperatorMapNotification.java:173)\n            at rx.internal.operators.OperatorMapNotification$MapNotificationSubscriber.onCompleted(OperatorMapNotification.java:80)\n            at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.slowpath(OnSubscribeFromIterable.java:101)\n            at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:73)\n            at rx.internal.producers.ProducerArbiter.emitLoop(ProducerArbiter.java:186)\n            at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:129)\n            at rx.internal.operators.OperatorMapNotification$MapNotificationSubscriber.setProducer(OperatorMapNotification.java:74)\n            at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)\n            at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\n            at rx.Observable$2.call(Observable.java:162)\n            at rx.Observable$2.call(Observable.java:154)\n            at rx.Observable$2.call(Observable.java:162)\n            at rx.Observable$2.call(Observable.java:154)\n            at rx.Observable.subscribe(Observable.java:8426)\n            at rx.Observable.subscribe(Observable.java:8393)\n            at rx.internal.operators.OperatorFlatMapTest.testFlatMapTransformsMaxConcurrentNormal(OperatorFlatMapTest.java:416)\n            ... 1 more\n```\n","id":"133349660","title":"1.x: fix mapNotification's last item backpressure handling","opened_on":"2016-02-12T21:39:25Z","closed_by":"akarnokd"},{"number":"3697","reopenOn":null,"comments":[{"date":"2016-02-12T19:52:06Z","author":"stevegury","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-12T19:57:08Z","description":"Schedulers.computation()\n\nWhen one installs a scheduler hook which makes Schedulers.computation() return a different scheduler, the constant function in ScalarSynchronousObservable crashes if that hasn't been initialized.\n","id":"133110268","title":"1.x: fix ScalarSynchronousObservable expects EventLoopsScheduler from","opened_on":"2016-02-11T22:59:01Z","closed_by":"akarnokd"},{"number":"3692","reopenOn":null,"comments":[{"date":"2016-02-11T00:22:40Z","author":"zsxwing","text":":+1: \n"},{"date":"2016-02-11T00:59:52Z","author":"stevegury","text":":+1: \n"},{"date":"2016-02-11T05:33:09Z","author":"zsxwing","text":"Although nebula gradle plugin requires Java 7, I'm still wondering if we can setup a build to compile codes with Java 6 to avoid such issue. E.g., I can just use `find src\/main\/java\/* -name *.java | xargs javac` to compile them using Java 6 and see if any error.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-11T05:28:35Z","description":"The upgraded gradle switched my IDE to use a JDK 6 library I have installed all along and these popped up immediately.\n","id":"132846151","title":"1.x: Fix Completable using JDK 7 suppressed exceptions feature","opened_on":"2016-02-10T23:15:25Z","closed_by":"zsxwing"},{"number":"3689","reopenOn":null,"comments":[{"date":"2016-02-09T18:42:07Z","author":"akarnokd","text":"There was a test failure in BackpressureTests.testMergeAsync, run before any of the changes of this PR and shouldn't have any effect. Overloaded servers?\n"},{"date":"2016-02-09T20:19:10Z","author":"stevegury","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-09T20:21:40Z","description":"The operators didn't honor backpressure when they switched over to the other Observable.\n\nThis PR also includes the fix #3685.\n","id":"132493776","title":"1.x: unified onErrorX and onExceptionResumeNext and fixed backpressure","opened_on":"2016-02-09T18:25:24Z","closed_by":"akarnokd"},{"number":"3688","reopenOn":null,"comments":[{"date":"2016-02-10T04:15:54Z","author":"artem-zinnatullin","text":"Few small things, otherwise lgtm :+1:\n"},{"date":"2016-02-10T08:30:02Z","author":"akarnokd","text":"Updated.\n"},{"date":"2016-02-10T19:16:47Z","author":"stevegury","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-10T19:17:27Z","description":"Reported in #3687.\n\nBy the way, I see several other small problems with zip: it is implemented as an `Operator` and even though one can know the number of sources upfront, this indirection hides the fact. In addition, it uses SpMc queue but could just use Spsc because there is only one drain thread at a time.\n","id":"132439790","title":"1.x: Fix zip() - observer array becoming visible too early and causing NPE","opened_on":"2016-02-09T14:52:26Z","closed_by":"akarnokd"},{"number":"3687","reopenOn":null,"comments":[{"date":"2016-02-09T14:35:55Z","author":"akarnokd","text":"What RxJava version are you using?\n"},{"date":"2016-02-09T14:38:08Z","author":"jkettmann","text":"I'm using version 1.1.0\n"},{"date":"2016-02-09T14:38:44Z","author":"akarnokd","text":"Could be a missing barrier on line 207 or somewhere else, or a bug in that particular runtime. I'll reorganize things in zip so this doesn't happen.\n"},{"date":"2016-02-09T14:39:51Z","author":"jkettmann","text":"Great. Thanks a lot!\n"},{"date":"2016-02-09T14:52:36Z","author":"akarnokd","text":"See #3688\n"},{"date":"2016-03-14T01:08:00Z","author":"akarnokd","text":"Closing via #3688.\n"}],"opened_by":"jkettmann","reopen":false,"closed_on":"2016-03-14T01:08:00Z","description":"I get crashreports caused by a NullPointerException in OperatorZip's tick() method. You find the stacktrace and my code, causing the problem below.\n\nThe responsible line in tick() method is\n\n``` java\nRxRingBuffer buffer = ((InnerSubscriber) observers[i]).items;\n```\n\nwhere observers[i] seems to be null. \n\nThe app crashes only rarely on one device, which I don't have acces to (Samsung S3, Android 4.3).  The reason seems to be, that  the property `missedProducer` in `ProducerArbiter` must be set, which is never the case on my devices.\n\nWe're not in production yet, so I can not tell how many other devices will show this error. \n\nStacktrace:\n\n```\n0 java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n1   at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)\n2   at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:98)\n3   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\n4   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\n5   at java.lang.Thread.run(Thread.java:841)\n6 Caused by: java.lang.NullPointerException\n7   at rx.internal.operators.OperatorZip$Zip.tick(OperatorZip.java:237)\n8   at rx.internal.operators.OperatorZip$ZipProducer.request(OperatorZip.java:175)\n9   at rx.internal.producers.ProducerArbiter.emitLoop(ProducerArbiter.java:181)\n10  at rx.internal.producers.ProducerArbiter.request(ProducerArbiter.java:69)\n11  at rx.internal.operators.OperatorConcat$ConcatSubscriber.requestFromChild(OperatorConcat.java:118)\n12  at rx.internal.operators.OperatorConcat$ConcatSubscriber.access$100(OperatorConcat.java:79)\n13  at rx.internal.operators.OperatorConcat$ConcatProducer.request(OperatorConcat.java:74)\n14  at rx.internal.producers.ProducerArbiter.request(ProducerArbiter.java:66)\n15  at rx.internal.operators.OperatorSubscribeOn$1$1$1$1$1.call(OperatorSubscribeOn.java:94)\n16  at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n17  ... 4 more\n```\n\nThis is the code causing the problem: Get `Observable<List<ContainerEntity>>`, map each container entity to my actual container model. flatmap is used to split my list into single items.\n\n``` java\ngetContainerEntities()\n.flatMap(containerEntities ->\n            Observable.from(containerEntities))\n    .concatMap(containerEntity ->\n            mDashboardMapper.mapContainerEntity(containerEntity))\n    .onErrorResumeNext(throwable -> {\n        Log.e(TAG, throwable);\n        return Observable.empty();\n    });\n```\n","id":"132433697","title":"NullPointerException on OperatorZip","opened_on":"2016-02-09T14:31:16Z","closed_by":"akarnokd"},{"number":"3685","reopenOn":null,"comments":[{"date":"2016-02-09T17:27:04Z","author":"benkomalo","text":"There are similar patterns in the other `onError*` operators, namely `OperatorOnErrorResumeNextViaObservable` and `OperatorOnErrorReturn` - do those need changing as well?\n"},{"date":"2016-02-09T17:32:25Z","author":"akarnokd","text":"Yes, I'll update this PR.\n"},{"date":"2016-02-09T17:39:25Z","author":"akarnokd","text":"Updated, although all of these classes have backpressure bugs in them.\n"},{"date":"2016-02-09T18:25:42Z","author":"akarnokd","text":"Replaced by #3689\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-09T18:25:42Z","description":"When the operator switches to the other, that counts as a handled error. \n\nSee also #3347.\n","id":"132423687","title":"1.x: onErrorResumeNext(Func1) should not call plugin handler there","opened_on":"2016-02-09T13:49:18Z","closed_by":"akarnokd"},{"number":"3678","reopenOn":null,"comments":[{"date":"2016-03-13T23:13:12Z","author":"akarnokd","text":"Ping @stevegury @stealthcode @zsxwing \n"},{"date":"2016-03-14T07:51:49Z","author":"egor-n","text":"@iNoles I think that's GitHub's fault. You can see [here](https:\/\/raw.githubusercontent.com\/akarnokd\/RxJava\/e9c6d49b0bb816c40483b4df2a580e5e1ad80c25\/src\/main\/java\/rx\/Observable.java) that the line is fine. \n"},{"date":"2016-03-17T21:33:50Z","author":"akarnokd","text":"Fixed all 3 sites of `new ArrayList`\n"},{"date":"2016-03-18T05:06:35Z","author":"stevegury","text":":+1: \n"},{"date":"2016-03-18T07:48:38Z","author":"hzsweers","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-03-18T07:50:29Z","description":"This PR fixes the backpressure behavior of the counted `buffer` and `window` operators and consists of several changes.\n\nThe main issue lies when `count > skip` in the operators, yielding overlapping buffers\/windows. \n\nFor `buffer`, when the upstream completed, the logic emitted all remaining partial buffers even if there was no request for new buffers, which can result in `MissingBackpressureException` somewhere. The proper handling of the final buffers required a new backpressure management algorithm which is now part of the `BackpressureUtils` class and consists of two new methods: `postCompleteDone` called from onComplete to take over the emission of queued values and `postCompleteRequest` which manages requests before and after the completed state.\n\nFor `window`, the new window opened was emitted regardless of requests which was common due to request-amplification (i.e., requesting n windows results in requesting `count + skip * (n - 1)` elements at first (then `skip * n` later) which opens `ceil(count \/ skip)` windows upfront. To avoid the overflow, the individual windows have to go through the usual queue\/drain logic as well. I've also updated the Javadoc to reflect the backpressure behavior along with parameter validation.\n\nIn addition, the window case didn't manage cancellation properly. When the outer observable is unsubscribed, the inner subscribers may be still going and thus cancelling the upstream would stop\/hang the inner windows. Instead, the open window count is tracked (also counting the outer as 1 window) and when all get unsubscribed (i.e., count reaches zero), the upstream is unsubscribed. To accomplish this, the `UnicastSubject` had to be retrofitted with a new optional callback `Action0` which gets called at most once whenever either `onError` or `onCompleted` is called or when the single `Subscriber` unsubscribes.\n\nA secondary issue was with the `TestSubscriber`'s initial request; some upstream operators could get triggered with `Long.MAX_VALUE` despite the initial request amount was set. This PR changes it to be set at construction time instead of in `onStart`.\n","id":"132266202","title":"1.x: fix counted buffer and window backpressure","opened_on":"2016-02-08T21:50:30Z","closed_by":"akarnokd"},{"number":"3675","reopenOn":null,"comments":[{"date":"2016-02-05T20:22:12Z","author":"zsxwing","text":":+1: \n"},{"date":"2016-02-05T20:28:01Z","author":"JakeWharton","text":"Why not IAE on negative values for the operator? This seems like it could hide errors in math-based `take` values.\n"},{"date":"2016-02-05T20:30:23Z","author":"akarnokd","text":"I don't know, could be some historical reasons from the early days of RxJava.\n"},{"date":"2016-02-05T21:23:43Z","author":"zsxwing","text":"Just checked Rx.Net and RxJS. Both them throw an error for negative values:\n\nhttps:\/\/github.com\/Reactive-Extensions\/Rx.NET\/blob\/859e6159cb07be67fd36b18c2ae2b9a62979cb6d\/Rx.NET\/Source\/System.Reactive.Linq\/Reactive\/Linq\/Observable.StandardSequenceOperators.cs#L1279\nhttps:\/\/github.com\/Reactive-Extensions\/RxJS\/blob\/master\/src\/modular\/observable\/take.js#L47\n\nSo I suggest let's throw IAE.\n"},{"date":"2016-02-05T21:28:10Z","author":"zsxwing","text":"Could you also check `skip`?\n"},{"date":"2016-02-05T22:04:13Z","author":"akarnokd","text":"skip(0) and skip(-1) just returns the source without applying the operator to it.\n\nFor 2.x, definitely, but I'm not certain about 1.x, sounds like an API change.\n"},{"date":"2016-02-05T22:15:15Z","author":"zsxwing","text":"cc @ReactiveX\/rxjava-committers thoughts about this?\n"},{"date":"2016-02-05T23:54:34Z","author":"stealthcode","text":"For invalid inputs we've typically blown up as early as possible. \n"},{"date":"2016-02-06T00:28:26Z","author":"artem-zinnatullin","text":"I think we need to throw exception. We can highlight this in changelog and call it a bug fix because it actually is, I guess. \n"},{"date":"2016-02-06T00:36:08Z","author":"stevegury","text":"I vote for throwing IAE.\nI don't consider it's an API change, more a bug fix.\n"},{"date":"2016-02-06T08:20:53Z","author":"akarnokd","text":"Changed the fix to throw.\n"},{"date":"2016-02-06T12:37:41Z","author":"vanniktech","text":"Any reason for not using [`ExpectedException`](http:\/\/junit.org\/javadoc\/latest\/org\/junit\/rules\/ExpectedException.html), that way the exception message can also be verified plus it can be nailed down where the Exception is thrown (the moment you call `take(-1)`).\n"},{"date":"2016-02-06T12:55:29Z","author":"akarnokd","text":"Because it is irrelevant in this case, what matters is the type IAE.\n"},{"date":"2016-02-06T16:01:43Z","author":"stevegury","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-06T16:03:04Z","description":"Originally, only 0 was checked which resulted in `onCompleted()` but negative values weren't. When the downstream requested, c became -1 and was requested from the source. `range` ignores negative requests but other sources may throw IAE in that case.\n\nWith the fix, the operator will throw IAE in assembly time.\n","id":"131745647","title":"1.x: fix take(-1) not completing","opened_on":"2016-02-05T20:19:30Z","closed_by":"akarnokd"},{"number":"3673","reopenOn":null,"comments":[{"date":"2016-03-14T01:07:17Z","author":"akarnokd","text":"Closing via #3681\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-03-14T01:07:17Z","description":"The following unit test fails because the sequence doesn't complete:\n\n``` java\n    public void publishConcat() {\n        TestSubscriber<Integer> ts = TestSubscriber.create();\n\n        Observable.range(1, 3)\n        .publish(o -> o.take(5).concatWith(o.takeLast(5)))\n        .subscribe(ts);\n\n        ts.assertValues(1, 2, 3);\n        ts.assertNoErrors();\n        ts.assertCompleted();\n    }\n```\n\n The problem lies in operator `publish()`. When a published source completes, the operator switches back to a ready state where more subscribers can be subscribed to it and they all receive values from the upstream on the next `connect()`. Otherwise, it wouldn't be possible to observe the sequence again from the beginning by more than one subscriber.\n\nIn the test, the source is sort and by the time take(5) completes and makes `concat` subscribe to `o`, the published source, the underlying OperatorPublish is already in the ready state and awaits another connect, which will never arrive, thus leaving the second takeLast hang forever.\n\nThis anomaly is there since the rewrite of `publish()` to support backpressure, namely when it doubles as a multicast source. Previously, a PublishSubject was the mediator between the upstream and the use places in the lambda. PublishSubject, when completed will complete any latecommer subscriber such as the one by `takeLast()` thus the unit test passes.\n\nThe solution would be to write a request-coordinating internal PublishSubject variant and dispatch upstream values over it in the multicast scenario.\n\n(Note that unbounded `replay` has no such problem because it stays in the completed state until the next `connect()` call, thus latecommers still receive the orignal sequence. Because it buffers all values, there is no penalty for latecommers after a new `connect()` call.)\n","id":"131733652","title":"publish(Func1) may leave operators hang","opened_on":"2016-02-05T19:33:40Z","closed_by":"akarnokd"},{"number":"3662","reopenOn":null,"comments":[{"date":"2016-02-02T03:21:26Z","author":"davidmoten","text":"Good find thanks @akarnokd\n"},{"date":"2016-02-02T08:57:43Z","author":"akarnokd","text":"Done.\n"},{"date":"2016-02-02T22:59:22Z","author":"artem-zinnatullin","text":":+1: \n"},{"date":"2016-02-03T05:24:25Z","author":"zsxwing","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-03T05:26:04Z","description":"When the operator is assembled and it sets the producer on the child, if the child doesn't request until the assembly is complete, `doOnRequest` requested the default Long.MAX_VALUE.\n","id":"130523926","title":"1.x: fix doOnRequest premature requesting.","opened_on":"2016-02-01T23:57:00Z","closed_by":"zsxwing"},{"number":"3661","reopenOn":null,"comments":[{"date":"2016-02-01T21:36:21Z","author":"JakeWharton","text":"Thanks!\n"},{"date":"2016-02-03T21:18:22Z","author":"stevegury","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-03T21:38:07Z","description":"This PR is a backport of the 2.x `combineLatest` with `null` support and let's the programmer combine more than 128 sources at once. Note that 2.x supports manual sizing of the prefetch buffer and allows delaying the exceptions to the last moment; I kept these in case such features are required by 1.x some day.\n\nThe original had this 128 limit due to using a single and non-parametric RxRingBuffer to store values from sources. In addition, the original algorithm divided downstream requests among the sources with some strange logic in order to keep them running and not overflow the buffer.\n\nThis PR uses an unbounded-linked SPSC queue which can now hold as many elements as there are sources times the default ring buffer size (this is not preallocated and grows\/shrinks as necessary).\n\nThe algorithm stores the current latest array and the source subscriber in the queue in pairs so when that particular row is emitted to downstream, that source subscriber gets the request() replenishment call that generated the row.\n\nIn addition, I've added an Iterator overload from #3660 as well.\n","id":"130491448","title":"1.x: CombineLatest now supports any number of sources","opened_on":"2016-02-01T21:35:37Z","closed_by":"akarnokd"},{"number":"3658","reopenOn":null,"comments":[{"date":"2016-02-02T08:54:37Z","author":"akarnokd","text":"Restored original completion-unsubscription order + verification\n"},{"date":"2016-02-02T18:31:25Z","author":"zsxwing","text":":+1: \n"},{"date":"2016-02-02T19:09:19Z","author":"artem-zinnatullin","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-02T21:00:43Z","description":"This PR fixes 2 bugs with `sample`\n- Termination of the main or sampler subscriber unsubscribed the child subscriber which is not allowed.\n- The sampler wrapped the child subscriber and thus it allowed setting a producer on the child (thus sampling based on request with some sources).\n\nIn addition, #3657 wants to emit the very last item on completion to which I marked the required changes in comments (to be uncommented in a separate PR if needed).\n","id":"130114191","title":"1.x: fix unsubscription and producer issues in sample(other)","opened_on":"2016-01-31T11:05:09Z","closed_by":"akarnokd"},{"number":"3653","reopenOn":null,"comments":[{"date":"2016-01-29T02:05:26Z","author":"artem-zinnatullin","text":":+1: \n"},{"date":"2016-01-31T01:00:17Z","author":"zsxwing","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-01-31T10:08:40Z","description":"Reported on the rxjava discussion group.\n\nSample has to disconnect itself from the Producer chain and request Long.MAX_VALUE instead of whatever the downstream requests.\n","id":"129486757","title":"1.x: fix sample(Observable) not requesting Long.MAX_VALUE","opened_on":"2016-01-28T15:39:21Z","closed_by":"akarnokd"},{"number":"3645","reopenOn":null,"comments":[{"date":"2016-01-25T22:42:15Z","author":"zsxwing","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-01-25T22:43:10Z","description":"The OnSubscribeAmb shared the choice variable among all of its subscribers which prevented reusing the same Observable.\n","id":"128651606","title":"1.x: fix Amb sharing the choice among all subscribers","opened_on":"2016-01-25T22:00:25Z","closed_by":"akarnokd"},{"number":"3644","reopenOn":null,"comments":[{"date":"2016-01-25T22:09:39Z","author":"artem-zinnatullin","text":":+1:\n"},{"date":"2016-01-25T22:31:18Z","author":"stealthcode","text":":+1: \n"},{"date":"2016-01-25T22:49:35Z","author":"akarnokd","text":"@stealthcode Do you have time to review #3631, see what else can be included into 1.1.1 and hopefully release it this week?\n"},{"date":"2016-01-25T22:57:47Z","author":"stealthcode","text":"Sure I'll see what we can do.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-01-25T22:33:00Z","description":"Discovered in a [stackoverflow](http:\/\/stackoverflow.com\/questions\/35001387\/how-to-handle-error-in-generatestate-in-synconsubscribe-rxjava) question.\n","id":"128640713","title":"1.x: fix SyncOnSubscribe not signalling onError if the generator crashes","opened_on":"2016-01-25T21:19:28Z","closed_by":"akarnokd"},{"number":"3641","reopenOn":null,"comments":[{"date":"2016-01-24T08:21:18Z","author":"akarnokd","text":"#3507 already takes care of this as well, but thanks.\n"},{"date":"2016-01-24T09:05:56Z","author":"davidmoten","text":"Ah good, thanks @akarnokd. I guess we can leave this open if it's possible that #3507 doesn't make the next release.  By the way, the unit test in here would probably be nice to have in whichever PR makes it in first.\n"},{"date":"2016-01-25T09:39:19Z","author":"akarnokd","text":"I've updated #3507 with your test method.\n"},{"date":"2016-02-03T21:52:13Z","author":"akarnokd","text":"#3661 merged\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-02-09T12:18:05Z","description":"`combinator.call()` was not wrapped in an appropriate try catch to prevent the error from being reported from an upstream operator.\n\nThis PR includes a unit test that failed on the original code.\n","id":"128366167","title":"fix error handling in combineLatest","opened_on":"2016-01-24T01:50:26Z","closed_by":"akarnokd"},{"number":"3640","reopenOn":null,"comments":[{"date":"2016-01-24T08:15:11Z","author":"akarnokd","text":":+1: \n"},{"date":"2016-01-24T08:35:52Z","author":"zsxwing","text":":+1: \n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-01-24T08:43:25Z","description":"`onDrop.call()`  was not wrapped in an appropriate try catch to prevent the error from being reported from an upstream operator.\n\nThis PR includes a unit test that failed on the original code.\n","id":"128358744","title":"fix error handling in onBackpressureDrop","opened_on":"2016-01-23T23:13:23Z","closed_by":"akarnokd"},{"number":"3639","reopenOn":null,"comments":[{"date":"2016-01-23T11:15:08Z","author":"akarnokd","text":":+1:\n"},{"date":"2016-01-23T15:45:25Z","author":"artem-zinnatullin","text":":+1: \n"},{"date":"2016-01-24T23:09:58Z","author":"zsxwing","text":":+1: \n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-01-25T08:50:22Z","description":"`onOverflow.call()`  was not wrapped in an appropriate try catch to prevent the error from being reported from an upstream operator.\n\nThis PR includes a unit test that failed on the original code.\n","id":"128320913","title":"fix error handling in onBackpressureBuffer","opened_on":"2016-01-23T10:55:57Z","closed_by":"akarnokd"},{"number":"3638","reopenOn":null,"comments":[{"date":"2016-01-23T07:41:58Z","author":"akarnokd","text":":+1:\n"},{"date":"2016-01-23T18:17:45Z","author":"artem-zinnatullin","text":":+1: \n"},{"date":"2016-01-24T09:01:52Z","author":"davidmoten","text":"Thanks @zsxwing, it was supposed to have been used and now is. Also made stuff private and static that could be. Commits squashed.\n"},{"date":"2016-01-24T23:08:42Z","author":"zsxwing","text":":+1: \n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-01-25T08:49:51Z","description":"As per #3637, `keySelector.call()` was not wrapped in an appropriate try catch to prevent the error from being reported from an upstream operator.\n\nThis PR includes a unit test that failed on the original code.\n","id":"128311121","title":"fix error handling in OperatorDistinctUntilChanged","opened_on":"2016-01-23T07:12:52Z","closed_by":"akarnokd"},{"number":"3637","reopenOn":null,"comments":[{"date":"2016-01-23T07:08:29Z","author":"davidmoten","text":"unrelated unit test failure `BackpressureTests.testMergeAsync`\n"},{"date":"2016-01-23T07:56:25Z","author":"akarnokd","text":":+1:\n"},{"date":"2016-01-24T08:41:13Z","author":"zsxwing","text":":+1: \n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2016-01-24T08:44:41Z","description":"A non-fatal exception thrown by `predicate.call()` in `OperatorSkipWhile` could result in the error being reported by an upstream operator. This PR ensures that the error is reported by the operator in which it occurs.\n\nI've added a unit test for this scenario that failed with the original code, and a couple of other tests.\n\nThere are a few more of these floating around that I'll submit PRs for as well.\n","id":"128310282","title":"handle predicate exceptions properly in skipWhile","opened_on":"2016-01-23T06:49:16Z","closed_by":"akarnokd"},{"number":"3630","reopenOn":null,"comments":[{"date":"2016-01-22T06:08:57Z","author":"zsxwing","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-01-22T06:17:56Z","description":"The operator was not allowing `null`s in the inner Observables.\n\nRelated: #3629.\n","id":"127889117","title":"1.x: ConcatMapEager allow nulls from inner Observables.","opened_on":"2016-01-21T10:11:27Z","closed_by":"zsxwing"},{"number":"3629","reopenOn":null,"comments":[{"date":"2016-01-21T09:48:16Z","author":"Petikoch","text":"@akarnokd what do you think about this one? Best regards, Peti\n"},{"date":"2016-01-21T09:51:57Z","author":"akarnokd","text":"Yes, this is yet another oversight in eager concatMap. I'll post the fix soon.\n"},{"date":"2016-01-21T09:53:20Z","author":"Petikoch","text":"@akarnokd , thanks a lot!\n"},{"date":"2016-01-22T06:18:13Z","author":"zsxwing","text":"Fixed in #3630 \n"}],"opened_by":"Petikoch","reopen":false,"closed_on":"2016-01-22T06:18:13Z","description":"While flatMap and concatMap are fine with flattening null values, concatMapEager blows up.\n\n```\nimport rx.Observable;\n\npublic class RxJavaNullValueTolerance {\n\n    public static void main(String[] args) {\n        Observable.just(\"just me\")\n                .flatMap(nextString -> Observable.just(null))\n                .subscribe(nextObject -> System.out.println(\"Got: \" + nextObject));\n        System.out.println(\"flatMap is fine with null values\");\n\n        Observable.just(\"just me\")\n                .concatMap(nextString -> Observable.just(null))\n                .subscribe(nextObject -> System.out.println(\"Got: \" + nextObject));\n        System.out.println(\"concatMap is fine with null values\");\n\n        Observable.just(\"just me\")\n                .concatMapEager(nextString -> Observable.just(null))\n                .subscribe(nextObject -> System.out.println(\"Got: \" + nextObject));\n        System.out.println(\"concatMapEager is fine with null values\");\n    }\n}\n```\n\n(RxJava 1.1.0)\n\nOutput:\n\n```\nGot: null\nflatMap is fine with null values\nGot: null\nconcatMap is fine with null values\nException in thread \"main\" rx.exceptions.OnErrorNotImplementedException: null elements not allowed\n    at rx.Observable$27.onError(Observable.java:7923)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:159)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)\n    at rx.internal.operators.OperatorEagerConcatMap$EagerOuterSubscriber.drain(OperatorEagerConcatMap.java:216)\n    at rx.internal.operators.OperatorEagerConcatMap$EagerInnerSubscriber.onError(OperatorEagerConcatMap.java:302)\n    at rx.Observable.unsafeSubscribe(Observable.java:8105)\n    at rx.internal.operators.OperatorEagerConcatMap$EagerOuterSubscriber.onNext(OperatorEagerConcatMap.java:144)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.subscribe(Observable.java:8191)\n    at rx.Observable.subscribe(Observable.java:8158)\n    at rx.Observable.subscribe(Observable.java:7914)\n    at RxJavaNullValueTolerance.main(RxJavaNullValueTolerance.java:18)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\nCaused by: java.lang.NullPointerException: null elements not allowed\n    at rx.internal.util.unsafe.SpscArrayQueue.offer(SpscArrayQueue.java:104)\n    at rx.internal.operators.OperatorEagerConcatMap$EagerInnerSubscriber.onNext(OperatorEagerConcatMap.java:294)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:8098)\n    ... 14 more\n```\n\nThis is IMO critical, since these three operators are closely related and often replaced thru each other, depending on the concrete \"flattening\" requirements.\n","id":"127884518","title":"concatMapEager blows up on null values","opened_on":"2016-01-21T09:47:54Z","closed_by":"zsxwing"},{"number":"3620","reopenOn":null,"comments":[{"date":"2016-01-17T08:33:31Z","author":"akarnokd","text":":+1:\n"},{"date":"2016-01-23T18:52:54Z","author":"artem-zinnatullin","text":":+1: \n\n@msavitskiy can you please squash commits in your PR into one?\n"},{"date":"2016-01-26T08:47:46Z","author":"msavitskiy","text":"@artem-zinnatullin  I make squash commits. I did the right thing?\n"},{"date":"2016-01-27T00:02:44Z","author":"artem-zinnatullin","text":"@msavitskiy mm, nope\u2026\n\nBasically you should have one commit after squash done right. I'd suggest to read documentation and some examples (maybe even videos) about `git rebase`.\n\nIf it'll be blocker for merge I can squash your PR and resubmit it (you'll still be author of the commit!)\n"},{"date":"2016-01-27T11:22:46Z","author":"msavitskiy","text":"@artem-zinnatullin Now everything is fine?\n"},{"date":"2016-01-27T11:45:51Z","author":"artem-zinnatullin","text":"@msavitskiy yes, thanks!\n"},{"date":"2016-02-06T16:37:40Z","author":"stevegury","text":":+1: \n"}],"opened_by":"msavitskiy","reopen":false,"closed_on":"2016-02-06T16:54:18Z","description":"possible solution :)\n","id":"127067262","title":"1.x: Fix NPE in CompositeException when nested throws on initCause","opened_on":"2016-01-17T01:15:13Z","closed_by":"akarnokd"},{"number":"3614","reopenOn":null,"comments":[{"date":"2016-01-25T22:56:59Z","author":"stealthcode","text":"We were waiting to hear from @benjchristensen on this one I think. Any news?\n"},{"date":"2016-01-26T05:54:22Z","author":"benjchristensen","text":"+1 for correctness despite my hesitance due to perf impact. \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-01-26T10:23:11Z","description":"Updated `just()` to fully support backpressure.\n\nThis is a repost of #3496 due to merge and rebase problems.\n","id":"126413448","title":"1.x: just() now supports backpressure (+ related fixes\/changes)","opened_on":"2016-01-13T13:01:45Z","closed_by":"akarnokd"},{"number":"3599","reopenOn":null,"comments":[{"date":"2016-01-06T14:23:30Z","author":"emilianogc","text":"Also, when created with two exceptions with the first containing a cause, the second exception will not be present in the resulting chain.\n\nIs there a plan to move to java7? In that case this same feature can be implemented using Throwable#addSupressed.\n"},{"date":"2016-01-06T14:33:48Z","author":"akarnokd","text":"Hi. 1.x won't move beyond Java 6. I've looked at the crashing code but don't know how to fix it as I don't understand the logic in there exactly.\n"},{"date":"2016-01-08T19:28:03Z","author":"emilianogc","text":"Any help on what should be the expected behaviour for getCause so I can propose a fix? The test doesn't really show what's the contract for CompositeException#getCause.\n"},{"date":"2016-02-09T14:18:02Z","author":"akarnokd","text":"Closing via #3620\n"}],"opened_by":"emilianogc","reopen":false,"closed_on":"2016-02-09T14:18:02Z","description":"The following example throws a NPE\n\n``` java\npublic class Test {\n    public static class CustomException extends Throwable {\n        public synchronized Throwable initCause(Throwable cause) {\n            throw new UnsupportedOperationException();\n        }\n    }\n    public static void main(String ... args) {\n        new CompositeException(Arrays.asList(\n                new CustomException(),\n                new UnsupportedOperationException(),\n                new IllegalStateException())).getCause();\n    }\n}\n```\n\nThe stacktrace is the following:\n\n```\nException in thread \"main\" java.lang.NullPointerException\n    at rx.exceptions.CompositeException.getCause(CompositeException.java:126)\n    at Test.main(Test.java:18)\n```\n","id":"124977895","title":"NPE in CompositeException when nested throws on initCause","opened_on":"2016-01-05T14:31:54Z","closed_by":"akarnokd"},{"number":"3597","reopenOn":null,"comments":[{"date":"2016-02-08T21:51:04Z","author":"akarnokd","text":"Fresh version in #3678.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-08T21:51:05Z","description":"This PR fixes the backpressure behavior of the counted `buffer` and `window` operators and consists of several changes.\n\nThe main issue lies when `count > skip` in the operators, yielding overlapping buffers\/windows. \n\nFor `buffer`, when the upstream completed, the logic emitted all remaining partial buffers even if there was no request for new buffers, which can result in `MissingBackpressureException` somewhere. The proper handling of the final buffers required a new backpressure management algorithm which is now part of the `BackpressureUtils` class and consists of two new methods: `postCompleteDone` called from onComplete to take over the emission of queued values and `postCompleteRequest` which manages requests before and after the completed state.\n\nFor `window`, the new window opened was emitted regardless of requests which was common due to request-amplification (i.e., requesting n windows results in requesting `count + skip * (n - 1)` elements at first (then `skip * n` later) which opens `ceil(count \/ skip)` windows upfront. To avoid the overflow, the individual windows have to go through the usual queue\/drain logic as well. I've also updated the Javadoc to reflect the backpressure behavior along with parameter validation.\n\nIn addition, the window case didn't manage cancellation properly. When the outer observable is unsubscribed, the inner subscribers may be still going and thus cancelling the upstream would stop\/hang the inner windows. Instead, the open window count is tracked (also counting the outer as 1 window) and when all get unsubscribed (i.e., count reaches zero), the upstream is unsubscribed. To accomplish this, the `UnicastSubject` had to be retrofitted with a new optional callback `Action0` which gets called at most once whenever either `onError` or `onCompleted` is called or when the single `Subscriber` unsubscribes.\n\nA secondary issue was with the `TestSubscriber`'s initial request; some upstream operators could get triggered with `Long.MAX_VALUE` despite the initial request amount was set. This PR changes it to be set at construction time instead of in `onStart`.\n","id":"124765854","title":"1.x: fix counted buffer and window operators' backpressure behavior","opened_on":"2016-01-04T14:12:32Z","closed_by":"akarnokd"},{"number":"3585","reopenOn":null,"comments":[{"date":"2015-12-21T18:47:51Z","author":"artem-zinnatullin","text":":+1: \n"},{"date":"2016-01-12T07:09:53Z","author":"zsxwing","text":":+1:\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-01-12T07:57:05Z","description":"This PR fixes the cases when the Completable factory throws an exception\nor returns null and the resource is not disposed before reporting error\nto the subscriber.\n","id":"123334935","title":"1.x: fix Completable.using not disposing the resource if the factory crashes during the subscription phase.","opened_on":"2015-12-21T18:41:24Z","closed_by":"akarnokd"},{"number":"3556","reopenOn":null,"comments":[{"date":"2015-12-06T21:04:02Z","author":"artem-zinnatullin","text":":+1: \n"},{"date":"2015-12-07T00:27:03Z","author":"davidmoten","text":":+1: \n"},{"date":"2015-12-08T18:56:14Z","author":"stealthcode","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-12-08T18:56:19Z","description":"This PR adds the usual try-catch around callback invocations in `toMap`\nand `toMultimap`.\n\nRelated #3555.\n","id":"120128090","title":"1.x: fix toMap and toMultimap not handling exceptions of the callbacks","opened_on":"2015-12-03T09:36:22Z","closed_by":"stealthcode"},{"number":"3555","reopenOn":null,"comments":[{"date":"2015-12-03T09:37:04Z","author":"akarnokd","text":"Hi. This is an oversight on our part. Fix in #3556.\n"},{"date":"2015-12-03T10:19:17Z","author":"vyadh","text":"Wow, that was quick. :+1: \n\nThanks very much.\n"}],"opened_by":"vyadh","reopen":false,"closed_on":"2015-12-03T10:19:17Z","description":"Hi,\n\nWhen I try to use toMap() where my value selector may throw an exception, the error only seems to be propagated via the Observable error stream if the observable is with running single threaded or subscribeOn is being used, but not when observeOn is being used.\n\nHere is a unit test to illustrate the problem, where the test \"onErrorCalledWhenObserveOnUsed\" fails:\n\n``` java\npublic class RxJavaToMapWithErrorBehaviourTest {\n\n  @Test\n  public void onErrorCalledForSingleThread() {\n    Observable<Map<Integer, Integer>> observable = Observable.just(1, 2, 3, 4, 5)\n          .toMap(n -> n, n -> {\n            throw new IllegalStateException();\n          });\n\n    assertOnErrorCalled(observable);\n  }\n\n  @Test\n  public void onErrorCalledWhenSubscribeOnUsed() {\n    Observable<Map<Integer, Integer>> observable = Observable.just(1, 2, 3, 4, 5)\n          .subscribeOn(Schedulers.computation())\n          .toMap(n -> n, n -> {\n            throw new IllegalStateException();\n          });\n\n    assertOnErrorCalled(observable);\n  }\n\n  @Test\n  public void onErrorCalledWhenObserveOnUsed() {\n    Observable<Map<Integer, Integer>> observable = Observable.just(1, 2, 3, 4, 5)\n          .observeOn(Schedulers.computation())\n          .toMap(n -> n, n -> {\n              throw new IllegalStateException();\n          });\n\n    assertOnErrorCalled(observable);\n  }\n\n  private <T> void assertOnErrorCalled(Observable<T> observable) {\n    TestSubscriber<T> subscriber = new TestSubscriber<>();\n    observable.subscribe(subscriber);\n\n    subscriber.awaitTerminalEvent(2, TimeUnit.SECONDS);\n    subscriber.assertError(IllegalStateException.class);\n  }\n\n}\n```\n\nThe error thrown is:\n\n```\nException in thread \"RxComputationThreadPool-3\" java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.IllegalStateException\n    at RxJavaToMapWithErrorBehaviourTest.lambda$onErrorCalledWhenObserveOnUsed$5(RxJavaToMapWithErrorBehaviourTest.java:47)\n    at RxJavaToMapWithErrorBehaviourTest$$Lambda$2\/431687835.call(Unknown Source)\n    at rx.internal.operators.OperatorToMap$1.onNext(OperatorToMap.java:90)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:208)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:170)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    ... 7 more\n\n```\n\nThe observeOn() case seems to make make sense for my use-case at least (where I used subscribeOn to do a database call, followed by observeOn for subsequent calculations).\n\nI think I can probably workaround this problem by first doing a map() to do the calculation and then the toMap(), but I wondered whether this was a bug or expected behaviour?\n\nThanks.\n","id":"120116747","title":"Exceptions not being propagated via onError when using toMap with observeOn","opened_on":"2015-12-03T08:24:58Z","closed_by":"vyadh"},{"number":"3535","reopenOn":null,"comments":[{"date":"2015-11-22T03:41:41Z","author":"artem-zinnatullin","text":":+1: \n"},{"date":"2015-11-22T09:03:27Z","author":"akarnokd","text":":+1:\n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2015-11-22T09:03:31Z","description":"A follow up PR for #3528\n","id":"118236336","title":"1.x: Don't swallow fatal errors in OperatorZipIterable","opened_on":"2015-11-22T03:29:21Z","closed_by":"akarnokd"},{"number":"3528","reopenOn":null,"comments":[{"date":"2015-11-16T18:32:14Z","author":"akarnokd","text":":+1:\n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2015-11-16T18:32:18Z","description":"`delay` delays the `onCompleted` event and `unsubscribe` is called when `onCompleted` finishes. So if we put a `o.zipWith(Iterable, func)` before `delay`, such as `o.zipWith(Iterable, func).delay(...)`, `o` may keep emitting items even if `zipWith` emits an `onCompleted` event. This PR just fixed `OperatorZipIterable` to handle this case.\n\nFixes https:\/\/github.com\/ReactiveX\/RxScala\/issues\/180\n","id":"117056954","title":"1.x: Avoid to call next when Iterator is drained","opened_on":"2015-11-16T05:59:01Z","closed_by":"akarnokd"},{"number":"3510","reopenOn":null,"comments":[{"date":"2015-11-10T19:59:29Z","author":"stealthcode","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-11-10T21:03:09Z","description":"I forgot to add the choice because 2.x `SpscArrayQueue` doesn't use Unsafe. I copied the `SpscAtomicArrayQueue` from #3169 and I hope it won't conflict. This is the drawback of long trail of unmerged fixes and enhancements...\n\nReported in #3508 . \n","id":"115964333","title":"1.x: eager concatMap to choose safe or unsafe queue based on platform.","opened_on":"2015-11-09T20:58:54Z","closed_by":"akarnokd"},{"number":"3509","reopenOn":null,"comments":[{"date":"2015-11-09T17:51:07Z","author":"artem-zinnatullin","text":"If Samsung runtime renames fields in all classes (even `android.os.Build`)  it would break way more libraries that use reflection on fields, especially JSON parsers\/serializers and we will have tons of crashes on such devices. \n\nI mean, this workaround will probably never work.\n\ncc other Android devs, maybe I'm missing something, but I don't think that this PR will fix Samsung problem.\n"},{"date":"2015-11-09T18:24:17Z","author":"JakeWharton","text":"Yes. This class and field can never be renamed or the entire phone would fail to work.\n"},{"date":"2015-11-09T18:25:52Z","author":"akarnokd","text":"Is there a chance Samsung uses some whitelist that doesn't touch most common libraries but messes with others?\n"},{"date":"2015-11-09T18:32:23Z","author":"JakeWharton","text":"Highly unlikely. It seems like a simple reflection bug as people have\nconfirmed the field is named correctly at runtime.\n\nOn Mon, Nov 9, 2015, 1:25 PM David Karnok notifications@github.com wrote:\n\n> Is there a chance Samsung uses some whitelist that doesn't touch most\n> common libraries but messes with others?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/3509#issuecomment-155147020.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-11-12T08:53:43Z","description":"It seems some Samsung devices running 5.x mess with field names so\nreflection can't find them.\n\nIf the `PlatformDependent.resolveAndroidApiVersion` logic throws due to\nthe missing field (but not the class), the original code considered it\nto be a non-Android platform and went ahead with `Unsafe` stuff which\ncauses NPEs at many places.\n\nThe change splits the class check and the version check. If the version\ncheck fails, it returns a default version (7) value so the `Unsafe`\npaths are not triggered.\n","id":"115925066","title":"1.x: split Android detection and version detection","opened_on":"2015-11-09T17:26:16Z","closed_by":"akarnokd"},{"number":"3508","reopenOn":null,"comments":[{"date":"2015-11-09T17:13:25Z","author":"akarnokd","text":"Do you, by any chance, have a Samsung device?\n"},{"date":"2015-11-09T17:31:11Z","author":"jjvargas","text":"Its a Custom Tablet , non branded .\n\nOn 9 November 2015 at 17:14, David Karnok notifications@github.com wrote:\n\n> Do you, by any chance, have a Samsung device?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3508#issuecomment-155128725.\n"},{"date":"2015-11-09T17:38:09Z","author":"artem-zinnatullin","text":"@akarnokd you can create Android 4.2 emulator (Android API level 17) and try to run tests (#3503) on it, or I'll do this tonight.\n"},{"date":"2015-11-09T17:45:08Z","author":"jjvargas","text":"I tried with Genymotion I get the same error\n\nOn 9 November 2015 at 17:38, Artem Zinnatullin notifications@github.com\nwrote:\n\n> @akarnokd https:\/\/github.com\/akarnokd you can create Android 4.2\n> emulator (Android API level 17) and try to run tests (#3503\n> https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3503) on it, or I'll do this\n> tonight.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3508#issuecomment-155135337.\n"},{"date":"2015-11-09T17:47:57Z","author":"akarnokd","text":"My guess is that there is the same field error as with those Samsung devices so android.os.Build.VERSION.INT_VER is not properly discovered and the library thinks it runs on desktop Java.\n"},{"date":"2015-11-09T20:47:21Z","author":"akarnokd","text":"Ups, my bad. Forgot to check the unsafe access in eager concatmap.\n"},{"date":"2015-11-09T20:59:51Z","author":"akarnokd","text":"Fix posted in #3510\n"},{"date":"2015-11-10T21:03:31Z","author":"akarnokd","text":"Closing via #3510.\n"}],"opened_by":"jjvargas","reopen":false,"closed_on":"2015-11-10T21:03:31Z","description":"I am using a Tablet with Android 4.2  using 'io.reactivex:rxjava:1.0.15'\n\nIn Android 5.1 it works fine, but not it 4.2\n\n```\npublic Observable<Artist[]> batchGetArtistsById(ArtistIdList artistIdList) {\n        return Observable.from(artistIdList.getArtistIds())\n                .concatMapEager(artist -> getArtistById(artist))\n                .subscribeOn(Schedulers.io())\n                .toList()\n                .observeOn(AndroidSchedulers.mainThread())\n                .doOnError(e ->\n                        {\n                            System.out.println(\"Error what to do? \" + e);\n                        }\n                )\n                .flatMap(artistList -> {\n                    Artist[] artistsArray = artistList.toArray(new Artist[artistList.size()]);\n                    return Observable.just(artistsArray);\n                });\n}\n```\n\n11-09 16:23:01.485 6762-6782\/? E\/AndroidRuntime: FATAL EXCEPTION: RxCachedThreadScheduler-1\n                                                 java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n                                                     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)\n                                                     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)\n                                                     at java.util.concurrent.FutureTask.run(FutureTask.java:234)\n                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153)\n                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267)\n                                                     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\n                                                     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\n                                                     at java.lang.Thread.run(Thread.java:856)\n                                                  Caused by: java.lang.ExceptionInInitializerError\n                                                     at rx.internal.operators.OperatorEagerConcatMap$EagerInnerSubscriber.<init>(OperatorEagerConcatMap.java:281)\n                                                     at rx.internal.operators.OperatorEagerConcatMap$EagerOuterSubscriber.onNext(OperatorEagerConcatMap.java:130)\n                                                     at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.fastpath(OnSubscribeFromIterable.java:127)\n                                                     at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:70)\n                                                     at rx.Subscriber.setProducer(Subscriber.java:209)\n                                                     at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)\n                                                     at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\n                                                     at rx.Observable$2.call(Observable.java:162)\n                                                     at rx.Observable$2.call(Observable.java:154)\n                                                     at rx.Observable.unsafeSubscribe(Observable.java:8171)\n                                                     at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n                                                     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n                                                     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390) \n                                                     at java.util.concurrent.FutureTask.run(FutureTask.java:234) \n                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153) \n                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267) \n                                                     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080) \n                                                     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573) \n                                                     at java.lang.Thread.run(Thread.java:856) \n                                                  Caused by: java.lang.NullPointerException\n                                                     at rx.internal.util.unsafe.ConcurrentCircularArrayQueue.<clinit>(ConcurrentCircularArrayQueue.java:51)\n                                                     at rx.internal.operators.OperatorEagerConcatMap$EagerInnerSubscriber.<init>(OperatorEagerConcatMap.java:281) \n                                                     at rx.internal.operators.OperatorEagerConcatMap$EagerOuterSubscriber.onNext(OperatorEagerConcatMap.java:130) \n                                                     at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.fastpath(OnSubscribeFromIterable.java:127) \n                                                     at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:70) \n                                                     at rx.Subscriber.setProducer(Subscriber.java:209) \n                                                     at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49) \n                                                     at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32) \n                                                     at rx.Observable$2.call(Observable.java:162) \n                                                     at rx.Observable$2.call(Observable.java:154) \n                                                     at rx.Observable.unsafeSubscribe(Observable.java:8171) \n                                                     at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62) \n                                                     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55) \n                                                     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390) \n                                                     at java.util.concurrent.FutureTask.run(FutureTask.java:234) \n                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153) \n                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267) \n                                                     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080) \n                                                     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573) \n                                                     at java.lang.Thread.run(Thread.java:856) \n","id":"115912986","title":"Null pointer using ConcatMapEager on Android 4.2","opened_on":"2015-11-09T16:28:30Z","closed_by":"akarnokd"},{"number":"3497","reopenOn":null,"comments":[{"date":"2016-02-04T10:10:20Z","author":"akarnokd","text":"Closing, will be included in the complete backport PR.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-04T10:10:20Z","description":"The internal queue has to be trimmed while the source is active and the\nbackpressured-replay shouldn't drop values in case the requests are\ndelayed relative to each other.\n","id":"115343794","title":"2.x: fix takeLast(time) replay behavior causing discontinuity","opened_on":"2015-11-05T18:25:08Z","closed_by":"akarnokd"},{"number":"3496","reopenOn":null,"comments":[{"date":"2015-11-11T10:45:39Z","author":"akarnokd","text":"Rebased.\n"},{"date":"2015-11-23T23:26:25Z","author":"stealthcode","text":"Interesting. Thanks! :+1: \n"},{"date":"2015-11-23T23:28:04Z","author":"stealthcode","text":"This should probably be checked out by @benjchristensen before merging\n"},{"date":"2015-11-23T23:28:23Z","author":"akarnokd","text":"Just to check, you are fine with the overhead, right?\n"},{"date":"2015-11-24T20:15:10Z","author":"stealthcode","text":"@akarnokd yes. I think consistent behavior is worth the hit. \n"},{"date":"2015-11-26T22:32:25Z","author":"davidmoten","text":":+1: \n"},{"date":"2016-01-13T11:12:43Z","author":"davidmoten","text":"Any plans to merge this one?\n"},{"date":"2016-01-13T11:17:24Z","author":"akarnokd","text":"We are waiting for Ben but I have to fix the merge conflict as well now I see.\n"},{"date":"2016-01-13T11:48:54Z","author":"akarnokd","text":"Sorry, I'll redo this entire PR, everything is messed up.\n"},{"date":"2016-01-13T13:02:01Z","author":"akarnokd","text":"Replaced by #3614 \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-01-13T11:48:54Z","description":"One does not simply add backpressure support to `just()`.\n## Fixes\n\nThe reason for this is the bugs hidden by the lack of backpressure support of just(): the overwriting of a previous Producer by `timeout`, `zip` and `subscribeOn`. I've fixed up `timeout` with a proper `ProducerArbiter`, had to apply the bugfix from #3493 to `zip` (may conflict) and had to rewrite `subscribeOn` from scratch and have it an `OnSubscribe`. This change required that `Single.subscribeOn` to be rewritten as well.\n## Benchmark\n\nLet's see the benchmark comparison (i7 4790, Windows 7 x64, Java 8u66):\n\n![image](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/10972989\/ec1eb288-83db-11e5-951c-48840b165b7e.png)\n\nThere are two ways to implement backpressure: with strong atomics or with plain field accesses. The latter tries to exploit the high chance that there won't be concurrent calls to `request()` ever and thus saves on the atomics. As far as I can tell, there is nothing in RxJava 1.x or 2.x that would violate this assumption. However, I added an escape hatch in case of rogue requesters: set the `rx.just.strong-mode` system parameter to \"true\" and `just` will run with strong atomics.\n\nAs seen in the table, the weak version is just slightly better (+3-+10%) in some cases and slightly worse (up to -3%) in other cases. Note, however, the original cases have 2x-5x less overhead. \n\nMaybe the most revealing are the `simple`, `simpleEscape` and `simpleEscapeAll` comparison between and within version. What's seen there is that with the original version, the JIT converted the test into a pure stack-allocation and thus saving on overhead in the `simple` case. As the other tests add escapes, it forces the JIT to do regular allocations. Interesting that with this PR, the escape doesn't really matter: this is due to how `Subscriber.setProducer` makes the JIT believe the producer escapes.\n\nIn the `simpleEscapeAll` (which should be the most restrictive for JIT), the overhead is still 2 - 2.3 times bigger: this is due to the extra allocation of a `Producer` instance when subscribing.\n\nIf one remembers my recent [blog post](http:\/\/akarnokd.blogspot.hu\/2015\/10\/comparison-of-reactive-streams.html), it can be seen that RxJava 2.x does quite well, about 30 Mops\/s in the range-1 test (which is equivalent to `simple`). \n\nWhere does the overhead come from? `SubscriptionList`. In 1.x, the `Subscriber` creates a `SubscriptionList` whether or not it is ever required. (I've tried my best several times to defer the creation of this list to no success: the performance improved for some cases while worsened for others, see #3479.)\n\nThe strong\/weak optimization is not applied to `scalarScheduleOn`. I haven't benchmarked it but I guess the scheduling overhead overshadows it anyways.\n## Conclusion\n\nI believe the correctness of `just` is more important than its performance, but the increased overhead bothers me nonetheless. Given the architecture of 2.x, I'll look into ways to get rid of the mandatory `SubscriptionList` allocation without breaking public API classes such as `Subscriber`.\n","id":"115316347","title":"1.x: make just() support backpressure","opened_on":"2015-11-05T16:08:45Z","closed_by":"akarnokd"},{"number":"3494","reopenOn":null,"comments":[{"date":"2015-11-04T18:32:27Z","author":"akarnokd","text":"The cause for this exception is that `just` doesn't support backpressure and emits immediately. For a workaround, you can apply `onBackpressureBuffer` to `just(\"Hello\")`.\n"},{"date":"2015-11-04T21:48:24Z","author":"dlew","text":"Thanks for the workaround, that fixes it for now.\n\nWould it be so bad to have `just` support backpressure? I mean, it will need to support it in RxJava 2.0 anyways - it's not like things aren't already headed that way.\n"},{"date":"2015-11-04T22:20:52Z","author":"akarnokd","text":"I'll post a PR tomorrow with benchmark to see how the overheads change.\n"},{"date":"2015-11-05T04:40:29Z","author":"davidmoten","text":"@dlew Thanks for finding another instance of backpressure failure caused by `just`. I've been collecting them! (#3044). I think it's time backpressure support for `just` happened.\n"},{"date":"2015-11-05T16:09:02Z","author":"akarnokd","text":"Fix posted: #3496.\n"},{"date":"2015-11-05T23:35:27Z","author":"zsxwing","text":"I remember we don't require that the user's Observable should support backpressure. So the user could just implement an `Observable` like `just(1)`. Right?\n"},{"date":"2016-02-09T14:04:00Z","author":"akarnokd","text":"Just now supports backpressure and will be part of 1.1.1.\n"}],"opened_by":"dlew","reopen":false,"closed_on":"2016-02-09T14:04:00Z","description":"This is the simplest reproduction I could conjure up of this problem:\n\n``` java\n    Observable.just(1)\n        .flatMap(n -> {\n          return Observable.just(null, null)\n              .filter(o -> o != null)\n              .switchIfEmpty(Observable.empty().switchIfEmpty(Observable.just(\"Hello\")));\n        })\n        .subscribe(System.out::println);\n```\n\nThis will spit out `onError` with the error message \"more items arrived than were requested\".\n\nThis appears to be a regression. It works on RxJava 1.0.11 but fails on every version since then (including 1.0.15, the latest).\n\nAdding in a `take(1)` seems to fix the problem (as a workaround).\n\nFor completeness, here is the exception:\n\n```\nException in thread \"main\" rx.exceptions.OnErrorNotImplementedException: more items arrived than were requested\n    at rx.Observable$27.onError(Observable.java:7996)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:158)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:119)\n    at rx.internal.util.ScalarSynchronousObservable$2$1.onError(ScalarSynchronousObservable.java:140)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onError(OperatorSwitchIfEmpty.java:116)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onError(OperatorSwitchIfEmpty.java:116)\n    at rx.Observable.unsafeSubscribe(Observable.java:8178)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.subscribeToAlternate(OperatorSwitchIfEmpty.java:78)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.onCompleted(OperatorSwitchIfEmpty.java:71)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1073)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1070)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.subscribeToAlternate(OperatorSwitchIfEmpty.java:78)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.onCompleted(OperatorSwitchIfEmpty.java:71)\n    at rx.internal.operators.OperatorFilter$1.onCompleted(OperatorFilter.java:42)\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.fastpath(OnSubscribeFromIterable.java:129)\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:70)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.setProducer(OperatorSwitchIfEmpty.java:63)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    at rx.internal.util.ScalarSynchronousObservable$2.call(ScalarSynchronousObservable.java:133)\n    at rx.internal.util.ScalarSynchronousObservable$2.call(ScalarSynchronousObservable.java:125)\n    at rx.Observable.subscribe(Observable.java:8266)\n    at rx.Observable.subscribe(Observable.java:8233)\n    at rx.Observable.subscribe(Observable.java:7987)\n    at net.danlew.experiments.Tester.main(Tester.java:40)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)\nCaused by: java.lang.IllegalStateException: more items arrived than were requested\n    at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onNext(OperatorSwitchIfEmpty.java:122)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    ... 33 more\n```\n","id":"115102578","title":"switchIfEmpty() causes \"more items arrived than were requested\" in bizarre case","opened_on":"2015-11-04T17:19:06Z","closed_by":"akarnokd"},{"number":"3493","reopenOn":null,"comments":[{"date":"2015-11-11T20:46:19Z","author":"stealthcode","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-11-11T20:48:04Z","description":"Reported in #3492.\n","id":"115060556","title":"1.x: fix for zip(Obs<Obs<T>>) backpressure problem","opened_on":"2015-11-04T14:17:23Z","closed_by":"akarnokd"},{"number":"3492","reopenOn":null,"comments":[{"date":"2015-11-04T14:23:09Z","author":"akarnokd","text":"Hello and thanks for the in-depth analysis. What happens is that the child is caputed by `ZipSubscriber` and when it receives its `Producer` from `toList`, that also gets forwarded to child which overwrites the `ZipProducer` and thus no further requests get accounted. The fix is posted in #3493\n\nOrdered merging comes up from time to time on StackOverflow; you can post a PR for it but frankly, if Netflix doesn't need one urgently, it can take a long time to get it approved.\n"},{"date":"2015-11-04T15:58:25Z","author":"MaltAlex","text":"Thanks. That's pretty much what I suspected.\n\nSo if I understand correctly, your solution was to disconnect the child from the backpressure chain, but add the `ZipSubscriber` to its subscription list so it'll know whether the downstream is subscribed.\n"},{"date":"2015-11-04T16:42:42Z","author":"akarnokd","text":"Yes. I've fixed like dozens of such bugs before; it is a design shortcoming of `Subscriber`.\n"},{"date":"2015-11-05T06:04:53Z","author":"davidmoten","text":"@MaltAlex re your sorted merge operator. You can find one at [rxjava-extras](https:\/\/github.com\/davidmoten\/rxjava-extras) as well (`Transformers.orderedMergeWith`) with almost complete test coverage (for what that's worth). Even if you don't use it the testing strategy might be useful to you:\n- test ordered merge of all pairs of sorted sets taken from a Power Set of numbers from 1..n, perform for n=0 to 10\n- do the above synchronously and asynchronously\n\nThe operator I made requires backpressure supporting sources but does not support backpressure itself and would be combined with `.onBackpressureXXX`.\n\nI think @akarnokd has one of these floating around as well but I don't know if it has unit tests.\n"},{"date":"2015-11-05T07:59:45Z","author":"akarnokd","text":"I [have one](https:\/\/gist.github.com\/akarnokd\/c86a89738199bbb37348) that supports backpressure but without unit tests.\n"},{"date":"2015-11-05T08:40:43Z","author":"davidmoten","text":"I'll have a look at your SortedMerge @akarnokd and beef up unit tests\n(there were some with your gist)\n\nOn 5 November 2015 at 18:59, David Karnok notifications@github.com wrote:\n\n> I have one https:\/\/gist.github.com\/akarnokd\/c86a89738199bbb37348 that\n> supports backpressure but without unit tests.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3492#issuecomment-153981952.\n"},{"date":"2015-11-05T09:04:47Z","author":"MaltAlex","text":"@davidmoten I looked at your implementation before going forward with my own. There were a few details in the implementation that I couldn't figure out, plus the lack of backpressure support was a complete deal breaker in my case. That's why I modified the Zip operator to fit my needs. Its functionality is almost identical.\n\nSo now I have one of those operators too, and the only test that failed for it (erm... so far) was a test that failed for the original Zip as well (hence this issue). I might put it on github sometime later.\n"},{"date":"2015-11-05T20:26:44Z","author":"davidmoten","text":"would be good to see your implementation @MaltAlex. Operators are complex and are hard to test due to async possibilities but I'll chuck the best candidate in a _rxjava-extras_ release. The candidate from @akarnokd will have a good chance of winning out because he knows this domain so well!\n"},{"date":"2015-11-05T23:48:49Z","author":"davidmoten","text":"The implementation from @akarnokd passes my power set tests. Do you have any plans for it @akarnokd? Do you mind if I throw it in to _rxjava-extras_ (I'd make clear your authorship in the source)?\n"},{"date":"2015-11-06T06:55:11Z","author":"akarnokd","text":"No plans, go ahead.\n"},{"date":"2015-11-12T08:55:31Z","author":"akarnokd","text":"Fix delivered with 1.0.16. The discussion about sorted merge can continue in a different thread if you wish.\n"}],"opened_by":"MaltAlex","reopen":false,"closed_on":"2015-11-12T08:55:31Z","description":"I've written an \"SortedMerge\" operator, which is used to orderly merge several ordered observables. The operator is based on [OperatorZip](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/f2410f88dc28c1013f48754606e38507e493245f\/src\/main\/java\/rx\/internal\/operators\/OperatorZip.java) except for several key differences:\n1. Instead of passing an array of items into a zip function the items are compared using a comparator and only the smallest one is emitted.\n2. After emissions, `requestMore` is called only on the observable from which the minimum was taken, and only its buffer's head is removed. The others are left untouched for future comparison. So no items are lost.\n3. Additional type safety is added since the types of the incoming observables is known.\n\n(I can contribute the operator to the project if anyone's interested).\n\nDuring testing, I stumbled upon a use case that failed for my operator, and it turns out that the same problem exists in the original Zip.\n\nTake a look at the following observables. First, o1:\n\n```\nObservable<Integer>[] osArray = new Observable[] { Observable.range(0, 10), Observable.range(0, 10) };\nObservable<Observable<Integer>> os = (Observable<Observable<Integer>>) Observable.from(osArray);\nObservable<Integer> o1 = Observable.zip(os, (a) -> 0);\n```\n\nSecond, o2:\n\n```\nObservable<Integer> o2 = Observable.zip(Observable.range(0, 10), Observable.range(0, 10), (a, b) -> 0);\n```\n\nAccording to my understanding, both should work in exactly the same way. However, their response to requests from the subscriber is different:\n\n```\nTestSubscriber<Integer> sub1 = new TestSubscriber<>(5);\nTestSubscriber<Integer> sub2 = new TestSubscriber<>(5);\n\no1.subscribe(sub1);\no2.subscribe(sub2);\n\nsub1.requestMore(5);\nsub2.requestMore(5);\n\nsub1.awaitTerminalEvent(1, TimeUnit.SECONDS);\nsub2.awaitTerminalEvent(1, TimeUnit.SECONDS);\n\nSystem.out.println(sub1.getOnNextEvents().size());\nSystem.out.println(sub2.getOnNextEvents().size());\n```\n\nproduces this response:\n     5\n     10\n\nWhich is exactly what happened to my SortedMerge operator. After poking at the operator for a while, it turned out that the issue can be solved by changing the construction of the Zip subscriber ZipSubscriber from this:\n\n```\npublic ZipSubscriber(Subscriber<? super R> child, Zip<R> zipper, ZipProducer<R> producer) {\n        super(child);\n        this.child = child;\n        this.zipper = zipper;\n        this.producer = producer;\n    }\n```\n\nto this:\n\n```\npublic ZipSubscriber(Subscriber<? super R> child, Zip<R> zipper, ZipProducer<R> producer) {\n        super();\n        this.child = child;\n        this.zipper = zipper;\n        this.producer = producer;\n    }\n```\n\nWhich seems to make sense, but I'm not sure that I understand Rx's backpressure well enough to know whether that's indeed the right solution.\n","id":"115056106","title":"Backpressure on OperatorZip doesn't work when the observable is created using toList()","opened_on":"2015-11-04T13:56:44Z","closed_by":"akarnokd"},{"number":"3491","reopenOn":null,"comments":[{"date":"2015-11-12T02:34:27Z","author":"davidmoten","text":"Can we get this one reviewed and in a release soon please? This is a blocker for me and precludes me using 1.0.15 and 1.0.16. It's a serious bug with `scan` and I'm nervous for others too that this is out there in another release (1.0.16).\n"},{"date":"2015-12-02T01:15:56Z","author":"stealthcode","text":"Is `ProducerObserverArbiter` used in the public API? It appears to only be in use in the tests. \n"},{"date":"2015-12-02T08:27:48Z","author":"akarnokd","text":"It was added as a tool for building operators but I usually inline the algorithm.\n"},{"date":"2015-12-02T19:15:02Z","author":"stealthcode","text":"Okay. So it's more like a pattern that gets pasted into operators. Do you usually inline for performance reasons or for custom functionality? \n"},{"date":"2015-12-02T19:19:35Z","author":"stealthcode","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-12-02T19:36:49Z","description":"It turns out serializing `request()` calls with regular `onXXX()` calls can be problematic because a `request()` may trigger an emission of events which then end up being queued (since `emitting == true`). If the request is large and the queue otherwise unbounded, this will likely cause OOME.\n\nIn case of `scan`, the fix was to make the missing request accounting and arrival of the `Producer` independent of the event's emitter loop; there is no need for them to be serialized in respect to each other.\n\nIn case of the `ProducerObserverArbiter` where the request accounting and producer swapping has to be serialized with the value emission, the solution is to call `request()` outside the emitter-loop.\n\nThere shouldn't be any issue with 2.x `scan()` because in 2.x, scan receives the `Subscription` before it allows the downstream to request anything so there is no missing requested to be handled.\n\nThis should resolve #3490. As far as I can remember, no other operator should have such problems because all others use `ProducerArbiter` which is independent of `onXXX` emission serializations.\n","id":"115005829","title":"1.x: make scan's delayed Producer independent of event serialization","opened_on":"2015-11-04T09:10:39Z","closed_by":"stealthcode"},{"number":"3490","reopenOn":null,"comments":[{"date":"2015-11-03T23:20:58Z","author":"akarnokd","text":"You are right. Serializing the requesting\/producer arrival with the normal event emission is unnecessary. I'll merge #3485 now but start working on the fix in my morning. I'll review other operators that might exhibit the same problem.\n"},{"date":"2015-11-03T23:46:46Z","author":"davidmoten","text":"Thanks @akarnokd \n"},{"date":"2015-11-04T09:11:09Z","author":"akarnokd","text":"See #3491 for the fix.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-12-02T19:36:49Z","description":"The following test fails in 1.x (and 1.0.15):\n\n``` java\n    @Test(timeout=1000)\n    public void testScanDoesNotHang() {\n        Observable.range(0, Integer.MAX_VALUE)\n                \/\/\n                .scan(1, new Func2<Integer, Integer, Integer>() {\n\n                    @Override\n                    public Integer call(Integer t1, Integer t2) {\n                        return t1;\n                    }\n                })\n                \/\/\n                .subscribe(new Subscriber<Integer>() {\n\n                    int count = 0;\n\n                    @Override\n                    public void onCompleted() {\n\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        count++;\n                        if (count == 2)\n                            unsubscribe();\n                    }\n                });\n    }\n```\n\n@akarnokd  I've stepped through in a debugger and in `OperatorScan` L284 initiates a fast path emission in `OnSubscriberRange` which calls `OperatorScan.emit()` L289 but because the method containing L284 has set `emitting` to true the emission goes no further and an a loop occurs that fills the heap.\n\nThough the test might look a bit contrived I just isolated the behaviour to `scan` for the test. I encountered the bug when this hung:\n\n``` java\nobservable.scan(..).elementAt(n); \/\/where n > 1\n```\n\nI'd rank this bug as nasty (not an improbable edge case like some concurrency bugs) and possibly deserving of a new release quickly.\n","id":"114929915","title":"scan infinite loop","opened_on":"2015-11-03T22:58:54Z","closed_by":"stealthcode"},{"number":"3488","reopenOn":null,"comments":[{"date":"2015-11-03T07:47:09Z","author":"artem-zinnatullin","text":"There is a reason for `AtomicFieldUpdater` + `volatile` value \u2014 lower memory consumption (cc @akarnokd), but personally, I'd like to switch to `Atomic` fields too to get rid of reflection in such hot code.\n\n#3459 is Samsung's problem. Even though we see it in our apps (somebody told me that it's about 5% of Samsung devices of our users) I don't think that such platform specific bugs should be solved on library side.\n"},{"date":"2015-11-03T08:18:47Z","author":"akarnokd","text":"As @artem-zinnatullin mentioned, field updaters were introduced to reduce number of allocations and runtime size of the library; especially for the Android platform.\n\nAlthough field updaters have 1-5% overhead compared to Unsafe, the same overhead may manifest with Atomic instances due to the one level indirection, plus usually the surrounding logic forces a re-read of the AtomicXXX field all the time if not done with care.\n\nSee my other comments in the code.\n"},{"date":"2015-11-03T08:57:51Z","author":"akarnokd","text":"I've finished my review.\n"},{"date":"2015-11-03T09:29:24Z","author":"markrietveld","text":"Thanks for the quick review\n"},{"date":"2015-11-03T11:13:51Z","author":"markrietveld","text":"@akarnokd I think I addressed all your feedback\n"},{"date":"2015-11-03T11:26:20Z","author":"akarnokd","text":"Generally looks okay now. Could you squash your commits into a single commit?\n"},{"date":"2015-11-03T11:42:48Z","author":"markrietveld","text":"Sure thing. Squashed\n"},{"date":"2015-11-03T11:50:54Z","author":"akarnokd","text":"Thanks.\n"},{"date":"2015-11-06T19:52:55Z","author":"akarnokd","text":"The changes look okay. Could you do a comparison benchmark of OperatorObserveOnPerf mainly (and post the comparison image made via [JMH-Compare-GUI](https:\/\/github.com\/akarnokd\/jmh-compare-gui) ) ?\n"},{"date":"2015-11-09T00:25:01Z","author":"markrietveld","text":"I started a run on this branch now using `.\/gradlew benchmarks '-Pjmh=.*OperatorObserveOnPerf.*'`. The ETA for that is in over 2 hours. Does that seem right?\n"},{"date":"2015-11-09T21:17:10Z","author":"markrietveld","text":"I ran JMH yesterday for this commit and the preceding one. The results are on my computer at home, and I'm at work now. I'll post them when I get back\n"},{"date":"2015-11-10T22:39:21Z","author":"markrietveld","text":"Here is the screenshot. The first result is from 51527b7d17652a493e2c73f8724ebc62253a7e4b, the second one is from after the changes in this pull request:\n![image](https:\/\/cloud.githubusercontent.com\/assets\/964550\/11078097\/88f7d050-87b8-11e5-8f0e-a2c909688a79.png)\n\n@akarnokd I'm not sure if I used the GUI right. I can't get it to use something as a baseline. I pasted the result from 51527b7d17652a493e2c73f8724ebc62253a7e4b first, and then the result from this pull request. Do I need to do something else?\n"},{"date":"2015-11-10T23:29:29Z","author":"akarnokd","text":"Right click in a cell and you get a popup menu with options.\n"},{"date":"2015-11-10T23:30:29Z","author":"akarnokd","text":"Otherwise, no performance regression. :+1:\n"},{"date":"2015-11-10T23:52:08Z","author":"stealthcode","text":":+1: \n"},{"date":"2015-11-11T05:43:41Z","author":"artem-zinnatullin","text":":+1:, few nits. Looks like @akarnokd wants local copies of `final` references, but I don't, though I'm ok with having them \u2014 you can just fix `@SuppressWarnings(\"unused\")`. \n\n@akarnokd can you please give a link or describe how local copy of `final` reference will help? I mean, JIT will ~100% won't make re-reads of `final` references until it detect change of the reference via reflection. Or I'm wrong?\n"},{"date":"2015-11-11T08:24:03Z","author":"akarnokd","text":"Keep the locals as I suggested. JIT re-reads them unfortunately. I read and experienced this myself with JCTools queries and range().\n"},{"date":"2015-11-11T08:41:28Z","author":"artem-zinnatullin","text":"That's sad. Okay, then just SuppressWarnings need to be fixed.\n\nNetflix team: can we expect 1.0.16 soon? As mentioned in the original issue\nthis PR would prevent crashes in many apps.\n\nOn Wed, Nov 11, 2015, 11:24 David Karnok notifications@github.com wrote:\n\n> Keep the locals as I suggested. JIT re-reads them unfortunately. I read\n> and experienced this myself with JCTools queries and range().\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/3488#issuecomment-155701813.\n> \n> ## \n\n@artem_zin\n"},{"date":"2015-11-11T08:49:46Z","author":"markrietveld","text":"@artem-zinnatullin I removed the erroneous annotations\n"},{"date":"2015-11-11T09:24:22Z","author":"artem-zinnatullin","text":":+1:, thanks!\n"},{"date":"2015-11-11T09:48:45Z","author":"akarnokd","text":"Please squash this again.\n"},{"date":"2015-11-11T10:05:45Z","author":"markrietveld","text":"Done\n"},{"date":"2015-11-11T10:09:41Z","author":"akarnokd","text":"Thanks for contributing.\n"}],"opened_by":"markrietveld","reopen":false,"closed_on":"2015-11-11T10:09:38Z","description":"Replace them all with their respective Atomic\\* counterparts\nFor example AtomicLongFieldUpdater -> AtomicLong\nAddresses https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3459\n","id":"114762848","title":"1.x Remove all instances of Atomic*FieldUpdater","opened_on":"2015-11-03T07:37:43Z","closed_by":"akarnokd"},{"number":"3485","reopenOn":null,"comments":[{"date":"2015-11-02T21:55:11Z","author":"zsxwing","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-11-03T23:18:24Z","description":"I forgot a NotificationLite conversion in the constructor. Note that\nthere were no tests verifying null behavior at all.\n","id":"114620096","title":"1.x: fix scan() not accepting a null initial value","opened_on":"2015-11-02T15:41:34Z","closed_by":"akarnokd"},{"number":"3484","reopenOn":null,"comments":[{"date":"2015-11-02T15:27:31Z","author":"akarnokd","text":"Hi and thanks for reporting. This is a bug with 1.x because we should be null tolerant. \n\nHowever, I suggest moving away from explicit null values because 2.x and Reactive-Streams in general prohibit null values completely.\n"},{"date":"2015-11-02T15:35:28Z","author":"abersnaze","text":"Try switching to collect() which is like reduce but for mutable seeds.\n"},{"date":"2015-11-02T15:37:28Z","author":"renaudcerrato","text":"@abersnaze thanks - I already worked around by passing a non-null value. Just wanted to report a possible regression.\n"},{"date":"2015-11-02T15:42:11Z","author":"akarnokd","text":"Fix posted in #3485.\n"},{"date":"2015-11-09T21:20:05Z","author":"akarnokd","text":"Closed via #3485.\n"}],"opened_by":"renaudcerrato","reopen":false,"closed_on":"2015-11-09T21:20:05Z","description":"Since I switched to 1.0.15, one of my observable is throwing an NPE - if I'm revert back to 1.0.14, everything is fine.\n\nIt seems the `reduce` operator does'nt accept `null` for initial value anymore.\n\n```\nFatal Exception: java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java)\n       at android.os.Handler.handleCallback(Handler.java)\n       at android.os.Handler.dispatchMessage(Handler.java)\n       at android.os.Looper.loop(Looper.java)\n       at android.app.ActivityThread.main(ActivityThread.java)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java)\nCaused by rx.exceptions.OnErrorNotImplementedException: null elements not allowed\n       at rx.Observable$27.onError(Observable.java)\n       at rx.observers.SafeSubscriber._onError(SafeSubscriber.java)\n       at rx.observers.SafeSubscriber.onError(SafeSubscriber.java)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java)\n       at android.os.Handler.handleCallback(Handler.java)\n       at android.os.Handler.dispatchMessage(Handler.java)\n       at android.os.Looper.loop(Looper.java)\n       at android.app.ActivityThread.main(ActivityThread.java)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java)\nCaused by java.lang.NullPointerException: null elements not allowed\n       at rx.internal.util.unsafe.SpscLinkedQueue.offer(SpscLinkedQueue.java)\n       at rx.internal.operators.OperatorScan$InitialProducer.<init>(OperatorScan.java)\n       at rx.internal.operators.OperatorScan.call(OperatorScan.java)\n       at rx.internal.operators.OperatorScan.call(OperatorScan.java)\n       at rx.Observable$2.call(Observable.java)\n       at rx.Observable$2.call(Observable.java)\n       at rx.Observable$2.call(Observable.java)\n       at rx.Observable$2.call(Observable.java)\n       at rx.Observable$2.call(Observable.java)\n       at rx.Observable$2.call(Observable.java)\n       at rx.Observable.unsafeSubscribe(Observable.java)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java)\n       at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java)\n       at rx.observers.SerializedObserver.onNext(SerializedObserver.java)\n       at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java)\n       at rx.internal.operators.OperatorDebounceWithTime$DebounceState.emit(OperatorDebounceWithTime.java)\n       at rx.internal.operators.OperatorDebounceWithTime$1$1.call(OperatorDebounceWithTime.java)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java)\n       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java)\n       at java.util.concurrent.FutureTask.run(FutureTask.java)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java)\n       at java.lang.Thread.run(Thread.java)\n```\n","id":"114616461","title":"[reduce] initial value not allowed to be null anymore","opened_on":"2015-11-02T15:24:00Z","closed_by":"akarnokd"},{"number":"3480","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-10-29T08:31:30Z","description":"Note: this doesn't change any main class, just a perf class.\n- Two of the tests used the wrong subscriber type.\n- The benchmark layout allowed stack allocation instead of heap allocation and thus showing less overhead than expected. By letting consuming the `Subscriber`s via blackhole, this JIT optimization is negated as it should be.\n- Added a benchmark which should help verify the overhead of checking `isUnsubscribed` within range in #3479 because I suspect that will get worse there.\n\nBenchmark values: (i7 **4790**, Windows 7 x64, Java 8u66):\n\n![image](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/10813246\/16cbe7e4-7e1e-11e5-8de6-5bc1ffdb2739.png)\n","id":"114000740","title":"1.x: update and bugfix to SubscribingPerf","opened_on":"2015-10-29T08:20:09Z","closed_by":"akarnokd"},{"number":"3468","reopenOn":null,"comments":[{"date":"2015-10-24T16:58:05Z","author":"artem-zinnatullin","text":":+1: \n"},{"date":"2015-10-26T07:08:05Z","author":"akarnokd","text":":+1:\n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2015-11-04T06:00:35Z","description":"Reviewed all usages of `OnErrorNotImplementedException` and fixed issues similar to #3455.\n","id":"113137360","title":"1.x: Fix other places that may swallow OnErrorFailedException","opened_on":"2015-10-24T05:18:58Z","closed_by":"zsxwing"},{"number":"3467","reopenOn":null,"comments":[{"date":"2015-10-22T14:05:23Z","author":"headinthebox","text":"Time drift is pretty nasty. We spent a lot of time on this in Rx.NET http:\/\/blogs.msdn.com\/b\/rxteam\/archive\/2012\/06\/20\/reactive-extensions-v2-0-release-candidate-available-now.aspx\n"},{"date":"2015-12-14T22:59:56Z","author":"akarnokd","text":"I've updated the code with the suggestion of @stealthcode \n"},{"date":"2015-12-14T23:29:05Z","author":"stealthcode","text":":+1: LGTM\n"},{"date":"2015-12-14T23:51:13Z","author":"akarnokd","text":"Do you need additional changes? If not, feel free to merge this PR.\n"},{"date":"2015-12-15T00:48:16Z","author":"abersnaze","text":":+1: \n"},{"date":"2015-12-15T06:22:41Z","author":"artem-zinnatullin","text":"Yay! This was important issue.\n\nSo, I did test (similar to #3530):\n\n``` java\nObservable\n  .interval(5, 10, SECONDS)\n  .subscribe(aLong -> logger.d(\"Interval: %d\", aLong));\n```\n\nAnd then changed system clock to +2 hours at runtime of the app.\n\n**Before fix**\nAs expected computation scheduler gone crazy and fired about 700 events during one second.\n\n<img width=\"1160\" alt=\"screen shot 2015-12-15 at 08 44 57\" src=\"https:\/\/cloud.githubusercontent.com\/assets\/967132\/11803559\/1d2e29ee-a30d-11e5-960d-1489b3b0fb1c.png\">\n<img width=\"944\" alt=\"screen shot 2015-12-15 at 08 43 54\" src=\"https:\/\/cloud.githubusercontent.com\/assets\/967132\/11803560\/1d678ac2-a30d-11e5-888d-88d397767339.png\">\n\n**After fix**\nEverything was just fine! No incorrect events, no CPU consuming\n\n<img width=\"1165\" alt=\"screen shot 2015-12-15 at 09 01 06\" src=\"https:\/\/cloud.githubusercontent.com\/assets\/967132\/11803561\/1d73136a-a30d-11e5-9304-f25050ad4f58.png\">\n<img width=\"1006\" alt=\"screen shot 2015-12-15 at 09 00 42\" src=\"https:\/\/cloud.githubusercontent.com\/assets\/967132\/11803562\/1d7628a2-a30d-11e5-8c20-77a3b3c222fa.png\">\n\n---\n\nSo, I think #3461 and #3530 can be closed now!\n\nThanks, @akarnokd!\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-12-15T00:48:19Z","description":"There is a problem, reported in #3461 and #2943, in which if the system clock drifts, the periodic calculation inside Scheduler.Worker gets off and either taking a longer time for the next invocation of the task or doing \"catching-up\" with all the lost invocations.\n\nThe solution checks the wall clock difference between the last run and the current run and if it went back or forward significantly, it rebases the timer period and schedules the next execution relative to now.\n\nIf the clock goes back, the original code scheduled the next invocation way into the future. This PR will schedule it after the period.\n\nIf the clock goes forward, the original code scheduled executions for all the missed time between the last run and the new time immediately, yielding a bunch of 0 delays. This PR will simply schedule the next invocation after the period.\n\nThe algorithm for both cases is the same: make sure the next invocation is scheduled relative to now and recalculate the start timestamp as if the whole sequence run under the new drifted clock all along. The subsequent invocations will be scheduled at a fixed rate again.\n\nI've added the system parameter `rx.scheduler.drift-tolerance` (unit: minutes, default: 15 minutes), which is used to determine if the clock drifted too far between invocations of the periodic task.\n","id":"112804819","title":"1.x: compensation for significant clock drifts in schedulePeriodically","opened_on":"2015-10-22T13:36:45Z","closed_by":"abersnaze"},{"number":"3465","reopenOn":null,"comments":[{"date":"2016-02-04T10:10:30Z","author":"akarnokd","text":"Closing, will be included in the complete backport PR.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-04T10:10:30Z","description":"I forgot to request Long.MAX_VALUE in 3 of the `Subscribers.create`\noverloads.\n","id":"112790272","title":"2.x: fix Subscribers.create not requesting anything","opened_on":"2015-10-22T12:14:03Z","closed_by":"akarnokd"},{"number":"3461","reopenOn":null,"comments":[{"date":"2015-10-19T14:34:32Z","author":"akarnokd","text":"Thanks for reporting. It has been already reported in #2943.\n"},{"date":"2015-10-19T16:33:11Z","author":"tehmur","text":"Thanks for your swift reply.\n\nDo we have a feel of when we might have a fix for this on v1.x?\n"},{"date":"2015-10-19T16:35:54Z","author":"artem-zinnatullin","text":"\/\/ one of the possible fixes \u2014 Abstraction for Clock #3295.\n"},{"date":"2015-10-22T11:18:08Z","author":"nachodeh","text":"I also experienced this issue and it's quite serious. Will this be fixed soon? \n"},{"date":"2015-10-22T13:38:23Z","author":"akarnokd","text":"I've proposed a fix for this issue in #3467. I don't know if and when this can get into a release.\n"}],"opened_by":"tehmur","reopen":false,"closed_on":"2016-02-09T14:01:07Z","description":"On Android using this library, if the user changes the system time, there is a huge spike in the CPU usage emanating from the RXComputationThreadPool, without any expensive calls being made to the RX library.\n","id":"112156448","title":"High CPU usage after time changed on device","opened_on":"2015-10-19T14:28:11Z","closed_by":"akarnokd"},{"number":"3455","reopenOn":null,"comments":[{"date":"2015-10-16T21:52:05Z","author":"akarnokd","text":"Looks good to me. :+1:\n"},{"date":"2015-10-18T17:04:43Z","author":"zsxwing","text":"Could you also fix the similar issues in `Observable.subscribe` and `Observable.unsubscribe`? Here are tests to reproduce them:\n\n```\n    @Test(expected = OnErrorFailedException.class)\n    public void testOnErrorExceptionIsThrownFromSubscribe() {\n        Observable.<Integer>create(s1 ->\n                        Observable.<Integer>create(s2 -> {\n                            throw new IllegalArgumentException(\"original exception\");\n                        }).subscribe(s1)\n        ).subscribe(System.out::println, e -> {\n            throw new RuntimeException();\n        });\n    }\n\n    @Test(expected = OnErrorFailedException.class)\n    public void testOnErrorExceptionIsThrownFromUnsafeSubscribe() {\n        Observable.<Integer>create(s1 ->\n                        Observable.<Integer>create(s2 -> {\n                            throw new IllegalArgumentException(\"original exception\");\n                        }).unsafeSubscribe(s1)\n        ).subscribe(System.out::println, e -> {\n            throw new RuntimeException();\n        });\n    }\n\n```\n"},{"date":"2015-10-19T22:32:49Z","author":"konmik","text":"I would replace error handling in both of these methods with simple\n\n```\n    } catch (Throwable e) {\n        Exceptions.throwIfFatal(e);\n        try {\n            subscriber.onError(hook.onSubscribeError(e));\n        } catch (Throwable e2) {\n            throw new OnErrorFailedException(e2);\n        }\n        return Subscriptions.unsubscribed();\n    }\n```\n\nHowever, I think that the problem should be handled more generally. \nThe entire error handling policy should be reviewed and enforced.\nOtherwise we will always see swallowed exceptions here and there.\nUnfortunately, I don't have time right now to investigate the issue, I've just fixed what creates troubles for my current project.\n"},{"date":"2015-10-20T18:24:51Z","author":"benjchristensen","text":"Thanks for digging in to help with this. I thought we had squashed all of these swallowing of errors! Apparently not :-(\n"},{"date":"2015-10-20T18:26:21Z","author":"benjchristensen","text":":+1: Go ahead with this @akarnokd if you're still good with it. \n"},{"date":"2015-10-20T19:53:03Z","author":"akarnokd","text":"It is good as it is. Merging. The thing @zsxwing asked for can be done in a separate PR.\n"}],"opened_by":"konmik","reopen":false,"closed_on":"2015-10-20T19:53:11Z","description":"https:\/\/github.com\/ReactiveX\/RxJava\/issues\/2998\n","id":"111916142","title":"OnErrorFailedException fix","opened_on":"2015-10-16T21:41:48Z","closed_by":"akarnokd"},{"number":"3454","reopenOn":null,"comments":[{"date":"2015-10-20T18:27:24Z","author":"benjchristensen","text":"Don't have the time to fully grok this, but the changes look okay and I trust @akarnokd on this. So :+1: \n"},{"date":"2015-10-20T19:59:18Z","author":"akarnokd","text":"Thank you @benjchristensen. Since `replay()` is one of the most complicated operators, I'd like @abersnaze or @stealthcode to look at it before it ends up in 1.0.15.\n"},{"date":"2015-12-14T18:40:26Z","author":"stealthcode","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-12-14T19:10:32Z","description":"Fixes the bug reported in #3452.\n\nThe fix involves 3 changes:\n- First, each node in the bounded buffer receives an incrementing index whenever they are created. The root node starts with 0, the first value's index will be 1 and so on.\n- In the replay logic, the very first time the current node is captured, the node's index is added to the totalRequested amount of the subscriber. Since this is always one less than the max requested that far, there is no point in calling `manageRequests()` at this point.\n- Third, the pinning of the current node has to happen before the child requests, otherwise the difference would manifest before the compensation and some elements may get missed.\n\nIn addition, there was a missing `r--` in the emission loop and thus the operator could have overflown its child subscriber.\n","id":"111906106","title":"1.x: fix: bounded replay() not requesting enough for latecommers","opened_on":"2015-10-16T20:36:57Z","closed_by":"akarnokd"},{"number":"3452","reopenOn":null,"comments":[{"date":"2015-10-19T11:42:06Z","author":"akarnokd","text":"Fix in #3454.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-09T13:56:48Z","description":"Replay works by requesting as many items as the largest requester subscriber does. So if there is one with `request(2)` and another with `request(5)`, replay will `request(5)` from the upstream. To be precise, subscriber requests are accumulated and the operator requests the difference between the last known max and the latest known max. This way, if there is an additional `request(10)` from the first subscriber above, `replay` will request only 5 additional elements.\n\nThis works for the unbounded `replay()` because all subscribers start from the very beginning. However, if the buffer is bounded, this differencing doesn't work anymore. The following unit test fails with both 1.x and 2.x implementations.\n\n``` java\n@Test\npublic void testSubscribersComeAndGoAtRequestBoundaries() {\n    ConnectableObservable<Integer> source = Observable.range(1, 10).replay(1);\n    source.connect();\n\n    TestSubscriber<Integer> ts1 = TestSubscriber.create(2);\n\n    source.subscribe(ts1);\n\n    ts1.assertValues(1, 2);\n    ts1.assertNoErrors();\n    ts1.unsubscribe();\n\n    TestSubscriber<Integer> ts2 = TestSubscriber.create(2);\n\n    source.subscribe(ts2);\n\n    ts2.assertValues(2, 3);\n    ts2.assertNoErrors();\n    ts2.unsubscribe();\n\n    TestSubscriber<Integer> ts3 = TestSubscriber.create();\n\n    source.subscribe(ts3);\n\n    ts3.assertNoErrors();\n    ts3.assertValues(3, 4, 5, 6, 7, 8, 9, 10);\n    ts3.assertCompleted();\n}\n```\n\nWhat happens here is that even though `ts2` subscribes after 2 elements were requested from source, it only receives the very last and `replay()` doesn't request 1 more.\n\nThe idea about fixing this is that the total requested amount of late subscribers would start from a \"current index\", i.e., the number of items received by `replay()` so far. \n\nThis approach would work in this synchronous test but may not work with asynchronous subscribers. The problem is that the start node and the index has to be atomically updated together so a subscriber \"pins\" both at the same time: the continuous delivery is guaranteed as well as the proper total requested amount. I'll investigate to make this happen.\n\nLet me emphasize again that the unbounded `replay()` works properly and the v2 `ReplaySubject` isn't affected because it is unbounded-in.\n","id":"111895458","title":"Bounded replay() request coordination doesn't work properly with latecommers","opened_on":"2015-10-16T19:25:30Z","closed_by":"akarnokd"},{"number":"3438","reopenOn":null,"comments":[{"date":"2015-10-18T17:12:48Z","author":"zsxwing","text":":+1:\n"},{"date":"2015-10-18T19:38:11Z","author":"artem-zinnatullin","text":"Code is :+1:, but not sure I like null tolerance for exceptions\u2026 `subscriber.onError(null)` is like `throw null`.\n"},{"date":"2015-10-18T19:42:13Z","author":"akarnokd","text":"The problem is that NPEs will crash the streams further and likely end up hanging somewhere.\n"},{"date":"2015-10-18T19:44:55Z","author":"artem-zinnatullin","text":"Yeah, I understand\u2026 Okay, I guess.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-10-19T11:59:34Z","description":"There seems to be a tendency to send `null` values through `onError` which eventually causes repeated failures. This PR converts these `null` values into `NullPointerException`s so the error origin is can be discovered and prevents the XXXExceptions from throwing NPEs in their constructors as well.\n\nI've also added some missing javadoc.\n","id":"110914144","title":"Better null tolerance in rx.exceptions.*Exception classes.","opened_on":"2015-10-12T06:16:19Z","closed_by":"akarnokd"},{"number":"3436","reopenOn":null,"comments":[{"date":"2015-11-11T11:08:02Z","author":"akarnokd","text":":+1:\n"},{"date":"2015-11-13T02:08:22Z","author":"zsxwing","text":":+1: \n"}],"opened_by":"artem-zinnatullin","reopen":false,"closed_on":"2015-11-13T08:28:38Z","description":"Part of #3435.\n\nPersonally, I'd also add same test to `Observable.finallyDo()` and `Single.finallyDo()` because there are no guarantees that in future they will use exact same operator as implementation and this contract is more a contract of `Observable.finallyDo()` and `Single.finallyDo()`.\n","id":"110807242","title":"1.x: Add action != null check in OperatorFinally","opened_on":"2015-10-10T17:34:06Z","closed_by":"akarnokd"},{"number":"3435","reopenOn":null,"comments":[{"date":"2015-10-10T17:25:15Z","author":"artem-zinnatullin","text":"Here are the tests:\n\n``` java\n@Test\npublic void nullFinallyActionShouldBeCheckedASAP() {\n    try {\n        Observable\n                .just(\"value\")\n                .finallyDo(null);\n\n        fail();\n    } catch (NullPointerException expected) {\n\n    }\n}\n\n@Test\npublic void ifFinallyActionThrowsExceptionShouldNotBeSwallowedAndActionShouldBeCalledOnce() {\n    Action0 finallyAction = mock(Action0.class);\n    doThrow(new IllegalStateException()).when(finallyAction).call();\n\n    TestSubscriber<String> testSubscriber = new TestSubscriber<String>();\n\n    Observable\n            .just(\"value\")\n            .finallyDo(finallyAction)\n            .subscribe(testSubscriber);\n\n    testSubscriber.assertValue(\"value\");\n\n    verify(finallyAction).call();\n    \/\/ Actual result:\n    \/\/ Not only IllegalStateException was swallowed\n    \/\/ But finallyAction was called twice!\n}\n```\n"},{"date":"2015-10-10T17:26:16Z","author":"artem-zinnatullin","text":"I'll try to send PRs with fixes ASAP, `null` check is easy, but second problem looks tricky.\n"},{"date":"2015-10-12T05:45:27Z","author":"akarnokd","text":"If the action throws, you can't do much but call `RxJavaPlugins.getInstance().getErrorHandler().handleError()` for it.\n"},{"date":"2015-10-12T10:27:47Z","author":"artem-zinnatullin","text":"We can throw it as `Error`. Leaving the app in an unknown state is very bad idea, especially in something like `finallyDo()`.\n"},{"date":"2015-10-12T10:59:17Z","author":"akarnokd","text":"The sequence has already terminated at that point and this operator is there to have side-effects after it. The exception has nowhere to go and there is no guarantee a thrown error reaches its intended target because of a potential async boundary. So it either propagates up to a synchronous caller, gets thrown away by the `ExecutorService` or gets sent to the error handler.\n"},{"date":"2016-02-09T13:51:11Z","author":"akarnokd","text":"Can this be closed?\n"},{"date":"2016-02-09T17:16:48Z","author":"artem-zinnatullin","text":"@akarnokd won't be able to work on this for at least 2 days, feel free to run the tests I posted  ^ and see what we can do here or I'll investigate this in the end of the week.\n\nAs far as I remember, the biggest problem is that `action` gets called twice if it throws exception and it may break app's logic in a dramatic manner.\n"},{"date":"2016-04-02T23:51:38Z","author":"akarnokd","text":"Fix posted in #3823.\n"},{"date":"2016-04-14T18:15:24Z","author":"akarnokd","text":"Closing via #3823\n"}],"opened_by":"artem-zinnatullin","reopen":false,"closed_on":"2016-04-14T18:15:24Z","description":"While I was implementing #3434 I've found two problems with `OperatorFinally`.\n\nI'll call `OperatorFinally.action` as `finallyAction` for better readability.\n1. If `finallyAction` is `null` \u2014 `NullPointerException` will be swallowed by `SafeSubscriber`, this can be solved via `action != null` check in the `OperatorFinally` (I'll make PR).\n2. If `finallyAction` throws exception, `lift` calls `onError()` and `OperatorFinally` invokes `finallyAction` again (this may brake user-defined logic)! And second exception is swallowed by the `SafeSubscriber` (see problem 1).\n\nI vote for solving both of these problems before 1.0.15\/1.1.10.\n","id":"110806319","title":"OperatorFinally calls action twice if action throws exception. Exception thrown by action is swallowed","opened_on":"2015-10-10T17:10:02Z","closed_by":"akarnokd"},{"number":"3428","reopenOn":null,"comments":[{"date":"2015-10-10T01:58:19Z","author":"stealthcode","text":"The following test starts breaking with this branch. It prints out 1 to 128 then stops and does not print anything else (apparently no progress is made). In branch 1.x this continues to print past 128. \n\n``` java\nrange(1, RxRingBuffer.SIZE *4).repeat()\n    .groupBy((d) -> d)\n    .flatMap((go) ->\n        go.doOnNext(System.out::println)\n            .subscribeOn(Schedulers.io())\n    )\n    .subscribe();\n```\n"},{"date":"2015-10-10T06:40:35Z","author":"akarnokd","text":"This is because the lack of horizontal unboundedness of flatMap and the bug in groupBy together made it work in 1.0.14. If I run this code with the 2.x fix and add 1024 as the max concurrency value, it prints lots of values indefinitely.\n"},{"date":"2015-11-26T07:58:23Z","author":"akarnokd","text":"I've updated the comments.\n"},{"date":"2015-12-07T19:17:02Z","author":"stealthcode","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-12-07T19:35:08Z","description":"This is a backport of the 2.x GroupBy operator which solves #3425.\n\nOne unit test in OperatorRetryTest had to be altered a bit. I believe\nthe original code relied on a GroupBy behavior which caused the bug in\n#3425.\n","id":"110716648","title":"GroupBy backpressure fix","opened_on":"2015-10-09T18:51:46Z","closed_by":"akarnokd"},{"number":"3426","reopenOn":null,"comments":[{"date":"2015-10-09T16:45:49Z","author":"akarnokd","text":"I've  changed the code a bit to handle another request pattern besides the fix for #3425 .\n"},{"date":"2015-10-09T19:05:16Z","author":"akarnokd","text":"I've also fixed the subscriber of the group becoming visible before the Subscription is set (similar bug as in #3381).\n"},{"date":"2016-02-04T10:11:50Z","author":"akarnokd","text":"Closing, will be included in the complete backport PR.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-04T10:11:50Z","description":"The problem with GroupBy is that a request(1) from the main source may\nresult in a new group, a value for another group or value for the\nintended group. The latter two is handled by unicasting but the former\nwas not properly handled.\n","id":"110618723","title":"2.x: fix GroupBy MissingBackpressureException due to main\/group overflow","opened_on":"2015-10-09T09:13:18Z","closed_by":"akarnokd"},{"number":"3425","reopenOn":null,"comments":[{"date":"2015-10-09T08:09:33Z","author":"akarnokd","text":"It fails with 2.x too. I'll have a look at this within 2.x.\n"},{"date":"2015-10-09T09:21:35Z","author":"akarnokd","text":"I've looked into this with 2.x. The problem is that a `request(N)` may result in a new group beyond the requested amount by the main subscriber (i.e., the one that receives `GroupedObservable`s). Since consuming groups requires value replenishment from main, one can't be sure what the next value will be or where it will go (into the same group, into another group or into a completely new group).\n\nThe solution is to buffer the `GroupedObservable`s for the main subscriber and hand them out based on requests while letting the groups be consumed. Since we can't know the number of groups, this buffering has to be unbounded, similar to how each group has to be unbounded (due to the same reason as before: asking for replenishment for a group may result in a value for another group).\n\nI don't fully understand 1.x GroupBy so I don't know how to fix it with minimal changes. The best I can do is to port back the 2.x GroupBy, however, that requires `SpscLinkedArrayQueue` from #3169.\n"}],"opened_by":"abersnaze","reopen":false,"closed_on":"2015-12-14T18:50:38Z","description":"Someone here brought by some code that was throwing a MissingBackpressureException. Aaron and I narrowed it down to this snippet.\n\n`merge(range(0, 500).groupBy(i -> i % (RxRingBuffer.SIZE + 2)).observeOn(computation())).toBlocking().last()`\n\nit comes down observeOn requesting 128 Observables from groupBy and groupBy hard coded to request 1024 from range.\n\nWe fixed his problem changing the `observeOn(computation())` to `flatMap(grp -> grp.subscribeOn(computation()))`2\n","id":"110598412","title":"Outer groupBy doesn't obey backpressure","opened_on":"2015-10-09T06:54:00Z","closed_by":"abersnaze"},{"number":"3414","reopenOn":null,"comments":[{"date":"2016-02-04T10:11:57Z","author":"akarnokd","text":"Closing, will be included in the complete backport PR.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-04T10:11:57Z","description":"Discovered while reviewing the operator for my blog post.\n","id":"110172799","title":"2.x: fix operator Amb eager cancellation and request validation","opened_on":"2015-10-07T08:13:23Z","closed_by":"akarnokd"},{"number":"3413","reopenOn":null,"comments":[{"date":"2016-02-04T10:12:05Z","author":"akarnokd","text":"Closing, will be included in the complete backport PR.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-04T10:12:05Z","description":"The subject tries to avoid the request reduction via addAndGet by re-reading the requested amount and continuing the loop as long as possible. The bug was in ignoring the total emission amount and thus a single request(1) from the child ended up replaying all values.\n","id":"109988927","title":"2.x: fix to ReplaySubject not properly accounting for emitted events.","opened_on":"2015-10-06T11:34:28Z","closed_by":"akarnokd"},{"number":"3410","reopenOn":null,"comments":[{"date":"2015-10-08T04:20:07Z","author":"robinst","text":":+1: this will also give much nicer stack traces!\n\nHave you considered making them even nicer by using the [overload with a String](http:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/Objects.html#requireNonNull-T-java.lang.String-)? E.g. in `fromFuture`:\n\n``` java\n        Objects.requireNonNull(future, \"future\");\n        Objects.requireNonNull(unit, \"unit\");\n```\n"},{"date":"2015-10-08T06:58:51Z","author":"akarnokd","text":"Sounds good. Would you like to post a PR based on this PR?\n"},{"date":"2015-10-15T05:19:45Z","author":"robinst","text":"Sure, here you go: https:\/\/github.com\/akarnokd\/RxJava\/pull\/3\n"},{"date":"2015-10-15T05:55:05Z","author":"akarnokd","text":"Thanks @robinst. Merged in and squashed commits.\n"},{"date":"2016-02-04T10:12:12Z","author":"akarnokd","text":"Closing, will be included in the complete backport PR.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-04T10:12:12Z","description":"This PR adds over 900 new null checks. Null checks are essential because RS doesn't allow null values and sometimes a missed null check may lead to operator hangs as well.\n","id":"109667277","title":"2.x: null safety checks and fixes","opened_on":"2015-10-04T07:04:13Z","closed_by":"akarnokd"},{"number":"3408","reopenOn":null,"comments":[{"date":"2015-10-07T23:46:05Z","author":"abersnaze","text":":+1: \n"},{"date":"2016-03-14T15:51:27Z","author":"frvi","text":"Is there a way to avoid this wrapping?\nI want to throw a specific exception in my `doOnError`, which then gets handled in a certain way.\n"},{"date":"2016-03-14T18:13:19Z","author":"akarnokd","text":"No, but you can unwrap via onErrorResumeNext:\n\n``` java\nsource.doOnError(e -> { throw new RuntimeException(); })\n.onErrorResumeNext(e -> {\n    if (e instanceof CompositeException) {\n       return Observable.error(((CompositeException)e).getExceptions().get(1));\n    }\n    return Observable.error(e);\n});\n```\n"},{"date":"2016-03-15T09:17:21Z","author":"frvi","text":"@akarnokd -- ah, thanks!\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-10-07T23:46:39Z","description":"This came up in a [Stackoverflow](http:\/\/stackoverflow.com\/questions\/32889008\/do-operators-instead-of-a-whole-subscriber) answer. If the `doOnError`'s callback or the `doOnEach`'s `onError` method throws, any non-fatal exception replaced the original error which got lost. This PR will wrap them both into a `CompositeException`.\n\n2.x note: since Java 8 supports `addSuppressed` all callbacks in this situation either attach to the original exception or the original exception is attached to the callback's exception.\n","id":"109440489","title":"DoOnEach: report both original exception and callback exception.","opened_on":"2015-10-02T07:08:30Z","closed_by":"abersnaze"},{"number":"3387","reopenOn":null,"comments":[{"date":"2015-09-30T00:54:49Z","author":"artem-zinnatullin","text":"You're delaying emission of `just(1)`, then operator `scan()` does it's job and emits two values without delay.\n\nTry:\n\n``` java\nObservable\n  .just(1)\n  .scan(2, (accum, x) -> accum + x)\n  .delay(10, SECONDS)\n```\n"},{"date":"2015-09-30T07:08:29Z","author":"akarnokd","text":"This is a bug with the `scan` operator emitting its initial value only when the first value arrived and has been fixed via #3171. It will be part of the next release.\n"},{"date":"2015-09-30T13:06:17Z","author":"mbrandonw","text":"Thanks @akarnokd. I only just realized this issue is related to #3168, which I also filed.\n\nSo just to confirm, the expected behavior of `scan` is to emit the initial value immediately, and then the accumulated values as they come?\n"},{"date":"2015-09-30T13:49:19Z","author":"akarnokd","text":"Exactly.\n"},{"date":"2015-09-30T13:57:54Z","author":"mbrandonw","text":"perf thanks!\n"}],"opened_by":"mbrandonw","reopen":false,"closed_on":"2015-09-30T13:57:54Z","description":"Consider the following observable:\n\n``` java\nObservable.just(1)\n  .delay(10, TimeUnit.Seconds)\n  .scan(2, (accum, x) -> accum + x)\n```\n\nI would expect this to emit `2` immediately, and then 10 seconds later emit `3`. Instead it waits 10 seconds, and then emits `2` and `3` immediately.\n\nAm I interpreting this incorrectly?\n","id":"108982953","title":"Applying `scan` after `delay` will delay the initial value ","opened_on":"2015-09-29T23:53:16Z","closed_by":"mbrandonw"},{"number":"3384","reopenOn":null,"comments":[{"date":"2015-09-29T16:50:59Z","author":"stevegury","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-30T18:28:58Z","description":"Fixes the bug reported in  #3346. (I've done this for 1.x as well since the original poster disappeared). \n","id":"108813485","title":"Fix for take() reentrancy bug.","opened_on":"2015-09-29T07:54:40Z","closed_by":"abersnaze"},{"number":"3382","reopenOn":null,"comments":[{"date":"2015-09-30T19:37:26Z","author":"stealthcode","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-30T19:37:55Z","description":"Discovered while debugging #3381. Confirmed with JCTools in https:\/\/github.com\/JCTools\/JCTools\/pull\/80\n","id":"108652933","title":"2.x: fix SpscLinkedArrayQueue leaves 1 slot null just before growing","opened_on":"2015-09-28T12:58:02Z","closed_by":"stealthcode"},{"number":"3381","reopenOn":null,"comments":[{"date":"2016-02-04T10:12:18Z","author":"akarnokd","text":"Closing, will be included in the complete backport PR.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-04T10:12:18Z","description":"Discovered while the test `NbpOperatorConcatTest.testIssue2890NoStackoverflow` hung on Travis.\n\nWhat happened is that the reference to the child became visible before the call to its `onSubscribe` method so a concurrent source emitting at the exact same time could already see the \"unstarted\" child. The PR fixes this in both `NbpUnicastSubject` and `UnicastSubject` by changing the order of calls. The rest of the subjects behave correctly (call `onSubscribe` first, make child visible second).\n\nIn addition, `UnicastSubject` now calls `drain()` because when the `onSubscribe` calls `request` and `drain`, the child is not visible and nothing gets replayed. Once both `onSubscribe` call returns and the child is becomes visible, a call to `drain` again will now correctly replay all available contents that were requested.\n","id":"108623169","title":"2.x: UnicastSubject fix for the child becoming visible before onSubscribe is called.","opened_on":"2015-09-28T09:47:23Z","closed_by":"akarnokd"},{"number":"3380","reopenOn":null,"comments":[{"date":"2016-01-15T21:05:24Z","author":"abersnaze","text":"LGTM\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-01-15T21:05:27Z","description":"A terminal condition is now clearing the latest array which should help release its contents earlier in case a reference is kept to the class.\n","id":"108554882","title":"2.x: CombineLatest removed leftover debug field + better cleanup","opened_on":"2015-09-27T19:03:50Z","closed_by":"abersnaze"},{"number":"3377","reopenOn":null,"comments":[{"date":"2015-09-28T23:38:23Z","author":"stevegury","text":"Oh I see why it's a reentrancy problem, this is tricky indeed.\n\n:+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-28T23:52:36Z","description":"Discovered by @mgp in #3346 and using his supplied fix. I've already\napplied it to NbpObservable's take this Monday so all that's left was\nthe unit test.\n","id":"108380883","title":"2.x: fix take() reentrancy problem.","opened_on":"2015-09-25T18:13:45Z","closed_by":"abersnaze"},{"number":"3356","reopenOn":"2015-09-28T17:21:04Z","comments":[{"date":"2015-09-23T19:56:24Z","author":"stealthcode","text":"It seems to me that there are still outstanding questions as to the AsyncOnSubscribe usage. I am going to open a pull request with improved javadocs for the next function. This should help clear up confusion about it's usage. Also there are a couple items here that I'd like to discuss in greater depth. I am not okay with a complete rewrite (as you have provided here) but I would gladly accept contributions. Please read my comments below and reply so that we can move forward. \n\n> Exception thrown from the generateState is now delivered to the child immediately.\n\nGreat. Good improvement. I would like to see a pull request for this against the current existing code base. \n\n> There was a race-condition and memory leak when tracking the generated Observables.\n\nIs this the `HashSet<Subscription>`? I think that your usage of a `CompositeSubscription` was a good fix and necessary. Again, I think you could have made this fix to the existing code base very simply. \n\n> The first 2 requests were always Long.MAX_VALUE no matter what the child requested.\n\nWhen debugging your previous test it was clear to me that the `TestSubscriber` was not correctly using the `initialRequest` value to change the first `requested` amount in the underlying `Subscriber`. I do not think this behavior has anything to do with the AsyncOnSubscribe implementation. I commented to this effect in your issue #3341. \n\n> Both the individual generated Observables and the main concatenation could overflow the internal buffers and had to be defensively-buffered. \n\nCan you be more specific? The Buffer until subscriber uses an unbounded queue and I already commented that this was a known issue. I would accept a pull request to address this issue against the existing code base. \n\n> If a request was responded with a generated Observable that delivered less than this requested amount, the child ended up hanging.\n\nThe observables emitted to the observer should emit exactly `n`. If they emit less than `n` then the observer must be `onCompleted()` as there is no more data available. Your test does not call a terminal event on the observer so I would expect this to hang. This is the area where the documentation needs to be improved (and I will open a pull request to improve this). It makes perfect sense how you would perceive this as a bug. I am open to ideas. However that will require that you communicate with me over the designs and present alternatives. \n\n> The concatenation didn't know about the number of values it should deliver in aggregate and might have delivered more or less, causing MissingBackpressureException or hangs.\n\nI deliberately chose not to validate the quantity of onNexted events. This is like validating at every level when it will invalidate intermittently at runtime and then blow up or if you don't implement validation then a missing back pressure exception is thrown intermittently, and it blows up at runtime. Is there anything better that we can do? I vote to not validate and trust that the user of the AsyncOnSubscribe follows the contract (that we will document in detail). \n"},{"date":"2015-09-23T20:42:01Z","author":"akarnokd","text":">  I am not okay with a complete rewrite (as you have provided here) but I would gladly accept contributions.\n\nFirst of all, this isn't a complete rewrite as I kept everything else that wasn't contributing to a bug. The API is still the same and the behavior is what looked like you'd like to achieve: client requests of n_i should be responded to with a single Observable that produces n_i values or (less + completes the main sequence).\n\n>  against the current existing code base.\n\nThe fixes apply together, not in parts.\n\n>  it was clear to me that the TestSubscriber was not correctly using the initialRequest value to change the first requested amount in the underlying Subscriber\n\nWe use this constructor in many other tests that require zero request upfront. It works there. Your code composed the various `Subscriber`s and `Producer`s in a wrong way and the default `Long.MAX_VALUE` was requested way before the end `TestSubscriber` could issue a request.\n\n> The Buffer until subscriber uses an unbounded queue and I already commented that this was a known issue. I would accept a pull request to address this issue against the existing code base.\n\n`BufferUntilSubscriber` doesn't support backpressure and thus 3 subsequent requests of any size would generate 3 sources but `concat` accepts 2 at a time. In addition, there is no way to know if the user actually returned a backpressure-supporting Observable or not. In `testSerializesConcurrentObservables` you actually over-deliver and the `concat` would fail with an `IllegalStateException`.\n\nI have a version of `BufferUntilSubscriber` in #3150 and before that in #3050 waiting for review for months now. And again, that would still leave the `AsyncOnSubscribe` buggy so why do separate PRs that would conflict with each other due to line differences? \n\n> The observables emitted to the observer should emit exactly n. If they emit less than n then the observer must be onCompleted() as there is no more data available.\n\n`testUnderdeliveryCorrection` tests for the case where the developer generated the wrong source which doesn't deliver enough values. It wasn't meant to be a finite sequence and not meant to call `onComplete`; what mattered is how it responded to `requestMore` calls.\n\n> I deliberately chose not to validate the quantity of onNexted events. This is like validating at every level when it will invalidate intermittently at runtime and then blow up or if you don't implement validation then a missing back pressure exception is thrown intermittently, and it blows up at runtime. Is there anything better that we can do? I vote to not validate and trust that the user of the `AsyncOnSubscribe` follows the contract (that we will document in detail).\n\nYou don't seem to understand how `concat` backpressure works: The client requests `n` and the `concat` operator forwards that amount to its first source. Because individual sources may deliver less than this value, `concat` has to check the number of produced elements so in case a new source is started, concat can request this remaining amount from it. This is what the `ProducerArbiter` manages.\n\nYour original code forgot to tell `concat` how many elements to expect and always run in unbounded mode regardless of the original child request value.\n"},{"date":"2015-09-23T21:16:14Z","author":"stealthcode","text":"@akarnokd I here you. Here is my concern. I have asked you directly for you feedback over the design and I have not received from you what I think is sufficient input to see that we both agree on the design or even the goals. My last impression from you regarding the `AsyncOnSubscribe` was that you simply didn't even agree with its existence and your questions seemed to indicate that you didn't understand why I implemented it. So when you commented on the pull request (after it was merged) with bugs without test code or details of how to reproduce, I was unclear about your interpretation of the design and asked you to file detailed issues with reproducible test code. \n\nAll of that said, I need confirmation that you and I are trying to achieve the same goals before I consider merging this. \n"},{"date":"2015-09-23T21:20:21Z","author":"benjchristensen","text":"1) Design \n\nIt seems much of the disagreement between you two is that the design and approach was not well discussed, and instead we have jumped to implementations without a common understanding. That discussion is dangling here: https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3003 @akarnokd You need to involve yourself in that discussion where I and @stealthcode have weighed in, but not received further feedback.\n\n2) Rewriting Code\n\nIt is generally not helpful to start from scratch unless there is upfront agreement that the original should not be pursued or iterated upon. Forking in two directions dilutes the discussion, pits egos against each other, and prevents collaboration. \n\nI view this PR as a rewrite. Looking at the two side-by-side shows hardly any code left behind, and the algorithms are changed, and it's hard to tell what is actually because of issues versus just stylistic differences between them.  This in turn forces everyone to start from scratch in reading the code, understanding the issues and making decisions. If there is something fundamental about the original code that prevents correct behavior, then I suggest that be discussed up front with the original author. \n\n3) Communication & Collaboration\n\nThe underlying contention I sense between you two is shown in places such as:\n- https:\/\/github.com\/ReactiveX\/RxJava\/pull\/3203#issuecomment-135358972\n- https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3341#issue-106142277\n\nPlease communicate with respect for each other. \n\nAnother example of statement that is not helpful:\n\n> You don't seem to understand how concat backpressure works:\n\n@akarnokd I could say very similar things if I wanted to about bugs you wrote into the last revision of `merge` ([1](https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2928#discussion_r32747249), [2](https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3156)), or the recent discussion about `Subject` in https:\/\/github.com\/ReactiveX\/RxJava\/pull\/3349. Please do not make things personal (such as in https:\/\/github.com\/ReactiveX\/RxJava\/pull\/3349#issuecomment-142037400). \n\nI too have submitted PRs with mistakes and bugs. All of us have. We do code reviews and patch releases for a reason, otherwise we should have been done this project a year ago. \n\nStick to objective statements of functionality, performance, and usage. A bug is a bug. A misunderstanding is just that. Overlooking something is easy, particularly when dealing with asynchrony, concurrency, flow control and the like. This particular `AsyncOnSubscribe` behavior is non-trivial, otherwise it wouldn't be this big of a discussion. Let's not trivialize it or attack people.\n\n4) Next Steps\n\nBoth of you (@akarnokd & @stealthcode) are great engineers, but with different strengths and weaknesses. That is a great thing for the project to have those diverse viewpoints and skills. \n\nPlease focus more on communication and less on the code for a bit. Code is honestly the easiest part of our job. In the long run, healthy collaboration is far more important that sprinting on code.\n"},{"date":"2015-09-24T06:27:08Z","author":"akarnokd","text":"I did my part in reviewing the code and providing fixes. If you think the original version is what you wanted then its up to you and there is no point in discussing this any further. \n"},{"date":"2015-09-28T17:21:01Z","author":"stealthcode","text":"> You don't seem to understand how concat backpressure works\n\nI misunderstood your original statement. My mistake. \n\nI reviewed the code and it looks fine :+1: \n"}],"opened_by":"akarnokd","reopen":true,"closed_on":"2015-09-29T17:19:45Z","description":"There were several problems with the operator:\n- The first 2 requests were always `Long.MAX_VALUE` no matter what the child requested.\n- There was a race-condition and memory leak when tracking the generated `Observable`s.\n- Both the individual generated `Observable`s and the main concatenation could overflow the internal buffers and had to be defensively-buffered.\n- If a request was responded with a generated `Observable` that delivered less than this requested amount, the child ended up hanging.\n- The concatenation didn't know about the number of values it should deliver in aggregate and might have delivered more or less, causing `MissingBackpressureException` or hangs.\n- Exception thrown from the `generateState` is now delivered to the child immediately.\n\nAs I see, the usage is as follows. Each individual `request()` from the child is supposed to be fulfilled by individual `Observable`s. For example, `request(1)` and `request(5)` will generate two distinct `Observable`s where the first will have 1 value and the second 5.\n","id":"107322422","title":"Fix to a bunch of bugs and issues with AsyncOnSubscribe","opened_on":"2015-09-19T09:51:55Z","closed_by":"stealthcode"},{"number":"3347","reopenOn":null,"comments":[{"date":"2016-02-09T13:45:43Z","author":"akarnokd","text":"Looks like that handler call is at the wrong place and belongs to after throwIfFatal. I'll post a PR for this.\n"},{"date":"2016-02-09T13:49:29Z","author":"akarnokd","text":"See #3685\n"},{"date":"2016-03-14T00:01:13Z","author":"akarnokd","text":"Closing via #3689\n"}],"opened_by":"mgp","reopen":false,"closed_on":"2016-03-14T00:01:14Z","description":"From its Javadoc:\n\n> Represents a `Throwable` that an `Observable` might notify its subscribers of, but that then can be handled by an operator that is designed to recover from or react appropriately to such an error.\n\nFrom this description I was thinking that operators like `onErrorResumeNext` might wrap emitted `Throwables` in an `OnErrorThrowable` instance using its `from` static factory method, and then pass that `OnErrorThrowable` instance to the global error handler. But the `onError` method of `OperatorOnErrorResumeNextViaFunction` looks like:\n\n``` java\n@Override\npublic void onError(Throwable e) {\n    if (done) {\n        Exceptions.throwIfFatal(e);\n        return;\n    }\n    done = true;\n    try {\n        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);\n\n        ...\n```\n\nAnd so the \"raw\" `Throwable` is passed to the global error handler instead.\n\nThe problem we're trying to solve is this: the global error handler in our app forwards errors to Crashlytics. But we want to only forward `Throwable` instances that we're not already recovering from by methods like `onErrorResumeNext`. I was hoping that `onErrorResumeNext` would wrap such errors in `OnErrorThrowable` or something equivalent and our global error handler could only forward errors if they are not of this type.\n\nAny thoughts on how we can achieve this behavior? Thanks!\n","id":"106696739","title":"When is OnErrorThrowable created and received?","opened_on":"2015-09-16T04:32:19Z","closed_by":"akarnokd"},{"number":"3346","reopenOn":null,"comments":[{"date":"2015-09-15T20:51:48Z","author":"akarnokd","text":"Hi and thanks for discovering this. The behavior is not intentional. We are generally not prepared for synchronous reentry such as this. Solving it is a bit tricky because a delicate behavior needs to be ensured right at the limit. Here is how I'd fix this:\n- I'd introduce a `boolean stop` variable on the parent Subscriber\n- I'd change the onNext to have the reentrancy protection:\n\n``` java\n@Override\npublic void onNext(T i) {\n    if (!isUnsubscribed()) {\n        boolean stop = ++count >= limit;\n        if (stop) {\n            if (this.stop) {\n                return;\n            }\n            this.stop = true;\n        }\n        child.onNext(i);\n        if (stop && !completed) {\n            completed = true;\n            try {\n                child.onCompleted();\n            } finally {\n                unsubscribe();\n            }\n        }\n    }\n}\n```\n\nThis will prevent a recursive onNext call to be delivered after the limit.\n"},{"date":"2015-09-15T21:15:06Z","author":"mgp","text":"Thanks for the response! I think alternatively you could do:\n\n``` java\nif (!isUnsubscribed() && (count++ < limit)) {\n    boolean stop = count >= limit;\n    child.onNext(i);\n    if (stop && !completed) {\n        completed = true;\n        try {\n            child.onCompleted();\n        } finally {\n            unsubscribe();\n        }\n    }\n}\n```\n\nWhich only changes the outer conditional and the computation of `stop`. LMK if that sounds good and I'll prepare a PR?\n"},{"date":"2015-09-15T21:24:14Z","author":"akarnokd","text":"Looks even better, go ahead with the PR.\n"},{"date":"2015-09-25T18:04:14Z","author":"akarnokd","text":"@mgp Are you going to post a PR against 1.x?\n"},{"date":"2015-10-01T10:38:51Z","author":"akarnokd","text":"Closing via #3384.\n"}],"opened_by":"mgp","reopen":false,"closed_on":"2015-10-01T10:38:51Z","description":"This can happen if a `doOnNext` action downstream can cause the observable upstream to emit another value. Here's a test that demonstrates this behavior:\n\n``` java\n@Test\npublic void testEmittingMoreValuesThanLimit() {\n    final AtomicBoolean emittedFirstValue = new AtomicBoolean(false);\n    final PublishSubject<Integer> subject = PublishSubject.create();\n    final int firstValue = 1;\n    final int secondValue = 2;\n\n    \/\/ Record emitted values with this action.\n    Action1<Integer> record = mock(Action1.class);\n    InOrder inOrder = inOrder(record);\n\n    subject\n            .take(1)\n            .doOnNext(record)\n            .doOnNext(new Action1<Integer>() {\n                @Override\n                public void call(final Integer integer) {\n                    \/\/ As the first value passes through, emit the second value.\n                    if (!emittedFirstValue.getAndSet(true)) {\n                        subject.onNext(secondValue);\n                    }\n                }\n            })\n            .subscribe();\n\n    inOrder.verifyNoMoreInteractions();\n\n    \/\/ Will record both values even though take(1) is upstream.\n    subject.onNext(firstValue);\n    subject.onCompleted();\n    inOrder.verify(record).call(firstValue);\n    inOrder.verify(record).call(secondValue);\n    inOrder.verifyNoMoreInteractions();\n}\n```\n\nI first noticed this in a project that uses RxJava 1.1.10. The `onNext` implementation of `OperatorTake` has changed a bit in master. Before I go ahead and submit a PR that fixes this behavior, I just wanted to ensure that it wasn't deliberate? Thanks!\n","id":"106609366","title":"1.x Take operator can emit more values than its limit","opened_on":"2015-09-15T17:50:44Z","closed_by":"akarnokd"},{"number":"3339","reopenOn":null,"comments":[{"date":"2015-09-11T16:51:53Z","author":"benjchristensen","text":"What is the purpose of this operator? Why is it added?\n"},{"date":"2015-09-11T16:52:55Z","author":"benjchristensen","text":"Huh. That exists in 1.x?! Never seen or heard of it.\n"},{"date":"2015-09-11T16:54:24Z","author":"benjchristensen","text":"> Btw, should an onComplete from this inner publisher be treated as an indication to not subscribe to the actual source?\n\nThat's a good question ... the 1.x docs say it subscribes if the given Observable emits. `onComplete` is not an \"emission\" in the normal sense. So probably not.\n"},{"date":"2015-10-03T13:53:34Z","author":"akarnokd","text":"I'll add this fix and unit test to a larger set of unit tests + fixes coming separately.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-10-03T13:53:34Z","description":"The subscription was triggered by the supplied publisher and not one of its value or completion.\n\nBtw, should an `onComplete` from this inner publisher be treated as an indication to not subscribe to the actual source?\n","id":"105974616","title":"2.x: fix delaySubscription with supplied publisher: wrong value to trigger subscription","opened_on":"2015-09-11T09:21:21Z","closed_by":"akarnokd"},{"number":"3335","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-09T14:11:27Z","description":"- I wanted to make sure the slow path passes all tests before enabling\n  the scalar optimization.\n- Fixed headers for internal classes\n","id":"105603057","title":"2.x: scalar flatMap optimization enabled","opened_on":"2015-09-09T14:03:42Z","closed_by":"akarnokd"},{"number":"3334","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-09T13:24:07Z","description":"- sorted `Observable` and added `@BackpressureSupport` and\n  `SchedulerSupport` annotations.\n- created `@Beta` and `@Experimental` annotations, nothing is marked\n  with them because I intent everything to be standard at this point.\n","id":"105594373","title":"2.x: disposable unit tests + fix to RefCountDisposable behavior","opened_on":"2015-09-09T13:16:41Z","closed_by":"akarnokd"},{"number":"3333","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-09T11:40:26Z","description":"I had to ignore many tests because they either test with null or throw\nan exception from a Subscriber method which are not allowed with RS.\n- added Observers and Subscribers to create Observers\/Subscribers with convenience.\n","id":"105578650","title":"2.x: subscribers\/observers tests","opened_on":"2015-09-09T11:33:14Z","closed_by":"akarnokd"},{"number":"3332","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-09T08:39:54Z","description":"- Fixed the `testNestedAsyncConcat` test.\n- Fixed memory leak in `NewThreadWorker`.\n","id":"105540494","title":"2.x: subject tests and bugfixes","opened_on":"2015-09-09T08:08:53Z","closed_by":"akarnokd"},{"number":"3331","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-08T21:04:26Z","description":"","id":"105462584","title":"2.x: schedulers test of classic schedulers","opened_on":"2015-09-08T20:27:36Z","closed_by":"akarnokd"},{"number":"3329","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-08T18:04:38Z","description":"I had to adjust some test slightly due to the a new behavior: if one\ncancels a source which is windowed, as long as the windows are active,\nthe source has to stay active. However, there are more subtle\npossibilities that need new tests.\n","id":"105436460","title":"2.x: operator test: window variants","opened_on":"2015-09-08T17:57:02Z","closed_by":"akarnokd"},{"number":"3328","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-08T14:24:43Z","description":"- fixed cancellation behavior of observeOn, subscribeOn and\n  unsubscribeOn (when and what to call cancel on)\n- fixed infinite loop in ScheduledRunnable\n- fixed zip not quitting eagerly if one of the sources was shorter\n- added specific ZipIterable because zip-iterable tests expect it to be\n  not prefetching any of the sources (the plain zip does prefetch)\n- made the fromIterable more resilient to Iterable\/Iterator crashes and\n  added null-value checks\n","id":"105391150","title":"2.x: operator tests unsubscribeOn, withLatestFrom, zip (partial)","opened_on":"2015-09-08T14:19:13Z","closed_by":"akarnokd"},{"number":"3327","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-08T11:27:43Z","description":"- signature fix to toMultimap and removed deprecated markers.\n","id":"105355646","title":"2.x: operator tests: timestamp, toMap, toMultiMap, toList, toSortedList","opened_on":"2015-09-08T11:11:29Z","closed_by":"akarnokd"},{"number":"3326","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-08T10:22:25Z","description":"","id":"105347067","title":"2.x: operator throttleFirst, timeInterval and timeout + bugfixes","opened_on":"2015-09-08T10:16:15Z","closed_by":"akarnokd"},{"number":"3325","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-08T09:14:11Z","description":"- fixed a deadlock possibility in one of the merge tests\n","id":"105334885","title":"2.x: operator tests: take family + fixes","opened_on":"2015-09-08T09:05:32Z","closed_by":"akarnokd"},{"number":"3324","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-08T07:47:10Z","description":"","id":"105320377","title":"2.x: operator test: switchIfEmpty, switchMap + bugfixes","opened_on":"2015-09-08T07:41:21Z","closed_by":"akarnokd"},{"number":"3323","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-07T21:04:28Z","description":"Note that since we know have time unit in schedulers, one must be\ncareful with the time unit of the timed skip operators. The timestamps\nwill be calculated via this unit and may not return the expected values. \n\nFor example, a skipLast of 1 second will not skip the value 0.5 seconds\nbefore completion because its timestamp is rounded down to the start of\nthe second. But if one uses 1000 milliseconds, the value will be\nskipped.\n","id":"105266857","title":"2.x: operator test: skip variants and bugfix","opened_on":"2015-09-07T21:00:10Z","closed_by":"akarnokd"},{"number":"3322","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-07T20:24:14Z","description":"","id":"105263484","title":"2.x: operator test: serialize, single + SerializedSubscriber fix","opened_on":"2015-09-07T20:16:08Z","closed_by":"akarnokd"},{"number":"3321","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-07T19:42:34Z","description":"","id":"105261054","title":"2.x: operator tests: sample, scan and sequenceEqual + their bugfixes","opened_on":"2015-09-07T19:38:06Z","closed_by":"akarnokd"},{"number":"3320","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-07T18:42:23Z","description":"- retry with bipredicate\n- fixed map not checking the returned value for null\n- since RS doesn't allow throwing other than NPE, temporarily subscribe\n  and lift will throw NPE with the actual error as cause so we don't miss\n  an operator bug due to swallowed exceptions.\n","id":"105255571","title":"2.x: operator test: retry, retryWhen","opened_on":"2015-09-07T18:36:56Z","closed_by":"akarnokd"},{"number":"3319","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-07T16:43:59Z","description":"Note that testIssue_2191_SchedulerUnsubscribe had to change the call\ncount to pass. I don't understand this test and the over-mocking (but\nrecognize the style).\n","id":"105245050","title":"2.x: operator test for replay","opened_on":"2015-09-07T16:38:51Z","closed_by":"akarnokd"},{"number":"3318","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-07T14:38:00Z","description":"- added toSingle and toNbpObservable to Observable\n- fixed bugs in many operators and in the IO scheduler's release logic\n","id":"105226308","title":"2.x: operator tests: publish, reduce, repeat + fixes","opened_on":"2015-09-07T14:33:17Z","closed_by":"akarnokd"},{"number":"3317","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-07T13:05:52Z","description":"I had to ignore tests that throw exceptions from a Publisher.subscribe or an Operator.apply due to their non-conformant behavior.\n","id":"105211744","title":"2.x: operator test onError and onException, relevant bugfixes","opened_on":"2015-09-07T13:01:10Z","closed_by":"akarnokd"},{"number":"3316","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-07T12:24:36Z","description":"","id":"105205183","title":"2.x: operator test onBackpressure(Buffer|Drop|Latest) and their bugfix","opened_on":"2015-09-07T12:19:02Z","closed_by":"akarnokd"},{"number":"3315","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-07T11:48:22Z","description":"- fix to observeOn to not request if cancelled in onNext delivery\n- fix combineLatest error emission if the other sources are late or\n  never emit\n- fix interval and PublishSubject to send MissingBackpressureException\n","id":"105199295","title":"2.x: operator test observeOn","opened_on":"2015-09-07T11:31:16Z","closed_by":"akarnokd"},{"number":"3313","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-07T09:29:16Z","description":"for GroupedObservable\n- added BooleanSubscription to detect cancellation without caring about\n  requests.\n\nI'm still not 100% convinced the groupBy request coordination works\nproperly (i.e., no stall due lack of requests from one of the groups).\n","id":"105180817","title":"2.x: operator test for groupBy; fix to groupBy and type argument swap","opened_on":"2015-09-07T09:24:11Z","closed_by":"akarnokd"},{"number":"3312","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-07T08:31:10Z","description":"- added operator flatMap of notifications, fixed a bug in onBackpressureBuffer\n\nNote also the few ignored tests because they either want to test against a null value or try to throw from RS methods.\n","id":"105171187","title":"2.x: operator test flatMap, merge, mergeDelayError","opened_on":"2015-09-07T08:26:49Z","closed_by":"akarnokd"},{"number":"3309","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-06T18:23:41Z","description":"Note: several tests have been ignored due to non-conformance with RS\n\nAdded missing distinct and distinctUntilChanged overloads, fixed doOnEach not cancelling upstream if the callback crashes on the onNext path.\n","id":"105108008","title":"2.x: operator test distinct, distinctUntilChanged and doOnEach","opened_on":"2015-09-06T18:19:12Z","closed_by":"akarnokd"},{"number":"3307","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-06T17:08:58Z","description":"When debounce is completed, the last value encountered is emitted immediately.\n","id":"105104377","title":"2.x: Operator debounce and defaultIfEmpty, fix to debounce behavior","opened_on":"2015-09-06T17:05:06Z","closed_by":"akarnokd"},{"number":"3306","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-06T16:33:02Z","description":"The concat reuses the same inner subscriber to save on its allocation\ncost which works only if the inner source conforms with the spec and\ndoesn't emit any event after an onComplete(). There is a test that\nexplicitly calls onComplete() twice to test the resilience of concat.\nThe current workaround makes this test pass but any async non-conforming\nsource may still bug out the operator. \n\nThis is a tradeoff between safety and performance. If we'd expect such\nnon-conforming behavior, the current optimization has to be turned into\na regular individually allocated inner subscribers.\n","id":"105102636","title":"2.x: operators cast and concat tests","opened_on":"2015-09-06T16:26:53Z","closed_by":"akarnokd"},{"number":"3301","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-04T13:09:17Z","description":"","id":"104887024","title":"2.x: test for buffer, I'm still missing the boundary-supplier version","opened_on":"2015-09-04T13:05:39Z","closed_by":"akarnokd"},{"number":"3300","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-04T11:41:29Z","description":"Bugfix: since they would emit a value on an empty source, they have to hold it until an actual request comes in.\n","id":"104874888","title":"2.x: test for operators all, any, asObservable, fixes to all and any","opened_on":"2015-09-04T11:37:50Z","closed_by":"akarnokd"},{"number":"3298","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-04T09:36:56Z","description":"","id":"104857892","title":"2.x: tests for refCount and timer, fixes to flatMap, publish and range","opened_on":"2015-09-04T09:32:50Z","closed_by":"akarnokd"},{"number":"3297","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-04T08:12:22Z","description":"","id":"104847053","title":"2.x: unit tests and fixes for fromIterable and range","opened_on":"2015-09-04T08:08:13Z","closed_by":"akarnokd"},{"number":"3294","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-03T22:06:38Z","description":"","id":"104790486","title":"More tests and bugfixes to operators.","opened_on":"2015-09-03T22:04:01Z","closed_by":"akarnokd"},{"number":"3287","reopenOn":null,"comments":[{"date":"2015-09-03T20:45:34Z","author":"stealthcode","text":"Nice find. Opening a pull request for fix. \n"},{"date":"2015-09-09T14:14:51Z","author":"akarnokd","text":"Fixed via #3285.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-09T14:14:51Z","description":"The following program demonstrates the issue. If a request runs in parallel with a cancellation, both may end up calling the unsubscription callback, which I believe should't happen with the operator.\n\n``` java\npublic class SyncOnSubscribeRace {\n    public static void main(String[] args) throws Exception {\n        final AtomicInteger wip = new AtomicInteger();\n\n        Func0<AtomicInteger> func0 = new Func0<AtomicInteger>() {\n            @Override\n            public AtomicInteger call() {\n                return wip;\n            }\n        };\n        Func2<AtomicInteger, Observer<? super Integer>, AtomicInteger> func2 = \n                new Func2<AtomicInteger, Observer<? super Integer>, AtomicInteger>() {\n            @Override\n            public AtomicInteger call(AtomicInteger s, Observer<? super Integer> o) { \n                o.onNext(1); \n                return s; \n            }\n        };\n        Action1<? super AtomicInteger> action1 = new Action1<AtomicInteger>() {\n            @Override\n            public void call(AtomicInteger s) {\n                s.getAndIncrement();\n            }\n        };\n        Observable<Integer> source = Observable.create(\n                SyncOnSubscribe.createStateful( \n                func0, \n                func2, action1\n        ));\n\n        ExecutorService exec = Executors.newSingleThreadExecutor();\n\n        try {\n            for (int i = 0; i < 100_000; i++) {\n                if (i % 1 == 0) {\n                    System.out.println(\">> \" + i);\n                }\n                int j = wip.get();\n                TestSubscriber<Integer> ts = TestSubscriber.create(0);\n                source.subscribe(ts);\n\n                final CyclicBarrier cb = new CyclicBarrier(2);\n\n                Future<?> f = exec.submit(new Callable<Object>() {\n                    @Override\n                    public Object call() throws Exception {\n                        cb.await();\n                        ts.requestMore(1);\n                        return null;\n                    }\n                });\n\n                cb.await();\n                ts.unsubscribe();\n                f.get();\n\n                if (j + 1 != wip.get()) {\n                    throw new AssertionError(\"Unsubscribe called multiple times: \"\n                         + (wip.get() - j));\n                }\n            }\n        } finally {\n            exec.shutdownNow();\n        }\n    }\n}\n```\n","id":"104565548","title":"SyncOnSubscribe can call the unsubscription callback multiple times","opened_on":"2015-09-02T20:32:43Z","closed_by":"akarnokd"},{"number":"3285","reopenOn":null,"comments":[{"date":"2015-09-02T19:55:09Z","author":"akarnokd","text":"#3286 has encountered another failure:\n\n```\nrx.observables.SyncOnSubscribeTest > testSubscribeOn FAILED\n    java.lang.AssertionError: expected:<4> but was:<3>\n        at org.junit.Assert.fail(Assert.java:93)\n        at org.junit.Assert.failNotEquals(Assert.java:647)\n        at org.junit.Assert.assertEquals(Assert.java:128)\n        at org.junit.Assert.assertEquals(Assert.java:472)\n        at org.junit.Assert.assertEquals(Assert.java:456)\n        at rx.observables.SyncOnSubscribeTest.testSubscribeOn(SyncOnSubscribeTest.java:734)\n```\n"},{"date":"2015-09-03T21:23:08Z","author":"stealthcode","text":"This should also resolve #3287. I have added your example test to the unit tests (3,000 iterations).\n"},{"date":"2015-09-04T18:14:45Z","author":"abersnaze","text":":+1: \n"},{"date":"2015-09-04T21:00:48Z","author":"akarnokd","text":"Okay, let's merge this so other PRs don't run into the test bug with the current main.\n"}],"opened_by":"stealthcode","reopen":false,"closed_on":"2015-09-04T21:00:56Z","description":"","id":"104553144","title":"Added latch to async SyncOnSubscrbeTest","opened_on":"2015-09-02T19:16:29Z","closed_by":"akarnokd"},{"number":"3280","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-02T14:36:31Z","description":"Bugfixes in many operators.\n","id":"104492453","title":"ObservableTests and bugfixes.","opened_on":"2015-09-02T14:24:52Z","closed_by":"akarnokd"},{"number":"3279","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-02T12:25:22Z","description":"Forgot to call request, refactored some validation code.\n","id":"104468161","title":"ConversionTest and DoOnTest","opened_on":"2015-09-02T12:22:25Z","closed_by":"akarnokd"},{"number":"3275","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-02T10:28:57Z","description":"Forgot to deliver the value inside the GroupedUnicast drain loop.\n","id":"104448586","title":"Simplest combineLatest tests and fix to groupBy.","opened_on":"2015-09-02T10:25:52Z","closed_by":"akarnokd"},{"number":"3271","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-09-02T09:11:23Z","description":"Fixed mistakes in the operators.\n","id":"104429193","title":"First unit test and fixes to operators.","opened_on":"2015-09-02T08:44:52Z","closed_by":"akarnokd"},{"number":"3223","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-08-28T11:43:24Z","description":"Also corrected the naming of one-shot timer and fixed-period interval\n","id":"103703072","title":"Fixes to classes, convenience operators mostly.","opened_on":"2015-08-28T11:39:17Z","closed_by":"akarnokd"},{"number":"3219","reopenOn":null,"comments":[{"date":"2015-08-28T07:21:09Z","author":"akarnokd","text":"Could you post the example in plain Java?\n"},{"date":"2015-08-28T08:28:15Z","author":"rayshih","text":"The following is the equivalent java code (except the log function)\n\n``` java\nBehaviorSubject<String> password = BehaviorSubject.create(\"\");\n\nConnectableObservable<Boolean> passwordIsValid = password.map(new Func1<String, Boolean>() {\n    @Override\n    public Boolean call(String s) {\n        return s.length() >= 8;\n    }\n}).startWith(false).\ndoOnSubscribe(new Action0() {\n    @Override\n    public void call() {\n        Log.d(\"RxBug\", \"on subscribe\");\n    }\n}).\ndoOnNext(new Action1<Boolean>() {\n    @Override\n    public void call(Boolean v) {\n        Log.d(\"RxBug\", \"do on next => \" + v);\n    }\n}).replay(1);\n\npasswordIsValid.connect();\n\npassword.onNext(\"1\");\npassword.onNext(\"12\");\npassword.onNext(\"12345678\");\npasswordIsValid.subscribe(new Action1<Boolean>() {\n    @Override\n    public void call(Boolean v) {\n        Log.d(\"RxBug\", \"another password => \" + v);\n    }\n});\n```\n"},{"date":"2015-08-28T08:34:48Z","author":"akarnokd","text":"Thanks. Without `startWith`, this variant gives a reasonable output:\n\n``` java\n        BehaviorSubject<String> password = BehaviorSubject.create(\"\");\n\n        ConnectableObservable<String> valid = password\n                .map(s -> s + \": \" + (s.length() >= 8))\n                .doOnSubscribe(() -> System.out.println(\"onSubscribe\"))\n                .doOnNext(v -> System.out.println(\"onNext -> \" + v))\n                .replay(1)\n                ;\n\n        valid.connect();\n\n        password.onNext(\"1\");\n        password.onNext(\"12\");\n        password.onNext(\"12345678\");\n\n        valid.forEach(System.out::println);\n```\n\n```\nonSubscribe\nonNext -> : false\nonNext -> 1: false\nonNext -> 12: false\nonNext -> 12345678: true\n12345678: true\n```\n\nI'll check what's different with `startWith`.\n"},{"date":"2015-08-28T08:37:28Z","author":"rayshih","text":"yup, I have checked that before. It behaves correctly without `startWith`\n"},{"date":"2015-08-28T08:58:48Z","author":"akarnokd","text":"`replay()` in 1.0.14 supports downstream backpressure and expects upstream backpressure. This required request coordination among child subscribers. \n\nIf there are no child subscribers to begin with (at `connect()` for example), replay doesn't request anything. Without request, the concat in startWith won't subscribe to just(false). Since false isn't observed, `concat` won't continue with the `BehaviorSubject` that has 0 subscribers at the time, dropping your `1` and `12` values but holding onto `12345678`. When you do subscribe to the `ConnectableObservable`, `just(false)` and the latest value of the `BehaviorSubject` is received.\n\nWithout `startWith`, it works as `BehaviorSubject` disregards backpressure and pushes its values down to `replay()` that dutifully buffers them as long as it can.\n\nIn contrast, publish() slowly consumes its source if there are no child subscribers to it. Otherwise, the behavior you are expecting wasn't codified in our unit tests (therefore the updated replay() operator shipped). I have to think about if this is actually achievable or not. Until then, you can get back the old behavior:\n\n``` java\n   \/\/ ...\n\n   valid.subscribe();\n   valid.connect();\n\n   password.onNext(\"1\");\n   \/\/ ...\n```\n\nThis will consume the upstream whether there are other subscribers or not.\n"},{"date":"2015-08-28T09:05:24Z","author":"rayshih","text":"Thanks. I currently downgrade to 1.0.13, is that ok? Or you suggest to use 1.0.14 and do `subscribe` before `connect`?\n"}],"opened_by":"rayshih","reopen":false,"closed_on":"2016-02-09T13:36:53Z","description":"I am not sure my implementation is good. But I notice that given the following code (in scala):\n\n``` scala\nval password = BehaviorSubject[String](\"\")\nval passwordIsValid = (false +: password.map(s => s.length >= 8)).\n  doOnSubscribe(println(\"on subscribe\")).\n  doOnNext(v => println(s\"do on next => $v\")).\n  replay(1)\n\npasswordIsValid.connect\n\npassword.onNext(\"1\")\npassword.onNext(\"12\")\npassword.onNext(\"12345678\")\n\npasswordIsValid.subscribe(v => println(s\"another password => $v\"))\n```\n\nthe output by RxJava 1.0.13 is:\n\n```\non subscribe\ndo on next => false\ndo on next => false\ndo on next => false\ndo on next => false\ndo on next => true\nanother password => true\n```\n\nwhich is what I want.\n\nhowever the output by RxJava 1.0.14 is different.\n\n```\non subscribe\ndo on next => false\nanother password => false\ndo on next => true\nanother password => true\n```\n\nwhich doesn't make sense to me.\n","id":"103660342","title":"Different behaviour of replay between 1.0.13 and 1.0.14","opened_on":"2015-08-28T07:04:06Z","closed_by":"akarnokd"},{"number":"3214","reopenOn":null,"comments":[{"date":"2015-08-28T17:30:46Z","author":"stealthcode","text":":+1: this seems like a valid contribution with tests. \n"},{"date":"2015-08-28T17:30:46Z","author":"stevegury","text":":+1: \n"},{"date":"2015-08-29T10:26:49Z","author":"wrightm","text":"Thanks guys, hopefully the first of many contributions.\n"}],"opened_by":"wrightm","reopen":false,"closed_on":"2015-08-28T17:30:48Z","description":"The Notification method was missing a check to hasValue and hasThrowable. This allowed for a null value onNext Notification to equal an Object notification. A similar bug for onError Notification events also existed.\n","id":"103595685","title":"Fix to Notification equals method.","opened_on":"2015-08-27T21:09:21Z","closed_by":"stealthcode"},{"number":"3183","reopenOn":null,"comments":[{"date":"2015-08-28T17:39:18Z","author":"stealthcode","text":":+1: \n"},{"date":"2015-08-28T17:41:18Z","author":"stealthcode","text":"What if the `Exceptions.throwOrReport(...)` took a `Subscriber` instead? This way we could check if the downstream subscriber is unsubscribed and then if we are reporting we would instead log to the `RxJavaPlugins.getInstance().getErrorHandler().handleError(e)`. This would standardize usage of the error handler plugin. Thoughts? \n"},{"date":"2015-08-28T17:44:17Z","author":"akarnokd","text":"@stealthcode Your suggestion can be applied after the merge with another PR if you wish.\n"},{"date":"2015-08-28T18:43:34Z","author":"stealthcode","text":"I agree. Just suggesting for your input. \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-08-28T18:43:38Z","description":"Added two convenient methods to `Exceptions` which either throws a fatal exception or reports it with our without the causing value to an Observer.\n","id":"102902592","title":"Refactored exception reporting of most operators.","opened_on":"2015-08-24T22:11:51Z","closed_by":"stealthcode"},{"number":"3182","reopenOn":null,"comments":[{"date":"2015-08-24T21:16:28Z","author":"akarnokd","text":"Thanks for reporting. The fatal error `OnErrorNotImplemented` is swallowed by filter. I'll do a sweep of places where a `catch (Throwable` is not followed by `Exceptions.throwIfFatal()`\n"},{"date":"2015-09-03T07:33:28Z","author":"akarnokd","text":"Fixed via #3183.\n"},{"date":"2015-09-03T08:05:16Z","author":"konmik","text":"Thanks! :)\n"}],"opened_by":"konmik","reopen":false,"closed_on":"2015-09-03T07:33:28Z","description":"The test:\n\n```\n@Test(expected = Throwable.class)\npublic void testThrowDuringOnNext() throws Exception {\n    Observable\n        .just(1)\n        .filter(new Func1<Integer, Boolean>() {\n            @Override\n            public Boolean call(Integer integer) {\n                return true;\n            }\n        })\n        .first()\n        .subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer integer) {\n                throw new RuntimeException();\n            }\n        });\n}\n```\n\nIf I remove `filter` or `first` the test gets passed.\n","id":"102871347","title":".just(1).filter().first().subscribe(throw) swallows the exception","opened_on":"2015-08-24T19:21:37Z","closed_by":"akarnokd"},{"number":"3181","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-08-24T21:19:08Z","description":"Fixed the NPE reported in #3180.\n","id":"102847437","title":"MapNotification producer NPE fix","opened_on":"2015-08-24T17:20:19Z","closed_by":"akarnokd"},{"number":"3180","reopenOn":null,"comments":[{"date":"2015-08-24T17:21:35Z","author":"akarnokd","text":"Thanks for reporting. #3181 fixes this issue.\n"},{"date":"2015-09-09T14:32:55Z","author":"akarnokd","text":"Fix merged via #3181 and will be delivered in 1.0.15.\n"}],"opened_by":"mikegr","reopen":false,"closed_on":"2015-09-09T14:32:55Z","description":"The following code works with RxJava 1.0.12, but throws a NullPointerException with 1.0.13 and 1.0.14\n\n```\nObservable.just(1)\n                .flatMap(\n                        item -> Observable.just(item + 1),\n                        e -> Observable.error(e),\n                        () -> Observable.never())\n                .subscribe(\n                        i -> {\n                            Log.d(TAG, \"Got \" + i);\n                        },\n                        e -> {\n                            Log.d(TAG, \"RxJava ERROR\", e);\n                        });\n\n```\n\n```\njava.lang.NullPointerException: Attempt to invoke virtual method 'void rx.internal.operators.OperatorMapNotification$SingleEmitter.offer(java.lang.Object)' on a null object reference\nat rx.internal.operators.OperatorMapNotification$1.onNext(OperatorMapNotification.java:82)\nat rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\nat rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\nat rx.Observable$1.call(Observable.java:145)\nat rx.Observable$1.call(Observable.java:137)\nat rx.Observable$1.call(Observable.java:145)\nat rx.Observable$1.call(Observable.java:137)\nat rx.Observable.subscribe(Observable.java:7803)\nat rx.Observable.subscribe(Observable.java:7579)\n```\n\nFurther notice: Observable.just(1,2,3) works fine on all versions.\n","id":"102813271","title":"NullPointerException with flatMap version that handles notification handling","opened_on":"2015-08-24T15:01:13Z","closed_by":"akarnokd"},{"number":"3176","reopenOn":null,"comments":[{"date":"2016-02-09T13:37:32Z","author":"akarnokd","text":"See #3678\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2016-02-09T13:37:32Z","description":"The following test fails because Window forgets to request the 'gaps' between elements if skip > size:\n\n``` java\n@Test\npublic void testBackpressureWithLargeSkip() {\n    TestSubscriber<Observable<Integer>> ts = new TestSubscriber<Observable<Integer>>(2) {\n        @Override\n        public void onNext(Observable<Integer> t) {\n            AsyncSubject<Integer> as = AsyncSubject.create();\n            t.subscribe(as);\n            super.onNext(as);\n        }\n    };\n\n    Observable.just(1, 2, 3)\n    .window(1, 2)\n    .subscribe(ts);\n\n    ts.assertCompleted();\n    ts.assertNoErrors();\n    ts.assertValueCount(2);\n}\n```\n\nNote that due to potential conflict with #3150, I won't create a PR to fix this right now but will post a PR that adds some helper methods to BackpressureUtils to deal with add\/multiply overflows.\n","id":"102524089","title":"Window with skip > size doesn't request enough","opened_on":"2015-08-22T10:34:36Z","closed_by":"akarnokd"},{"number":"3171","reopenOn":null,"comments":[{"date":"2015-08-28T17:27:35Z","author":"stevegury","text":":+1: \n"},{"date":"2015-08-28T17:27:36Z","author":"stealthcode","text":":+1: \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-08-28T17:27:44Z","description":"Fixes #3168\n\nIf there is no initial value, there is no need to manipulate the request amounts.\n\nIf there is an initial value, we must do a full emitter-loop with value queueing because now the downstream request can race with the first onNext or the setting of the upstream producer. The downside is the increased overhead which should be reduced when the spsc unbounded queues get merged.\n","id":"102365872","title":"Scan backpressure and first emission fix","opened_on":"2015-08-21T12:13:33Z","closed_by":"stealthcode"},{"number":"3169","reopenOn":"2015-09-09T15:34:12Z","comments":[{"date":"2015-09-09T16:29:57Z","author":"benjchristensen","text":"I'll have to allocate some time to review this later as it is somewhat detailed. Thank you for tackling this.\n"},{"date":"2015-09-09T16:31:15Z","author":"benjchristensen","text":"> Pre 1.0.13 implicitly limited the concurrency level to RxRingBuffer.SIZE when scalars were received.\n\nThat was done by design, since scalars behave as `onNext`. And we can limit the number of `Observable`s being merged if we have scalars queued up for delivery.\n\nThe reason we can't limit the number of async `Observable`s is because we don't know if they will emit or not and thus risk deadlock.\n"},{"date":"2015-11-10T20:02:12Z","author":"stealthcode","text":":+1: \n"},{"date":"2015-11-10T21:05:21Z","author":"akarnokd","text":"I'll rebase this.\n"},{"date":"2015-11-10T21:39:24Z","author":"akarnokd","text":"Rebased, let's get this finally in.\n"},{"date":"2015-11-10T21:44:04Z","author":"stealthcode","text":"Thanks\n"}],"opened_by":"akarnokd","reopen":true,"closed_on":"2015-11-10T21:39:27Z","description":"Resolves #3156 \n\nNote that since the default merge operation is unbounded, this change could lead to an excessive memory usage when flatMapping fast sources. Note that the pre 1.0.13 version did this albeit on a slighty slower path.\n\nThe change also affects the scalar optimization as well. Pre 1.0.13 implicitly limited the concurrency level to RxRingBuffer.SIZE when scalars were received. This version now fills the queue up to the concurrency level.\n\nFor 2.0, I suggest having a bounded behavior by default and require the developer to specify Integer.MAX_VALUE to go for the unbounded behavior so he\/she knows about the consequences.\n","id":"102226397","title":"Merge can now operate in horizontally unbounded mode.","opened_on":"2015-08-20T20:10:24Z","closed_by":"akarnokd"},{"number":"3168","reopenOn":null,"comments":[{"date":"2015-08-20T20:39:06Z","author":"akarnokd","text":"This is odd. The initial value is emitted just before the first accumulated value or a completion event.\n"},{"date":"2015-08-21T12:14:00Z","author":"akarnokd","text":"Fix available via #3171.\n"}],"opened_by":"mbrandonw","reopen":false,"closed_on":"2015-08-28T17:27:44Z","description":"I would expect this:\n\n```\nfinal Observable<Void> ob = BehaviorSubject.create();\nob.scan(0, (accum, x) -> 123)\n  .subscribe(x -> {\n    Timber.d(\"Hit!\");\n  });\n```\n\nto emit a value (and indeed it does in the equivalent RxJS code).\n\nIs this a bug?\n","id":"102208397","title":"BehaviorSubject.scan not picking up initial value","opened_on":"2015-08-20T18:57:18Z","closed_by":"stealthcode"},{"number":"3167","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-08-24T21:18:56Z","description":"Reported in #3166 \n\nWhat happened is that if there are multiple subscribers, one with larger requests than the others and it unsubscribed early, the new max request of the others then became smaller than before which yielded a negative difference and thus a negative request.\n","id":"102188394","title":"Fixed negative request due to unsubscription of a large requester","opened_on":"2015-08-20T17:26:27Z","closed_by":"akarnokd"},{"number":"3166","reopenOn":null,"comments":[{"date":"2015-08-20T16:31:30Z","author":"akarnokd","text":"Could you post the code (or equivalent) which exhibits this problem? Looks like there is a flatmap followed by a replay.\n"},{"date":"2015-08-20T17:28:17Z","author":"akarnokd","text":"Found the problem. Fix in #3167. \n"},{"date":"2015-08-21T14:38:22Z","author":"danhawkes","text":"Awesome, thanks for the speedy fix. As a workaround until there's an update to RX, is it be safe to wrap the unsubscribe call in a catch statement? I'd be discarding the entire source observable at that point also.\n"},{"date":"2015-08-21T14:41:53Z","author":"akarnokd","text":"The bug can leave the operator in inconsistent state and could stop replaying altogether.\n"},{"date":"2015-09-03T07:34:12Z","author":"akarnokd","text":"Fixed via #3167 \n"}],"opened_by":"danhawkes","reopen":false,"closed_on":"2015-09-03T07:34:12Z","description":"Saw this exception in crash logs, but haven't been able to reproduce it. Any ideas what the cause is?   \n\n```\njava.lang.IllegalArgumentException: n >= 0 required\nat rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:128)\nat rx.internal.operators.OperatorReplay$ReplaySubscriber.manageRequests(OperatorReplay.java:521)\nat rx.internal.operators.OperatorReplay$InnerProducer.unsubscribe(OperatorReplay.java:716)\nat rx.internal.util.SubscriptionList.unsubscribeFromAll(SubscriptionList.java:124)\nat rx.internal.util.SubscriptionList.unsubscribe(SubscriptionList.java:113)\nat rx.Subscriber.unsubscribe(Subscriber.java:98)\nat rx.internal.util.SubscriptionList.unsubscribeFromAll(SubscriptionList.java:124)\nat rx.internal.util.SubscriptionList.unsubscribe(SubscriptionList.java:113)\nat rx.Subscriber.unsubscribe(Subscriber.java:98)\n```\n\nhttps:\/\/github.com\/ReactiveX\/RxJava\/blob\/v1.0.14\/src\/main\/java\/rx\/internal\/operators\/OperatorMerge.java#L128\n","id":"102175132","title":"\"java.lang.IllegalArgumentException: n >= 0 required\" when unsubscribing","opened_on":"2015-08-20T16:15:20Z","closed_by":"akarnokd"},{"number":"3156","reopenOn":null,"comments":[{"date":"2015-08-14T16:09:20Z","author":"akarnokd","text":"This shortcoming is much earlier, at least as old as RxRingBuffer and a certain Scalar optimization in merge...\n"},{"date":"2015-08-14T16:58:47Z","author":"benjchristensen","text":"Scalar is different ... they aren't async so aren't an issue. A scalar ALWAYS has a value in it, thus it will always emit if there is downstream support. \n\nThese unit tests pass if I go back to 1.0.12\n\n``` java\n    @Test\n    public void testUnboundedDefaultConcurrency() {\n        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();\n        for(int i=0; i < 2000; i++) {\n            os.add(Observable.<Integer>never());\n        }\n        os.add(Observable.range(0, 100));       \n\n        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n        Observable.merge(os).take(1).subscribe(ts);\n        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);\n        ts.assertValue(0);\n        ts.assertCompleted();\n    }\n\n    @Test\n    public void testConcurrencyLimit() {\n        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();\n        for(int i=0; i < 2000; i++) {\n            os.add(Observable.<Integer>never());\n        }\n        os.add(Observable.range(0, 100));       \n\n        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n        Observable.merge(os, 5000).take(1).subscribe(ts); \/\/ reduced to 5000 instead of MAX_VALUE since it causes an OOM\n        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);\n        ts.assertValue(0);\n        ts.assertCompleted();\n    }\n```\n"},{"date":"2015-08-14T17:57:34Z","author":"akarnokd","text":"In v12, if there were scalars in the input source, the subscribing was held off until some scalars were drained (i.e., in case of an async downstream request): given 1 normal and 128 scalar queued up, the next source wasn't requested until some or all scalars were drained.\n\nIn order for the tests to pass, we need an Spsc queue instead of the RxRingBuffer if the maxConcurrency is lesss than max, otherwise, we need an unbounded spsc queue. JCTools' SpscArrayQueue supports only power of 2 capacity so a backpressure violation wouldn't be detected at item 5000 but only at item 8192. SpscUnboundedArrayQueue works if its capacity is at least some value due to a bug in its lookahead-grow logic (8 with defaults). \n\nV14 merge has the side effect of limiting the tracking array size so the copy-on-write has to work with at most 512 bytes per add\/remove.\n\nI happen to have a platform safe SpscArrayQueue with explicit capacity insurance (but still power of 2 memory cost) and a platform safe SpscLinkedArrayQueue (still sensitive to certain capacity settings), courtesy of my rsi flatMap.\n\nI can't do PR for a few days but this is a simple change (provided the tradeoff is understood) and most of the community should be able to pull this off.\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2015-11-10T21:39:26Z","description":"Since the `merge` changes in 1.0.13 we now have a bug in `merge` that limits concurrency and can cause an async \"deadlock\" since not all `Observable`s being merged will be subscribed to. \n\nThese unit tests show the issue:\n\n``` java\n    @Test\n    public void testUnboundedDefaultConcurrency() {\n        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();\n        for(int i=0; i < 2000; i++) {\n            os.add(Observable.<Integer>never());\n        }\n        os.add(Observable.range(0, 100));       \n\n        TestSubscriber<Integer> ts = TestSubscriber.create();\n        Observable.merge(os).take(1).subscribe(ts);\n        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);\n        ts.assertValue(0);\n        ts.assertCompleted();\n    }\n\n    @Test\n    public void testConcurrencyLimit() {\n        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();\n        for(int i=0; i < 2000; i++) {\n            os.add(Observable.<Integer>never());\n        }\n        os.add(Observable.range(0, 100));       \n\n        TestSubscriber<Integer> ts = TestSubscriber.create();\n        Observable.merge(os, Integer.MAX_VALUE).take(1).subscribe(ts);\n        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);\n        ts.assertValue(0);\n        ts.assertCompleted();\n    }\n```\n\nSurprisingly, even when providing the `maxConcurrent` value the issue still happens.\n\nWe have bounded **vertical** buffers, but always must default to unbounded **horizontal** buffers, since it is the code that defines how many items are horizontally buffered. This affects both `merge` and `groupBy`. The `maxConcurrent` overload allows a developer to limit the horizontal buffering, and a developer controls the `groupBy` selector.\n","id":"101043302","title":"Merge Limiting Concurrency - Can Deadlock","opened_on":"2015-08-14T16:05:29Z","closed_by":"akarnokd"},{"number":"3155","reopenOn":null,"comments":[{"date":"2015-08-14T12:11:58Z","author":"davidmoten","text":"There are a lot of repeated try catch blocks calling the RxJavaPlugins error handler so I've made a `RxJavaPluginUtils` class. It will also be called from the `using` fix which I will submit once this PR has been accepted.\n"},{"date":"2015-08-14T12:31:52Z","author":"akarnokd","text":"One of the tests fails.\n"},{"date":"2015-08-14T21:14:46Z","author":"davidmoten","text":"I'm going to ponder the issue of throwing after reporting to the error handler a bit.\n"},{"date":"2015-08-15T12:15:41Z","author":"davidmoten","text":"I've been looking for a bit of guidance about what to do when `unsubscribe` throws in `SafeSubscriber`. _Rx Design Guidelines_ doesn't really cover it. _reactive-streams-jvm_ does touch upon it saying:\n\n> 3.15 Calling Subscription.cancel MUST return normally. The only legal way to signal failure to a Subscriber is via the onError method.\n\nI think given that the contract has been breached it is fair to throw an exception and I think a new wrapper `UnsubscribeFailureException` would be appropriate.\n\nI'd also like to address the case when `onCompleted` throws. _reactive-streams-jvm_ has this to say:\n\n> 2.13 Calling onSubscribe, onNext, onError or onComplete MUST return normally except when any provided parameter is null in which case it MUST throw a java.lang.NullPointerException to the caller, for all other situations the only legal way for a Subscriber to signal failure is by cancelling its Subscription. In the case that this rule is violated, any associated Subscription to the Subscriber MUST be considered as cancelled, and the caller MUST raise this error condition in a fashion that is adequate for the runtime environment.\n\nSo in the existing code if in `SafeSubscriber` an `onError` call to the downstream subscriber throws then the RxJavaPlugin error handler is called _and_ an `OnErrorFailedException` is thrown. Comments in the method say this is ok because the contract has been broken and this is probably consistent with the advice in 3.13:\n\n> and the caller MUST raise this error condition in a fashion that is adequate for the runtime environment.\n\nIn the existing code if in `SafeSubscriber` an `onCompleted` call to the downstream subscriber throws then the consequent call to `_onError` tries to signal `onError` to the downstream subscriber.  I'm worried that calling `onError` after calling `onCompleted` is a strong enough breach of the contract that the possible side effects could be worse than just a throw. Shouldn't we throw only (and notify the plugin error handler of course)?\n"},{"date":"2015-08-16T06:51:32Z","author":"davidmoten","text":"I've submitted code that matches my thinking above. It still fails because I haven't amended the existing unit tests associated with throwing. I'll do that after another round of review if accepted.\n"},{"date":"2015-08-16T07:00:22Z","author":"akarnokd","text":"The failing test is a coverage test for a behavior no longer present. I suggest removing it and rerunning the jacoco to see if all current code path is covered.\n"},{"date":"2015-08-16T11:05:13Z","author":"davidmoten","text":"@akarnokd Yep that's right. Are you happy that a throwing `onCompleted()` call should not induce an `onError()` call? If so I'll clean up and update the PR.\n"},{"date":"2015-08-17T03:07:54Z","author":"davidmoten","text":"I've fixed the unit tests and added more so that `SafeSubscriber` gets 100% coverage.\n"},{"date":"2015-08-21T21:29:04Z","author":"akarnokd","text":":+1: Looks good to me.\n\nSince this adds public API classes, it requires further approval (otherwise it shouldn't affect programs other than those that badly fail, therefore, the merge policy would allow me to merge it).\n"},{"date":"2015-08-22T15:10:23Z","author":"zsxwing","text":"LGTM. It would be better if you can fix the indent. :+1: for UnsubscribeFailureException. It's a pity that we cannot change `OnErrorFailedException`s that should have been `UnsubscribeFailureException` now since it's a break change.\n"},{"date":"2015-08-22T22:21:42Z","author":"davidmoten","text":"Thanks for review @akarnokd  and @zsxwing. I've fixed indent in test and squashed commits.\n"},{"date":"2015-08-24T21:17:27Z","author":"akarnokd","text":"Great, thanks!\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-08-24T21:17:29Z","description":"Discussed in #2464, when an observable emits `onCompleted` but `unsubscribe` in `SafeSubscriber` throws then the error should be reported to the `RxJavaPlugin` error handler and if that fails a stack trace is written to `System.err`.\n","id":"100991304","title":"SafeSubscriber - report onCompleted unsubscribe error to RxJavaPlugin ","opened_on":"2015-08-14T11:12:54Z","closed_by":"akarnokd"},{"number":"3129","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-08-06T08:24:54Z","description":"Apparently, we forgot about this operator. The backpressure handling is a trivial case with `ProducerArbiter`. I've also fixed some apparent code indentation error.\n\nOriginally reported in #3128 with a test case which I didn't include due to its lengthy nature; however, I did run the test manually and both passed after the fix.\n","id":"98821315","title":"Fix retry with predicate ignoring backpressure.","opened_on":"2015-08-03T19:29:48Z","closed_by":"akarnokd"},{"number":"3128","reopenOn":null,"comments":[{"date":"2015-08-03T19:17:26Z","author":"akarnokd","text":"That particular retry overload doesn't support backpressure. I'll post a PR that fixes it.\n"},{"date":"2015-08-03T19:30:56Z","author":"akarnokd","text":"Fixed in #3129. It may take some weeks until 1.0.14 is released though.\n"},{"date":"2015-08-03T22:01:30Z","author":"dfjones","text":"@akarnokd Thank you for the quick response and fix. I tried your patch with my test and it appears to have fixed the issue. Thanks!\n"},{"date":"2015-09-03T07:38:05Z","author":"akarnokd","text":"Fixed via #3129 and patch delivered in 1.0.14\n"}],"opened_by":"dfjones","reopen":false,"closed_on":"2015-09-03T07:38:05Z","description":"In some production code, I noticed that it is possible to create a situation where the retry method that accepts a predicate produces a MissingBackpressureException. However, other retry methods do not produce such an exception.\n\nI've created a small test case here:\nhttps:\/\/github.com\/dfjones\/RxJava\/blob\/67a18a453616539faf16204637b9399057e0bf8e\/src\/test\/java\/rx\/RetryBackpressureTest.java\n\nApologies for this being a non-deterministic test, but on my laptop the `testBackpressurePredicateRetry` test will reliably fail due to MissingBackpressureException with the trace below. \n\nHowever, the `testBackpressureNormalRetry` test will run for 1 minute without producing this exception.\n\nAdmittedly, this might be a convoluted setup, but it reflects a situation I had in some production code. Essentially, I have a flow where for each event produced by an Observable, I need to perform some IO with retries. So, I've spread that IO work over a Scheduler. The IO work produces many individual events. In my test case, imagine this inner Observable is performing IO:\n\n``` java\nAbstractOnSubscribe.create((state) ->\n            state.onNext(2L))\n```\n\nEverything in this flow should respond to back-pressure through the use of `AbstractOnSubscribe`, however I'm running into the issue described here when using retry with a predicate function.\n\n```\nrx.exceptions.MissingBackpressureException\n        at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:349)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.queueScalar(OperatorMerge.java:345)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:328)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:802)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)\n        at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber$1$1.onNext(OperatorRetryWithPredicate.java:113)\n        at rx.observables.AbstractOnSubscribe$SubscriptionState.accept(AbstractOnSubscribe.java:535)\n        at rx.observables.AbstractOnSubscribe$SubscriptionProducer.doNext(AbstractOnSubscribe.java:369)\n        at rx.observables.AbstractOnSubscribe$SubscriptionProducer.request(AbstractOnSubscribe.java:340)\n        at rx.Subscriber.setProducer(Subscriber.java:209)\n        at rx.observables.AbstractOnSubscribe.call(AbstractOnSubscribe.java:192)\n        at rx.observables.AbstractOnSubscribe$LambdaOnSubscribe.call(AbstractOnSubscribe.java:275)\n        at rx.Observable.unsafeSubscribe(Observable.java:7689)\n        at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber$1.call(OperatorRetryWithPredicate.java:120)\n        at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.enqueue(TrampolineScheduler.java:80)\n        at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.schedule(TrampolineScheduler.java:59)\n        at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:77)\n        at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:45)\n        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n        at rx.Observable$1.call(Observable.java:144)\n        at rx.Observable$1.call(Observable.java:136)\n        at rx.Observable.unsafeSubscribe(Observable.java:7689)\n        at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n```\n","id":"98809456","title":"MissingBackpressureException when using Retry with Predicate","opened_on":"2015-08-03T18:20:03Z","closed_by":"akarnokd"},{"number":"3126","reopenOn":null,"comments":[{"date":"2015-07-31T18:08:03Z","author":"akarnokd","text":"Generally, you are not supposed to call onError with null and not expect one so the NPE in the test in this case, in my opinion, is acceptable as a failure state.\n"},{"date":"2015-07-31T18:10:02Z","author":"artem-zinnatullin","text":"Yeah, I agree, but if we'll deny `null` as error we will break backward compatibility because it was allowed in previous versions of RxJava :(\n"},{"date":"2015-08-12T19:58:44Z","author":"akarnokd","text":"I don't know. Are there really users that send null through onError and test for it with this assert?\n"},{"date":"2015-08-12T21:05:38Z","author":"artem-zinnatullin","text":"According to #3125 there is at least one user of `onError(null)`, but personally, I'd like to deny it. Though it might be interpreted as breaking change in the API I'd just call it \"bugfix\", add check to the `TestSubscriber` and write tests that asserts that `null` will break the execution :)\n\nIf you agree, I'll update this PR and we will deny `null`s for errors.\n"},{"date":"2015-08-12T21:16:49Z","author":"akarnokd","text":"`onError(null)` is definitely a bad practice and reactive-streams explicitly forbids it, so should we.\n"},{"date":"2015-08-12T22:19:28Z","author":"benjchristensen","text":"Agreed, `onError(null)` is invalid. This is supposed to represent throwing exceptions, and we can not \"throw null\".\n"},{"date":"2015-08-12T22:22:34Z","author":"artem-zinnatullin","text":"Oh, I wanted to change this PR and add javadoc about `null` into the `TestSubscriber.assertError()` and `Observer.onError()` but you closed this PR\u2026 :)\n\nI'll do it in a separate PR.\n"}],"opened_by":"artem-zinnatullin","reopen":false,"closed_on":"2015-08-12T22:19:28Z","description":"Resolves #3125 via test, makes `TestSubscriber.assertError()` little bit faster via caching first error, and allows to use `TestSubscriber.assertError(null)`.\n","id":"98438387","title":"Allow to use null as error for TestSubscriber.assertError()","opened_on":"2015-07-31T17:40:34Z","closed_by":"benjchristensen"},{"number":"3122","reopenOn":null,"comments":[{"date":"2015-07-30T11:13:58Z","author":"akarnokd","text":"The `lift` operator doesn't use `Exceptions.throwIfFatal` but only checks for `OnErrorNotImplementedException` and tries to send the error back downstream which is dropped because the take inside the `delaySubscription` operator is already completed at that point. @davidmoten, would you like to locate such cases in the codebase?\n"},{"date":"2016-02-09T13:32:08Z","author":"akarnokd","text":"This should be fixed and if not already, released with the next version.\n"}],"opened_by":"gdela","reopen":false,"closed_on":"2016-02-09T13:32:08Z","description":"Recently I stumbled upon issue, where `.toBlocking().single()` hanged forever. After painful debugging I traced it down to issue during our build\/deploy pipeline which resulted in `NoSuchMethodError` thrown from one of the libraries. This error was swallowed completely by RxJava, and the end result was a hanging thread.\n\nHere is a minimal test case to reproduce the issue:\n\n```\nObject result = Observable\n    .create(subscriber -> {\n        subscriber.onNext(\"item 1\");\n        if (true) throw new NoSuchMethodError();\n        subscriber.onCompleted();\n    })\n    .delaySubscription(() -> Observable.just(\"delay\"))\n    .toBlocking()\n    .single();\nSystem.out.println(result);\n```\n\nThis will hang like that:\n\n```\n\"main\" #1 prio=5 os_prio=0 tid=0x000000000217e000 nid=0x1d80 waiting on condition [0x000000000207e000]\njava.lang.Thread.State: WAITING (parking)\n    at sun.misc.Unsafe.park(Native Method)\n    ...\n    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:461)\n    at rx.observables.BlockingObservable.single(BlockingObservable.java:341)\n    at Sandbox.main(Sandbox.java:14)\n```\n\nOf course I've fixed it by fixing our build\/deploy pipeline, but I'm reporting it because the swallowed exception makes such issues really hard to debug. If the RxJava could somehow report it and\/or not hang, it would be nice.\n","id":"98040679","title":"NoSuchMethodError + delaySubscription() causes BlockingObservable hang forever","opened_on":"2015-07-29T22:13:27Z","closed_by":"akarnokd"},{"number":"3119","reopenOn":null,"comments":[{"date":"2015-07-29T14:25:23Z","author":"JakeWharton","text":"Woah. If the signature of the to-be-reflected method is known why is a direct lookup not being done?\n"},{"date":"2015-07-29T14:36:12Z","author":"akarnokd","text":"@digitalbuddha You can use the system property \"rx.scheduler.jdk6.purge-force\" set to \"true\" to avoid the loop. The reason for the loop is to avoid NoSuchMethodException being thrown on JDK 6 which is more costly than looping through ~70 methods. Although I admit evaluating that all the time is unnecessary as Executors.newScheduledExecutor() won't change is ability during runtime.\n"},{"date":"2015-07-29T14:38:12Z","author":"JakeWharton","text":"Thankfully that property _just_ squeezes under Android's 31 character max at 29 chars!\n"},{"date":"2015-07-29T14:41:54Z","author":"JakeWharton","text":"Can we use `PlatformDependent.isAndroid()` to default this to `true`?\n"},{"date":"2015-07-29T15:44:37Z","author":"akarnokd","text":"My google search indicates the method `setRemoveOnCancelPolicy` is supported from API level 22. If there could be a way to discover the API level programmatically and cross-platform safe then sure.\n"},{"date":"2015-07-29T16:03:58Z","author":"JakeWharton","text":"The `android.os.Build.VERSION` class has an `SDK_INT` int constant which can be read. The presence of the class could replace the check for `android.app.Application`.\n"},{"date":"2015-07-29T16:15:08Z","author":"artem-zinnatullin","text":"@akarnokd what do you mean by \n\n>  cross-platform safe\n\n? `android.os.Build.VERSION` is safe to call for all Android versions. \n\nDocumentation: http:\/\/developer.android.com\/reference\/android\/os\/Build.VERSION.html#SDK_INT\n"},{"date":"2015-07-29T16:18:15Z","author":"JakeWharton","text":"Android is one platform\n"},{"date":"2015-07-29T16:23:29Z","author":"akarnokd","text":"Great. Would you like to submit a PR?\n"},{"date":"2015-07-29T18:20:01Z","author":"artem-zinnatullin","text":"Just pushed the PR #3121.\n\nAndroid [supports `ScheduledThreadPoolExecutor.setRemoveOnCancelPolicy()` since API 21](http:\/\/developer.android.com\/reference\/java\/util\/concurrent\/ScheduledThreadPoolExecutor.html#setRemoveOnCancelPolicy%28boolean%29).\n"},{"date":"2015-07-30T15:24:03Z","author":"artem-zinnatullin","text":"Little Gist for those who want to fix this in Android app with RxJava: https:\/\/gist.github.com\/artem-zinnatullin\/51b6c6720ecb8a2a71eb\n"},{"date":"2015-07-30T15:25:12Z","author":"JakeWharton","text":"Your gist says \"static initializer block\" and then proceeds to use an instance initializer block.\n"},{"date":"2015-07-30T15:29:19Z","author":"artem-zinnatullin","text":"Such a stupid mistake\u2026Uh. Thanks.\n"}],"opened_by":"digitalbuddha","reopen":false,"closed_on":"2015-08-01T10:58:18Z","description":"I was  analyzing startup time in the NY Times Android app and started method profiling on startup using Android Device Monitor.  Total time from the beginning of the application class to end of onCreate for first activity is roughly  2.2seconds. Diving deeper I was able to observe that `NewThreadWorker.tryEnableCancelPolicy`\n was taking 1200ms to execute with the offending line being  \n`for (Method m : exec.getClass().getMethods())` (1017ms)\nDiving deeper shows a call to \n`CollectionUtils.removeDuplicates (992 ms)`  \nwhich will call \n`collection.sort` (719ms)\n & \n`reflect.compare`(259ms).\n\ntryEnableCancelPolicy has the following comment: \n\n``` \/**\n     * Tries to enable the Java 7+ setRemoveOnCancelPolicy.\n     * <p>{@code public} visibility reason: called from other package(s) within RxJava.\n     * If the method returns false, the {@link #registerExecutor(ScheduledThreadPoolExecutor)} may\n     * be called to enable the backup option of purging the executors.\n     * @param exec the executor to call setRemoveOnCaneclPolicy if available.\n     * @return true if the policy was successfully enabled \n     *\/ \n```\n\nI tried creating a Scheduler from an Executor but still hit the offending code.  Is there a way to avoid this code or fix the large performance hit that it is causing?\n","id":"97947528","title":"NewThreadWorker.tryEnableCancelPolicy doing costly reflection on Android","opened_on":"2015-07-29T14:21:49Z","closed_by":"akarnokd"},{"number":"3112","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-08-12T19:48:53Z","description":"This includes a rewrite of `SerializedObserver` to have a more cleaner exception semantics.\n\nThe `TestSubscriberTest` can be improved further but I've run out of time for today.\n","id":"97047501","title":"Observers package test coverage and fixes.","opened_on":"2015-07-24T13:00:36Z","closed_by":"akarnokd"},{"number":"3104","reopenOn":null,"comments":[{"date":"2015-07-24T08:54:57Z","author":"akarnokd","text":"SynchronizedQueue should be replaced with one of the JCTools' atomic-based bounded queues instead.\n"},{"date":"2015-08-12T19:37:45Z","author":"akarnokd","text":"Thanks.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-08-12T19:37:47Z","description":"Courtesy of findBugs, `SynchronizedQueue.equals()` is improperly implemented. I used Eclipse to generate a new `equals()` method based on the `list` field.\n\nThe existing code would even have failed to return true when testing queue equality with itself.\n\nI don't think this is causing problems anywhere but this PR will ensure that it doesn't cause a problem in the future.\n","id":"96968189","title":"Fix SynchronizedQueue.equals","opened_on":"2015-07-24T05:20:10Z","closed_by":"akarnokd"},{"number":"3103","reopenOn":null,"comments":[{"date":"2015-07-24T10:30:49Z","author":"davidmoten","text":"Thanks @akarnokd, I've updated with those fixes and rebased.\n"},{"date":"2015-07-24T10:39:01Z","author":"davidmoten","text":"A quick question about synchronized blocks vs using volatile variables in general. It would also be possible to atomically change a pair like `busy` and `missed` using an immutable wrapping object `BusyAndMissed` and storing it in an `AtomicReference<BusyAndMissed>` and use spinning to modify. It could involve some GC pressure if rapidly changing of course. Have you any experience of advantages\/disadvantages with this approach?\n"},{"date":"2015-07-24T10:57:37Z","author":"akarnokd","text":"That approach is wasteful. You only need an AtomicInteger and its increment\/decrement methods. 0 means not busy, 1+ means busy and 2+ means there is still work to be done. The pair of booleans + synchronized, however, plays into the hands of lock elision and biased locking which affects our benchmarks. If it were up to me, I'd use atomics everywhere so we avoid the chance of unnecessary thread suspension due to a lock not available around 2 bytes.\n"},{"date":"2015-07-24T11:09:00Z","author":"davidmoten","text":"Thanks, quite right for that pair of objects, was probably a bad example. So under circumstances where we are getting significant lock elision and biased locking is it also the case that the volatile read and write of `terminalNotification` is just like a non-volatile read and write? I left it as non-volatile to favour lock elision and biased locking in the first place.\n"},{"date":"2015-07-24T11:31:49Z","author":"akarnokd","text":"That is a terminal event that happens once, but when the lock optimizations don't happen, you may get a hefty delay. Paying a few dozen nanoseconds for a single volatile write is way better.\n"},{"date":"2015-07-24T11:54:12Z","author":"davidmoten","text":"Makes sense, thanks.\n"},{"date":"2015-08-06T08:26:06Z","author":"akarnokd","text":"Thanks!\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-08-06T08:26:09Z","description":"As mentioned in #3098 the existing version of  `materialize` could deliver one more event than requested being the termination event (completion or error).\n\nThis PR ensures that a termination event is buffered till requested.\n","id":"96958121","title":"materialize() - add backpressure support","opened_on":"2015-07-24T03:56:10Z","closed_by":"akarnokd"},{"number":"3101","reopenOn":null,"comments":[{"date":"2015-08-12T21:54:01Z","author":"benjchristensen","text":"Odd bug. Thanks for the fix.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-07-24T09:39:39Z","description":"Fixes the case uncovered by #3095.\n","id":"96821003","title":"Fix take swallowing exception if thrown by exactly the nth onNext call to it.","opened_on":"2015-07-23T13:54:29Z","closed_by":"akarnokd"},{"number":"3095","reopenOn":null,"comments":[{"date":"2015-07-23T13:41:51Z","author":"akarnokd","text":"This is a strange situation: take sets its completed flag before the emission and when the exception is bounced back, it is not propagated any further. Looks like a bug.\n"},{"date":"2015-08-02T20:11:17Z","author":"mikebaum","text":"@akarnokd Thanks for the quick bug fix!\n"},{"date":"2015-08-12T23:20:23Z","author":"akarnokd","text":"The bug is fixed and is now part of 1.0.14. Thanks for reporting.\n"}],"opened_by":"mikebaum","reopen":false,"closed_on":"2015-08-12T23:20:23Z","description":"It seems that if your subscriber throws a \"fatal\" exception when subscribing to a BehaviorSubject chained with just, the fatal there error is swallowed and nothing is logged. See the following example:\n\n```\n    public static void main( String[] args )\n    {\n        BehaviorSubject<String> strings = BehaviorSubject.create( \"First\" );\n\n        RxJavaPlugins.getInstance().registerErrorHandler( new RxJavaErrorHandler()\n        {\n            public void handleError( Throwable throwable )\n            {\n                System.err.println( throwable );\n            };\n        } );\n\n        strings.take( 1 ).subscribe( string -> { throw new NoClassDefFoundError(); },\n                                     System.err::println );\n    }\n```\n\nIf the error thrown from the subscribe function is anything but a \"fatal\" error as determined by `Exceptions.throwIfFatal(Throwable)` an error is properly propagated.\n","id":"96370328","title":"Observable.take() on a BehaviorSubject swallows \"fatal\" errors.","opened_on":"2015-07-21T17:19:17Z","closed_by":"akarnokd"},{"number":"3093","reopenOn":null,"comments":[{"date":"2015-07-20T22:28:56Z","author":"benjchristensen","text":"Is this urgent for release, or can it wait?\n"},{"date":"2015-07-21T07:01:27Z","author":"akarnokd","text":"Yes, this is severe enough, especially if one merges high throughput asynchronous sources before observing them on a scheduler. Synchronous merges or small amount of values won't trigger the `MissingBackpressureException`.\n\nThere is another possible issue which affected the merge() version before. Due to the scalar optimization, it could reorder values from a source: \n1. a value comes in but requested is zero, therefore, the value is queued,\n2. the requested amount increases but it doesn't enter the emission loop yet,\n3. another value comes in, finds the requested to be non-zero, successfully enters the emitting state and emits this second value while the first is still in the queue,\n4. the requester also enters\/signals the emitter loop and the queue is drained.\n\nApparently, users of `merge()` so far didn't really mind this occasional reordering in the output.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-07-20T21:21:16Z","description":"Requested amount could reach zero between the first check and entering the synchronized block where it has to be re-read in order to verify the scalar emission can really happen at that point; the new `testMergeAsyncThenObserveOnLoop` test failed with `MissingBackpressureException` after ~20 rounds on my i7 4770K.\n\nThis might or might not relate to the canary failure; if combined with retry(), it could have failed over and over, but I'm not sure where the worker retention might have happened.\n","id":"96161010","title":"Fix request != 0 checking in the scalar paths of merge()","opened_on":"2015-07-20T21:11:40Z","closed_by":"akarnokd"},{"number":"3078","reopenOn":null,"comments":[{"date":"2015-08-12T20:01:16Z","author":"akarnokd","text":"Thanks. \n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-08-12T20:01:18Z","description":"As per #3073 a race condition in `OperatorSwitch` means that requests can be lost. This PR uses `ProducerArbiter` to ensure all unfulfilled requests are carried through to the next `Observable`.\n\nI also changed `InnerSubscriber` to be a static class as opposed to an inner class just to decouple it from surrounding state. \n","id":"95069206","title":"switchOnNext() - fix lost requests race condition ","opened_on":"2015-07-14T23:54:42Z","closed_by":"akarnokd"},{"number":"3073","reopenOn":null,"comments":[{"date":"2015-08-12T23:31:02Z","author":"akarnokd","text":"Fixed and released with 1.0.14.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-08-12T23:31:02Z","description":"There is a race condition in `OperatorSwitch` that may cause requests to be lost:\n1. `onNext` proceeds to just before [L137](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/d32a1b0ea7ee455a23082cd1a7db80b3adef6d2b\/src\/main\/java\/rx\/internal\/operators\/OperatorSwitch.java#L137) \n2. on a different thread `request` proceeds to just before [L112](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/d32a1b0ea7ee455a23082cd1a7db80b3adef6d2b\/src\/main\/java\/rx\/internal\/operators\/OperatorSwitch.java#L112)\n3. `onNext` continues and exits method\n4. `request` continues and requests from unsubscribed subscriber\n5. At this point stream could stall because requests were lost \n\nLooks like a candidate for `ProducerArbiter` help. I'll work on a PR if no-one else has started on this issue yet (let me know if you have). There may be other race conditions as well that turn up which I'll document in the PR.\n","id":"94623805","title":"switchOnNext() can lose requests","opened_on":"2015-07-13T02:35:26Z","closed_by":"akarnokd"},{"number":"3067","reopenOn":null,"comments":[{"date":"2015-08-12T23:45:47Z","author":"akarnokd","text":"Yes, that start is unnecessary.\n"},{"date":"2015-09-12T18:13:45Z","author":"KevinTCoughlin","text":"Related PR #3342.\n"},{"date":"2015-11-09T21:21:24Z","author":"akarnokd","text":"Fix merged via #3342 and delivered in 1.0.15.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-11-09T21:21:24Z","description":"These lines\n\nhttps:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/operators\/OperatorGroupBy.java#L262-L264\n\nare redundant. I'm concerned that there is some intent behind placing these lines here that is not honoured.  @akarnokd looks like you put these lines here, what do you think?\n\nThe same goes for `OperatorDoOnUnbsubscribe`.\n","id":"93651629","title":"OperatorGroupBy - redundant onStart implementation","opened_on":"2015-07-07T23:17:52Z","closed_by":"akarnokd"},{"number":"3066","reopenOn":null,"comments":[{"date":"2015-07-07T20:56:47Z","author":"DavidMGross","text":"Thanks for the report.  Can anyone verify whether the same thing is true\nfor Rx.NET (buffer), RxY (buffer_with_time_or_count), RxScala\n(tumblingBuffer), or RxJS (bufferWithTimeOrCount)?\n\nOn Tue, Jul 7, 2015 at 6:37 AM, Chris Froussios notifications@github.com\nwrote:\n\n> The marble diagram in the documentation for the buffer operator\n> \n> buffer(long timespan,\n>           java.util.concurrent.TimeUnit unit,\n>           int count)\n> \n> shows that the duration of a window can be reset if it emits the buffer\n> due to being full.\n> \n> https:\/\/camo.githubusercontent.com\/bca2fd029b405783e846c7c6b944eaabfba12ac4\/68747470733a2f2f7261772e6769746875622e636f6d2f77696b692f5265616374697665582f52784a6176612f696d616765732f72782d6f70657261746f72732f627566666572362e706e67\n> After running a few experiments, this is not the case. Here I replicate\n> the example shown in the marble diagram.\n> \n> TestScheduler scheduler = Schedulers.test();Scheduler.Worker worker = scheduler.createWorker();\n> PublishSubject<Integer> subject = PublishSubject.create();\n> subject\n>     .buffer(100, TimeUnit.MILLISECONDS, 2, scheduler)\n>     .timestamp(scheduler)\n>     .subscribe(System.out::println);\n> \n> worker.schedule(() -> subject.onNext(0), 0, TimeUnit.MILLISECONDS);\n> worker.schedule(() -> subject.onNext(1), 0, TimeUnit.MILLISECONDS);\n> worker.schedule(() -> subject.onNext(2), 50, TimeUnit.MILLISECONDS);\n> worker.schedule(() -> subject.onNext(3), 150, TimeUnit.MILLISECONDS);\n> worker.schedule(() -> subject.onNext(4), 201, TimeUnit.MILLISECONDS);\n> worker.schedule(() -> subject.onNext(5), 250, TimeUnit.MILLISECONDS);\n> scheduler.advanceTimeBy(500, TimeUnit.MILLISECONDS);\n> \n> gives\n> \n> Timestamped(timestampMillis = 0, value = [0, 1])\n> Timestamped(timestampMillis = 100, value = [2])\n> Timestamped(timestampMillis = 200, value = [3])\n> Timestamped(timestampMillis = 250, value = [4, 5])\n> Timestamped(timestampMillis = 300, value = [])\n> Timestamped(timestampMillis = 400, value = [])\n> Timestamped(timestampMillis = 500, value = [])\n> \n> We can see that it continues to emit at multiples of 100, after emiting a\n> full buffer early at 250\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3066.\n\n## \n\nDavid M. Gross\nPLP Consulting\n"},{"date":"2015-07-07T22:34:05Z","author":"Froussios","text":"Rx.NET behaves according to the old marble diagram. It is therefore different than RxJava.\n\n``` C#\nvar scheduler = new TestScheduler();\n\nvar subject = new Subject<int>();\nsubject\n   .Buffer(TimeSpan.FromMilliseconds(100), 2, scheduler)\n   .Select(list => \"[\" + String.Join(\", \", list) + \"]\")\n   .TimeInterval(scheduler)\n   .Subscribe(v => Console.WriteLine(v));\n\nscheduler.Schedule(TimeSpan.FromMilliseconds(0), () => subject.OnNext(0));\nscheduler.Schedule(TimeSpan.FromMilliseconds(0), () => subject.OnNext(1));\nscheduler.Schedule(TimeSpan.FromMilliseconds(50), () => subject.OnNext(2));\nscheduler.Schedule(TimeSpan.FromMilliseconds(150), () => subject.OnNext(3));\nscheduler.Schedule(TimeSpan.FromMilliseconds(201), () => subject.OnNext(4));\nscheduler.Schedule(TimeSpan.FromMilliseconds(250), () => subject.OnNext(5));\nscheduler.AdvanceBy(TimeSpan.FromMilliseconds(500).Ticks);\n```\n\ngives\n\n```\n[0, 1]@00:00:00.0000001\n[2]@00:00:00.1000000\n[3]@00:00:00.1000000\n[4, 5]@00:00:00.0499999\n[]@00:00:00.1000000\n[]@00:00:00.1000000\n```\n\nAfter the early [4,5], the next buffer takes 100ms rather than 50\n"},{"date":"2015-07-08T17:15:01Z","author":"DavidMGross","text":"Thanks for your help.\n\nOn Tue, Jul 7, 2015 at 3:34 PM, Chris Froussios notifications@github.com\nwrote:\n\n> Rx.NET behaves according to the marble diagram\n> \n> var scheduler = new TestScheduler();\n> var subject = new Subject<int>();\n> subject\n>    .Buffer(TimeSpan.FromMilliseconds(100), 2, scheduler)\n>    .Select(list => \"[\" + String.Join(\", \", list) + \"]\")\n>    .TimeInterval(scheduler)\n>    .Subscribe(v => Console.WriteLine(v));\n> \n> scheduler.Schedule(TimeSpan.FromMilliseconds(0), () => subject.OnNext(0));\n> scheduler.Schedule(TimeSpan.FromMilliseconds(0), () => subject.OnNext(1));\n> scheduler.Schedule(TimeSpan.FromMilliseconds(50), () => subject.OnNext(2));\n> scheduler.Schedule(TimeSpan.FromMilliseconds(150), () => subject.OnNext(3));\n> scheduler.Schedule(TimeSpan.FromMilliseconds(201), () => subject.OnNext(4));\n> scheduler.Schedule(TimeSpan.FromMilliseconds(250), () => subject.OnNext(5));\n> scheduler.AdvanceBy(TimeSpan.FromMilliseconds(500).Ticks);\n> \n> gives\n> \n> [0, 1]@00:00:00.0000001\n> [2]@00:00:00.1000000\n> [3]@00:00:00.1000000\n> [4, 5]@00:00:00.0499999\n> []@00:00:00.1000000\n> []@00:00:00.1000000\n> \n> After the early [4,5], the next buffer takes 100ms rather than 50\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/issues\/3066#issuecomment-119363845.\n\n## \n\nDavid M. Gross\nPLP Consulting\n"},{"date":"2016-04-02T23:55:27Z","author":"akarnokd","text":"RxJava's buffer doesn't restart the timer when the buffer gets full. Question is, should we follow the Rx.NET pattern?\n"},{"date":"2016-06-27T09:45:11Z","author":"akarnokd","text":"I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"}],"opened_by":"Froussios","reopen":false,"closed_on":"2016-06-27T09:45:11Z","description":"The marble diagram in the documentation for the buffer operator\n\n``` java\nbuffer(long timespan, \n          java.util.concurrent.TimeUnit unit,\n          int count)\n```\n\nshows that the duration of a window can be reset if it emits the buffer due to being full.\n_(edit: the linked imaged has been updated)_\n![](https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.png)\nAfter running a few experiments, this is not the case. Here I replicate the example shown in the marble diagram.\n\n``` java\nTestScheduler scheduler = Schedulers.test();\nScheduler.Worker worker = scheduler.createWorker();\n\nPublishSubject<Integer> subject = PublishSubject.create();\nsubject\n    .buffer(100, TimeUnit.MILLISECONDS, 2, scheduler)\n    .timestamp(scheduler)\n    .subscribe(System.out::println);\n\nworker.schedule(() -> subject.onNext(0), 0, TimeUnit.MILLISECONDS);\nworker.schedule(() -> subject.onNext(1), 0, TimeUnit.MILLISECONDS);\nworker.schedule(() -> subject.onNext(2), 50, TimeUnit.MILLISECONDS);\nworker.schedule(() -> subject.onNext(3), 150, TimeUnit.MILLISECONDS);\nworker.schedule(() -> subject.onNext(4), 201, TimeUnit.MILLISECONDS);\nworker.schedule(() -> subject.onNext(5), 250, TimeUnit.MILLISECONDS);\nscheduler.advanceTimeBy(500, TimeUnit.MILLISECONDS);\n```\n\ngives\n\n```\nTimestamped(timestampMillis = 0, value = [0, 1])\nTimestamped(timestampMillis = 100, value = [2])\nTimestamped(timestampMillis = 200, value = [3])\nTimestamped(timestampMillis = 250, value = [4, 5])\nTimestamped(timestampMillis = 300, value = [])\nTimestamped(timestampMillis = 400, value = [])\nTimestamped(timestampMillis = 500, value = [])\n```\n\nWe can see that it continues to emit at multiples of 100, after emiting a full buffer early at 250\n","id":"93531730","title":"Marble diagram for buffer doesn't match actual behaviour","opened_on":"2015-07-07T13:36:47Z","closed_by":"akarnokd"},{"number":"3053","reopenOn":null,"comments":[{"date":"2015-07-17T06:58:33Z","author":"akarnokd","text":"This should be fixed in 1.0.13 RC.\n"},{"date":"2015-08-12T23:49:06Z","author":"akarnokd","text":"Fixed in 1.0.14.\n"}],"opened_by":"wujek-srujek","reopen":false,"closed_on":"2015-08-12T23:49:06Z","description":"It seems, by reading the introtorx.com book and the docs (and testing out) that the buffer and window overloads which take an Observable windowCloseSelector might not be behaving as they do in .NET.\n\nThe original SO topic is here: http:\/\/stackoverflow.com\/questions\/30963993\/rxjava-window-buffer-overload-questions-incompatibility-with-rx-net\n","id":"90733625","title":"window\/buffer overload questions, incompatibility with Rx.NET?","opened_on":"2015-06-24T17:03:07Z","closed_by":"akarnokd"},{"number":"3048","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-07-14T16:29:18Z","description":"`CompositeException` won't crash if it received null by some means. A `null` collection or `null` collection item is replaced by a `NullPointerException` instance.\n\nSee also: #3046.\n","id":"90490780","title":"CompositeException extra NPE protection","opened_on":"2015-06-23T21:08:31Z","closed_by":"benjchristensen"},{"number":"3046","reopenOn":null,"comments":[{"date":"2015-06-23T15:54:01Z","author":"akarnokd","text":"It appears you have a `null` exception added to a composite somewhere. What operators are you using. Do you call `onError(null)` somewhere by accident? \n"},{"date":"2015-06-24T07:01:58Z","author":"sgonchar","text":"I try to get throwable.getMessage callback and have this null pointer.\nI already find the reason. I make mistake at URL and try to connect to non-existent URL. I changed it and all is fine.\nI think you need handle this null pointer in other way, because currently I can't normally find the reason of exception.\nThank you\n"},{"date":"2015-08-12T23:50:50Z","author":"akarnokd","text":"Fix already delivered. Thank you for reporting.\n"}],"opened_by":"sgonchar","reopen":false,"closed_on":"2015-08-12T23:50:50Z","description":"I use RxAndroid library in my project and I have next exception :\n\nE\/AndroidRuntime(27849): Error reporting crash\nE\/AndroidRuntime(27849): java.lang.NullPointerException\nE\/AndroidRuntime(27849): at rx.exceptions.CompositeException.getListOfCauses(CompositeException.java:245)\nE\/AndroidRuntime(27849): at rx.exceptions.CompositeException.getCause(CompositeException.java:100)\nE\/AndroidRuntime(27849): at android.util.Log.getStackTraceString(Log.java:454)\nE\/AndroidRuntime(27849): at android.util.Slog.e(Slog.java:151)\nE\/AndroidRuntime(27849): at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:109)\nE\/AndroidRuntime(27849): at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\nE\/AndroidRuntime(27849): at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\nE\/AndroidRuntime(27849): at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:66)\nE\/AndroidRuntime(27849): at android.os.Handler.handleCallback(Handler.java:733)\nE\/AndroidRuntime(27849): at android.os.Handler.dispatchMessage(Handler.java:95)\nE\/AndroidRuntime(27849): at android.os.Looper.loop(Looper.java:146)\nE\/AndroidRuntime(27849): at android.app.ActivityThread.main(ActivityThread.java:5653)\nE\/AndroidRuntime(27849): at java.lang.reflect.Method.invokeNative(Native Method)\nE\/AndroidRuntime(27849): at java.lang.reflect.Method.invoke(Method.java:515)\nE\/AndroidRuntime(27849): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1291)\nE\/AndroidRuntime(27849): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1107)\nE\/AndroidRuntime(27849): at dalvik.system.NativeStart.main(Native Method)\n\nSomebody know how can I fix it ?\nThank you\n","id":"90380674","title":"NullPointerException at rx.exceptions.CompositeException.getListOfCauses(CompositeException.java:245)","opened_on":"2015-06-23T12:54:15Z","closed_by":"akarnokd"},{"number":"3039","reopenOn":null,"comments":[{"date":"2015-07-14T16:39:38Z","author":"benjchristensen","text":"Thank you for tackling this.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-07-14T16:39:32Z","description":"Fixed unsubscription propagation of two Window variants (boundary, start-end).\n\nIn addition, there was a discrepancy reported on [StackOverflow](http:\/\/stackoverflow.com\/questions\/30963993\/rxjava-window-buffer-overload-questions-incompatibility-with-rx-net) regarding the factory-boundary version. In Rx.NET, the factory is called whenever the previous boundary observable has produced a value. I.e., instead of a series of `onNexts` from the same `Observable`, it uses a series of `Observable`s with a single `onNext` emission as a boundary indicator.\n","id":"90040527","title":"Window with Observable: fixed unsubscription and behavior","opened_on":"2015-06-22T08:19:14Z","closed_by":"benjchristensen"},{"number":"3028","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-06-22T09:05:03Z","description":"Originally, the error through `delay` was emitted directly to the child without serializing in respect of an in-flight `onNext()`. This change schedules the error on the worker with no delay which ensures proper serialization. (The alternative would be to wrap the child into a `SerializedSubscriber`, however, that wouldn't immediately cancel any in-flight onNext schedules.)\n","id":"89240996","title":"Delay: error cut ahead was not properly serialized","opened_on":"2015-06-18T09:12:26Z","closed_by":"akarnokd"},{"number":"3008","reopenOn":null,"comments":[{"date":"2015-06-05T19:16:45Z","author":"akarnokd","text":"\/cc @davidmoten\n"},{"date":"2015-06-05T23:20:54Z","author":"davidmoten","text":"Yep, I'll have a look at it in the next couple of days. @stealthcode I'll check it with #2997 which is looking to address a few `retry` issues.\n"},{"date":"2015-06-08T04:29:04Z","author":"davidmoten","text":"I've tested these with #2997 and they both pass.\n\nThe emissions are for retry with always true predicate:\n\n```\nmap 1\n1\nmap 2\nmap 3\nmap 1\n1\nmap 2\n2\nmap 3\n3\n```\n\nand for infinite retry:\n\n```\nmap 1\n1\nmap 2\nmap 1\n1\nmap 2\n2\nmap 3\n3\n```\n\nThe emissions are the same and are expected. I'm unsure why the extra line `map 3` occurs in the logging of retry with predicate but might be worth checking.\n\nI'll commit the two new unit tests (in `OperatorRetryWithPredicateTest`) to the #2997 PR. \n"},{"date":"2015-08-03T19:33:58Z","author":"stealthcode","text":"This seems to be fixed in the latest 1.x\n"}],"opened_by":"stealthcode","reopen":false,"closed_on":"2015-08-03T19:33:58Z","description":"The following test fails once when mapping 3 values. The subscribe only receives 2 values. \n\n``` java\nfinal AtomicBoolean isFirst = new AtomicBoolean(true);\nObservable.<Long> just(1L, 2L, 3L).map((Long x) -> {\n    System.out.println(\"map \" + x);\n    if (x == 2 && isFirst.getAndSet(false)) {\n        throw new RuntimeException(\"retryable error\");\n    }\n    return x;\n})\n.retry((i, t) -> {return true;})\n.forEach(System.out::println);\n```\n\n**output**\n\n```\nmap 1\n1\nmap 2\nmap 3\n3\n```\n\nWhen you replace `.retry((i, t) -> {return true;})` with the retry infinite `retry()` then the output looks like this...\n\n```\nmap 1\n1\nmap 2\nmap 1\n1\nmap 2\n2\nmap 3\n3\n```\n","id":"85597806","title":"Data loss with RetryWithPredicate as compared to Retry Infinite","opened_on":"2015-06-05T18:18:35Z","closed_by":"stealthcode"},{"number":"3002","reopenOn":null,"comments":[{"date":"2015-06-02T20:10:34Z","author":"akarnokd","text":"Yes, looks odd. I can't really remember why the unsubscription of the worker had to be scheduled. Maybe it had something to do with pitfall no. 2: unsubscribing the downstream: something around subscribe and `SafeSubscriber` doing this and cutting off the last few events from the wrapped `Subscriber`.\n"},{"date":"2015-06-02T22:02:22Z","author":"davidmoten","text":"Might be another problem here that the call to `child.setProducer` is made before adding all the subscriptions. I might test with #2997.\n"},{"date":"2015-06-02T23:09:52Z","author":"benjchristensen","text":"> why the unsubscription of the worker had to be scheduled\n\nWas it was because we could end up not emitting an `onError` that was scheduled but then dropped because the `worker` got unsubscribed?\n"},{"date":"2015-06-02T23:37:46Z","author":"davidmoten","text":"I think @akarnokd is right, that `SafeSubscriber` reports `onCompleted` to its wrapped subscriber then unsubscribes which if `child.add(recursiveScheduler)` is present can cut short the schedule in `OperatorObserveOn` so that it doesn't emit its stuff. \n\nRe `onError` getting dropped this is still a possiblity but still consistent with the Observable contract (?). All the scheduled polls of the queue do check for error first so that once a scheduled task is run the error can shortcut the queue. Perhaps we can do something to aid this scenario without stuffing up the `onComplete` case.\n"},{"date":"2015-06-03T00:17:51Z","author":"davidmoten","text":"I've probably got my last comment backwards. I was thinking that SafeSubscriber was upstream of observeOn but should be downstream so wouldn't have the effect I stated.\n"},{"date":"2015-06-03T06:26:45Z","author":"akarnokd","text":"`SafeSubscriber` came into play earlier when the operators used `subscribe()` to attach to each other instead of `unsafeSubscribe()`.\n"},{"date":"2016-03-13T23:55:42Z","author":"akarnokd","text":"Closing via #3682.\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2016-03-13T23:55:42Z","description":"Need to explore the unsubscribe of `recursiveScheduler`: https:\/\/github.com\/ReactiveX\/RxJava\/blob\/34dce48b4d591a2c574839b4527cbc30cb69e5a2\/src\/main\/java\/rx\/internal\/operators\/OperatorObserveOn.java#L122\n\nIt seems to wrap with `child.add(scheduledUnsubscribe)` and then defeat that with `child.add(recursiveScheduler)`.\n","id":"84171785","title":"ObserveOn: Unsubscribe of RecursiveScheduler","opened_on":"2015-06-02T19:32:13Z","closed_by":"akarnokd"},{"number":"2998","reopenOn":"2015-06-02T19:36:51Z","comments":[{"date":"2015-06-01T21:02:29Z","author":"akarnokd","text":"You shouldn't throw from `onError()` because that exception, usually, has nowhere to go. The RxJava operators are a bit inconsistent about this; some catch it, some let it through and others wrap it around.\n"},{"date":"2015-06-02T19:30:37Z","author":"gdela","text":"I see, so I shouldn't use exception thrown from `onError()` to control flow, because it only seldom bubbles up to the `subscribe()` caller. I think that [this wiki doc](https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Error-Handling) is a little bit misleading about that, because it says something like: _\"if the onError() call itself fails, the Observable [...] will throw a RuntimeException, an OnErrorFailedException, or an OnErrorNotImplementedException\"_.\n"},{"date":"2015-06-02T19:36:35Z","author":"benjchristensen","text":"If we are swallowing an error that's a bug. \n"},{"date":"2015-08-28T17:50:10Z","author":"benjchristensen","text":"It would be helpful it someone can create a failing unit test for this issue that demonstrates where the exception is being swallowed.\n"},{"date":"2015-10-07T11:49:33Z","author":"konmik","text":"```\n@Test(expected = Exception.class)\npublic void throws_exception_from_onNext_onError() throws Exception {\n    Observable\n        .just(1)\n        .doOnNext(new Action1<Integer>() {\n            @Override\n            public void call(Integer integer) {\n                throw new RuntimeException();\n            }\n        })\n        .subscribe(\n            new Action1<Integer>() {\n                @Override\n                public void call(Integer integer) {\n\n                }\n            }, new Action1<Throwable>() {\n                @Override\n                public void call(Throwable throwable) {\n                    throw new RuntimeException();\n                }\n            });\n}\n\n@Test(expected = Exception.class)\npublic void throws_exception_from_switchMap_onError() throws Exception {\n    Observable\n        .just(1)\n        .switchMap(new Func1<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> call(Integer integer) {\n                return Observable.error(new RuntimeException());\n            }\n        })\n        .subscribe(\n            new Action1<Integer>() {\n                @Override\n                public void call(Integer integer) {\n\n                }\n            }, new Action1<Throwable>() {\n                @Override\n                public void call(Throwable throwable) {\n                    throw new RuntimeException();\n                }\n            });\n}\n\n@Test(expected = Exception.class)\npublic void throws_exception_from_flatMap_onError() throws Exception {\n    Observable\n        .just(1)\n        .flatMap(new Func1<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> call(Integer integer) {\n                return Observable.error(new RuntimeException());\n            }\n        })\n        .subscribe(\n            new Action1<Integer>() {\n                @Override\n                public void call(Integer integer) {\n\n                }\n            }, new Action1<Throwable>() {\n                @Override\n                public void call(Throwable throwable) {\n                    throw new RuntimeException();\n                }\n            });\n}\n\n@Test(expected = Exception.class)\npublic void throws_exception_from_groupBy_onError() throws Exception {\n    Observable\n        .just(1)\n        .groupBy(new Func1<Integer, Integer>() {\n            @Override\n            public Integer call(Integer integer) {\n                throw new RuntimeException();\n            }\n        })\n        .subscribe(\n            new Action1<GroupedObservable<Integer, Integer>>() {\n                @Override\n                public void call(GroupedObservable<Integer, Integer> integerIntegerGroupedObservable) {\n\n                }\n            }, new Action1<Throwable>() {\n                @Override\n                public void call(Throwable throwable) {\n                    throw new RuntimeException();\n                }\n            });\n}\n```\n"},{"date":"2015-10-07T11:58:19Z","author":"konmik","text":"Please let me know if someone is going to fix this.\n\nSorry, I don't feel that I can fix this myself - concurrency is not my strongest skill.\n"},{"date":"2015-10-07T12:21:52Z","author":"akarnokd","text":"This has nothing to do with concurrency but with fault tolerance. The problem is that if the call to onError throws, there is no clear path that could propagate the exception out of the operator chain. For example, if an `onNext` calls an `onError` which throws, the caller of `onNext` can't know if `onNext` itself failed or who else and may happily call a chain of `onError`s which end up throwing again. Therefore, either we always propagate exceptions up the stack until the thread-root is reached or sink the exception of `onError` into some plugin handler.\n"},{"date":"2015-10-07T12:29:45Z","author":"konmik","text":"I think that a clean way to do this could be creation of `RethrowAlwaysException` which decorates the original exception and which should be rethrown on every check. It should be unwrapped at the top loop and rethrown again unwrapped out of reach of rx chain.\n"},{"date":"2015-10-07T12:31:17Z","author":"akarnokd","text":"That works until the first async boundary where it will probably be swallowed by the `ExecutorService`.\n"},{"date":"2015-10-07T12:34:50Z","author":"konmik","text":"How does `OnErrorNotImplementedException` not get swallowed then? If I replace `RuntimeException` with `OnErrorNotImplementedException` it does not get swallowed.\n"},{"date":"2015-10-07T12:40:56Z","author":"akarnokd","text":"Most exception blocks around onNext and callbacks use `Exceptions.throwIfFatal` which checks for `OnErrorNotImplementedException`. This could be extended to handle `OnErrorThrewException` wrapper indeed, but we'd have to check and wrap every call to `onError` into a try-catch to convert to this exception. The async boundary is still a problem.\n"},{"date":"2015-10-07T13:02:35Z","author":"konmik","text":"How about wrapping only subscriber's `onError`?\n"},{"date":"2015-10-07T14:11:16Z","author":"akarnokd","text":"Could work. Could you post a PR with the changes and your unit tests to see if it really does?\n"},{"date":"2015-10-07T17:55:08Z","author":"konmik","text":"I can't build, I think there is something with the windows OS I'm running.\n\n`Caused by: org.eclipse.jgit.errors.RepositoryNotFoundException: repository not found: E:\\RxJava-1.x`\n\nhttps:\/\/github.com\/ReactiveX\/RxJava\/issues\/2651\n"},{"date":"2015-10-07T18:04:34Z","author":"akarnokd","text":"I'm developing RxJava under Windows with Eclipse Mars + Gradle plugin without any issues.\n"},{"date":"2015-10-07T18:08:25Z","author":"JakeWharton","text":"@konmik you need to clone the repo from git and not just download zip. The build plugins require that the project be build from inside of a git repo.\n"},{"date":"2015-10-07T20:53:02Z","author":"konmik","text":"Thanks, @JakeWharton.\n\nIt looks like we already have the required `OnErrorFailedException` https:\/\/github.com\/ReactiveX\/RxJava\/issues\/969\n\nThe first idea is to comment some lines out to allow `RuntimeException` to propagate.\n\n``` java\n    public static void throwIfFatal(Throwable t) {\n        if (t instanceof OnErrorNotImplementedException) {\n            throw (OnErrorNotImplementedException) t;\n        } else if (t instanceof OnErrorFailedException) {\n\/\/            Throwable cause = t.getCause();\n\/\/            if (cause instanceof RuntimeException) {\n\/\/                throw (RuntimeException) cause;\n\/\/            } else {\n                throw (OnErrorFailedException) t;\n\/\/            }\n        }\n```\n\nWhile this does not solve the problem of the `groupBy` operator, this allows my other tests to pass.\n\nI'll spend some time investigating the issue.\n"},{"date":"2015-11-09T21:30:50Z","author":"akarnokd","text":"I guess this issue has been fixed in #3455 and delivered in 1.0.15.\n"}],"opened_by":"gdela","reopen":true,"closed_on":"2015-11-09T21:30:50Z","description":"This issue is related to #969, where it has been said that following code should throw exception:\n\n```\nObservable.error(new Exception())\n  .subscribe(new Observer<Object>() {\n    public void onCompleted() {\n      \/\/ noop\n    }\n    public void onError(Throwable e) {\n      throw new IllegalStateException(\"This should crash the app\");\n    }\n    public void onNext(Object o) {\n      \/\/ noop\n    }\n  });\n```\n\nAnd it does throw exception, but when you add `groupBy`\/`flatMap` like that:\n\n```\nObservable.error(new Exception())\n  .groupBy(o -> o)\n  .flatMap(g -> g)\n  .subscribe(new Observer<Object>() {\n    public void onCompleted() {\n      \/\/ noop\n    }\n    public void onError(Throwable e) {\n      throw new IllegalStateException(\"This should crash the app\");\n    }\n    public void onNext(Object o) {\n      \/\/ noop\n    }\n  });\n```\n\nThen the exception is silently swallowed. I tried to debug it a little bit, and seems that it could be because `OnErrorFailedException` is wrapped with `CompositeException`, so `Exceptions.throwIfFatal()` doesn't recognize it as fatal.\n","id":"83690260","title":"Exception thrown from onError() is swallowed when using groupBy\/flatMap","opened_on":"2015-06-01T20:57:33Z","closed_by":"akarnokd"},{"number":"2997","reopenOn":null,"comments":[{"date":"2015-06-01T03:35:04Z","author":"davidmoten","text":"To induce failure I run this in a loop:\n\n``` bash\n.\/gradlew -i -Dtest.single=OperatorRetry cleanTest test\n```\n\nOn Ubuntu 14.04 64-bit i7 i7 CPU 920 @ 2.67GHz × 8, home desktop,  java 1.8u45:\n\n? tested with wrong branch version, testing again !\n\nOn Ubuntu 14.04 64-bit  i5 CPU U 470 @ 1.33GHz × 4, laptop, java 1.8u45:\n\n**238th** run:\n\n```\njava.lang.AssertionError: Data content mismatch: 1638={beginningEveryTime x 130}\n    at org.junit.Assert.fail(Assert.java:93)\n    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:768)\n```\n"},{"date":"2015-06-08T17:04:55Z","author":"akarnokd","text":"I still don't understand the cause of the failure. The best thing we can do is to increase that await timeout in the test to 5-7 seconds because this seems to be some transient hiccup rather than a hang. Otherwise, support this PR but defer the judgement to @benjchristensen .\n"},{"date":"2015-06-08T23:11:28Z","author":"davidmoten","text":"removed last comment, ran on wrong branch\n"},{"date":"2015-06-08T23:58:51Z","author":"davidmoten","text":"I bumped up await timeout to 5 minutes and the 54th run failed in  5 mins 9.9 seconds (on home desktop):\n\n``` java\nrx.internal.operators.OperatorRetryTest > testRetryWithBackpressureParallel FAILED\n    java.lang.AssertionError: Data content mismatch: 950={beginningEveryTime x 136}\n        at org.junit.Assert.fail(Assert.java:93)\n        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTes\nt.java:768)\n```\n\n5 minutes is a long time for some OS hiccup and makes me think that the freeze is occurring because of our code.\n\nI'll run another test and dump all threads after the freeze.\n"},{"date":"2015-06-09T06:33:39Z","author":"akarnokd","text":"Then we need a full rewrite, but I don't have time for it for at least 3 months.\n"},{"date":"2015-06-09T13:00:52Z","author":"davidmoten","text":"Thread dump after freeze occuring on 84th run on home desktop:\n\n```\nrx.internal.operators.OperatorRetryTest > testRetryWithBackpressureParallel STANDARD_OUT\n    testRetryWithBackpressureParallelLoop -> 0\n    \"pool-1-thread-4\" \n       java.lang.Thread.State: WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n            at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)\n            at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"pool-1-thread-3\" \n       java.lang.Thread.State: WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n            at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)\n            at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"pool-1-thread-2\" \n       java.lang.Thread.State: RUNNABLE\n            at sun.management.ThreadImpl.getThreadInfo1(Native Method)\n            at sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:174)\n            at rx.internal.operators.OperatorRetryTest.dumpAllThreads(OperatorRetryTest.java:913)\n            at rx.internal.operators.OperatorRetryTest.access$300(OperatorRetryTest.java:44)\n            at rx.internal.operators.OperatorRetryTest$14.run(OperatorRetryTest.java:751)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"pool-1-thread-1\" \n       java.lang.Thread.State: WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n            at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)\n            at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"RxComputationThreadPool-8\" \n       java.lang.Thread.State: WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1081)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)\n            at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"RxComputationThreadPool-7\" \n       java.lang.Thread.State: WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1081)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)\n            at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"RxComputationThreadPool-6\" \n       java.lang.Thread.State: WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1081)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)\n            at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"RxComputationThreadPool-5\" \n       java.lang.Thread.State: WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1081)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)\n            at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"RxComputationThreadPool-4\" \n       java.lang.Thread.State: WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1081)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)\n            at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"RxComputationThreadPool-3\" \n       java.lang.Thread.State: WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1081)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)\n            at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"RxComputationThreadPool-2\" \n       java.lang.Thread.State: TIMED_WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1093)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)\n            at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"RxComputationThreadPool-1\" \n       java.lang.Thread.State: TIMED_WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1093)\n            at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)\n            at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"\/0:0:0:0:0:0:0:1:51855 to \/0:0:0:0:0:0:0:1%lo:50738 workers Thread 3\" \n       java.lang.Thread.State: RUNNABLE\n            at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)\n            at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)\n            at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:79)\n            at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)\n            at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)\n            at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:101)\n            at org.gradle.messaging.remote.internal.inet.SocketConnection$SocketInputStream.read(SocketConnection.java:149)\n            at com.esotericsoftware.kryo.io.Input.fill(Input.java:139)\n            at com.esotericsoftware.kryo.io.Input.require(Input.java:159)\n            at com.esotericsoftware.kryo.io.Input.readByte(Input.java:255)\n            at org.gradle.messaging.serialize.kryo.KryoBackedDecoder.readByte(KryoBackedDecoder.java:80)\n            at org.gradle.messaging.remote.internal.hub.InterHubMessageSerializer$MessageReader.read(InterHubMessageSerializer.java:69)\n            at org.gradle.messaging.remote.internal.hub.InterHubMessageSerializer$MessageReader.read(InterHubMessageSerializer.java:58)\n            at org.gradle.messaging.remote.internal.inet.SocketConnection.receive(SocketConnection.java:74)\n            at org.gradle.messaging.remote.internal.hub.MessageHub$ConnectionReceive.run(MessageHub.java:235)\n            at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:64)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"\/0:0:0:0:0:0:0:1:51855 to \/0:0:0:0:0:0:0:1%lo:50738 workers Thread 2\" \n       java.lang.Thread.State: WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n            at org.gradle.messaging.remote.internal.hub.queue.EndPointQueue.take(EndPointQueue.java:49)\n            at org.gradle.messaging.remote.internal.hub.MessageHub$ConnectionDispatch.run(MessageHub.java:278)\n            at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:64)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"Test worker\" \n       java.lang.Thread.State: WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)\n            at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)\n            at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:771)\n            at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n            at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n            at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n            at java.lang.reflect.Method.invoke(Method.java:497)\n            at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n            at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n            at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n            at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n            at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n            at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n            at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n            at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n            at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n            at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n            at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n            at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n            at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n            at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:86)\n            at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:49)\n            at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)\n            at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:48)\n            at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n            at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n            at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n            at java.lang.reflect.Method.invoke(Method.java:497)\n            at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n            at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n            at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n            at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n            at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\n            at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:105)\n            at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n            at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n            at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n            at java.lang.reflect.Method.invoke(Method.java:497)\n            at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n            at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n            at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:360)\n            at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:64)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            at java.lang.Thread.run(Thread.java:745)\n\n    \"Signal Dispatcher\" \n       java.lang.Thread.State: RUNNABLE\n\n    \"Finalizer\" \n       java.lang.Thread.State: WAITING\n            at java.lang.Object.wait(Native Method)\n            at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)\n            at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)\n            at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)\n\n    \"Reference Handler\" \n       java.lang.Thread.State: WAITING\n            at java.lang.Object.wait(Native Method)\n            at java.lang.Object.wait(Object.java:502)\n            at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:157)\n\n    \"main\" \n       java.lang.Thread.State: WAITING\n            at sun.misc.Unsafe.park(Native Method)\n            at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)\n            at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)\n            at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)\n            at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:68)\n            at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:44)\n            at org.gradle.process.internal.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:78)\n            at org.gradle.process.internal.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:35)\n            at org.gradle.process.internal.child.ImplementationClassLoaderWorker.execute(ImplementationClassLoaderWorker.java:85)\n            at org.gradle.process.internal.child.ImplementationClassLoaderWorker.execute(ImplementationClassLoaderWorker.java:41)\n            at org.gradle.process.internal.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:43)\n            at org.gradle.process.internal.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:32)\n            at org.gradle.process.internal.launcher.BootstrapClassLoaderWorker.call(BootstrapClassLoaderWorker.java:46)\n            at org.gradle.process.internal.launcher.BootstrapClassLoaderWorker.call(BootstrapClassLoaderWorker.java:32)\n            at jarjar.org.gradle.process.internal.launcher.GradleWorkerMain.run(GradleWorkerMain.java:32)\n            at jarjar.org.gradle.process.internal.launcher.GradleWorkerMain.main(GradleWorkerMain.java:37)\n\n\n\nrx.internal.operators.OperatorRetryTest > testRetryWithBackpressureParallel FAILED\n    java.lang.AssertionError: Data content mismatch: 4208={beginningEveryTime x 128}\n        at org.junit.Assert.fail(Assert.java:93)\n        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:774)\n\n```\n"},{"date":"2015-06-10T23:07:37Z","author":"stealthcode","text":"@akarnokd I suspect that the retry when code base is exposing a race condition somewhere in the merge, producer, subscriber interactions. I think that we should hold off on any kind of a rewrite until #2928 is resolved. \n"},{"date":"2015-06-10T23:50:09Z","author":"davidmoten","text":"At the moment I don't suspect problems with the `OnSubscribeRedo` class and\n- `OperatorObserveOn` has been improved and inspected pretty closely (a little more to do there with unsubscribe)\n- I don't suspect `PublishSubject` after trying simpler single subscriber versions of `PublishSubject` \n- I scanned further into `Scheduler`s and the subscriber hook-up and found nothing\n\nI've been looking elsewhere and now my suspicions lie with the gradle infrastructure. I believe the tests for `retry` (redo) don't fail when jammed in a loop and left for a long time, it is only when gradle is repeatedly asked to clean and test that it fails infrequently and perhaps because of some NIO lockup. \n\nThis is an unusual case inasmuch as we don't normally rely on tests looping on gradle tests but rather run loops in a single JVM. A fresh JVM can sometimes expose race conditions that aren't as easily exposed by a warmed-up JVM but I think this is being pushed a bit far and might be exposing us to rarely encountered gradle bugs too.\n\nI think `OnSubscribeRedo` is ready for review (it certainly fixes known bugs with `retry` so there is some imperative to get this in).\n"},{"date":"2015-06-17T12:14:34Z","author":"akarnokd","text":"I think it is as good as it can get for now. I think we can return to the case when we port things over to RxJava 2.0. Thanks!\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-06-17T12:14:39Z","description":"This is the continuation of #2930 with a rebased PR.\n\nThere are sporadic testing failures with this PR so not ready for merge. I'll note some failures with this one soon.\n","id":"83289084","title":"Fix retry() race conditions","opened_on":"2015-06-01T03:21:23Z","closed_by":"akarnokd"},{"number":"2996","reopenOn":null,"comments":[{"date":"2015-06-01T00:58:08Z","author":"davidmoten","text":"Made those changes, ta.\n"},{"date":"2015-06-01T01:42:46Z","author":"davidmoten","text":"Cleaned up a bit, made the parent subscriber class a static class and improved names\n"},{"date":"2015-06-01T07:25:24Z","author":"davidmoten","text":"Well spotted, thanks. Updated.\n"},{"date":"2015-06-01T10:08:17Z","author":"davidmoten","text":"Erk, thanks for noticing that. Updated.\n"},{"date":"2015-06-01T10:19:35Z","author":"akarnokd","text":"Great, thanks!\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-06-01T10:19:39Z","description":"`OperatorSwitchIfEmpty` suffered from these conditions:\n- Backpressure was not enabled for the source observable (as opposed to the altenate) because `setProducer` called `super.setProducer` instead of `child.setProducer`\n- Requests could be lost\n\nBot the of the above problems are solved by using `ProducerArbiter` from @akarnokd.\n\nIncluded two unit tests that failed on previous code.\n","id":"83063734","title":"switchIfEmpty - fix backpressure bug and lost requests","opened_on":"2015-05-31T11:05:42Z","closed_by":"akarnokd"},{"number":"2995","reopenOn":null,"comments":[{"date":"2015-05-31T12:34:56Z","author":"akarnokd","text":"I'd like to review the whole operator (can't do it today) because I have a feeling a complex serialization is required (i.e., a `ProducerObserverArbiter` level).\n"},{"date":"2015-05-31T19:54:52Z","author":"davidmoten","text":"Yeah I'm not surprised at that, I suspected the same but put off a full head scratch till later.\n"},{"date":"2015-06-17T12:11:13Z","author":"akarnokd","text":"I'm merging this as is and perhaps come back later to think about corner cases remaining.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-06-17T12:11:16Z","description":"`OperatorSwitch` didn't record the total of requests before first inner subscription occurring and had problems with request overflow. \n\nIncludes 4 unit tests that failed on the original code.\n","id":"83026072","title":"switchOnNext - ensure initial requests additive and fix request overflow","opened_on":"2015-05-31T07:24:15Z","closed_by":"akarnokd"},{"number":"2992","reopenOn":null,"comments":[{"date":"2015-05-30T07:49:03Z","author":"akarnokd","text":"Good catch!\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-05-30T07:49:05Z","description":"When an error occurs some `Operator`s (like `map`) include the value in the exception cause to help debugging. The intent is that for the 9 primitive types (int\/Integer, double\/Double, byte\/Byte, char\/Character etc) we render the value using `value.toString` but the test for being a primitive does not work because `.isPrimitive` always returns false (primitives have always been autoboxed by the time they get here).\n\nThe fix is to create a lazy loaded singleton set of the primitive classes (Integer.class, Double.class, etc) and check for membership in that set.\n\nUnit tests included for each primitive type.\n","id":"82679497","title":"Fix value rendering in error last cause for primitive types","opened_on":"2015-05-30T03:15:49Z","closed_by":"akarnokd"},{"number":"2989","reopenOn":null,"comments":[{"date":"2015-05-29T07:50:21Z","author":"davidmoten","text":"Thanks @akarnokd. Changes made.\n"},{"date":"2015-05-29T08:05:51Z","author":"akarnokd","text":"Great job!\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-05-29T08:05:53Z","description":"The `request` method used logic that could overrequest upstream if multiple small requests were made before the next item arrived.\n\nAdded a unit test that failed on previous code.\n","id":"82169031","title":"prevent take() from requesting more than needed","opened_on":"2015-05-28T23:27:35Z","closed_by":"akarnokd"},{"number":"2987","reopenOn":null,"comments":[{"date":"2015-05-28T10:27:32Z","author":"akarnokd","text":"A shorter solution would be:\n\n``` java\n@Override\npublic void setProducer(Producer producer) {\n    super.setProducer(producer);\n    producer.request(toSkip);\n}\n```\n\nwhich, in theory, should retain the ability to run unbounded and trigger the fast-paths.\n"},{"date":"2015-05-28T10:33:47Z","author":"davidmoten","text":"Beautiful solution! I've updated the commit.\n"},{"date":"2015-05-28T10:46:23Z","author":"akarnokd","text":"Sorry, I wasn't completely right and one slight change is required: replace `super` with `child` to avoid the possibility of interference from the Subscriber (because unspecified initial request is turned into MAX_VALUE request in some cases). The reactive-streams API is so much better\/clearer in this regard...\n"},{"date":"2015-05-28T10:54:14Z","author":"davidmoten","text":"righto, have done.\n"},{"date":"2015-05-28T12:17:47Z","author":"akarnokd","text":"Thanks!\n"},{"date":"2015-06-09T20:01:28Z","author":"benjchristensen","text":"> The reactive-streams API is so much better\/clearer in this regard...\n\nYes it is.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-05-28T12:17:49Z","description":"`OperatorSkip` suffered from this race condition:\n\nSuppose we wanted to skip 5 elements, then\n- two concurrent requests of say 1 between onStart request of 0 and first emission would request 1+ (5-0) and 1 + (5-0) elements = 12 elements. To deliver the two requested we only need 7 from upstream so we have overrequested.\n\nIt also lacked protection from request overflow.\n\nTwo unit tests have been added that failed on previous code and now pass.\n","id":"81857384","title":"fix skip() race condition and request overflow","opened_on":"2015-05-28T10:04:02Z","closed_by":"akarnokd"},{"number":"2983","reopenOn":null,"comments":[{"date":"2015-07-07T19:07:43Z","author":"ibaca","text":"(I know that is easy to complain :wink:) This decorator strategy is not very memory friendly, you have this annoying (gwt compatibility perspective) AtomicXxxFieldUpdater in a lot of places to reduce memory usage, and you end up adding this decorators to only disable one method call.\n\nWhat do you think?. Thanks to solve the problem anyway :smile:.\n"},{"date":"2015-07-07T19:48:15Z","author":"davidmoten","text":"Yikes! There's a lot of stuffed up backpressure fixed here. I'm hoping we can release soon.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-06-17T11:56:38Z","description":"Started investigating multiple calls to onStart based on #2979 and found a bunch, but since onStart can be overridden, I might have missed cases. In addition, I've found a single place where a producer is set twice on a subscriber but again, many other places may exist.\n","id":"80832457","title":"Fixed multiple calls to onStart.","opened_on":"2015-05-26T07:18:17Z","closed_by":"akarnokd"},{"number":"2980","reopenOn":null,"comments":[{"date":"2015-05-22T20:43:40Z","author":"akarnokd","text":"The executor handles the race and we simply ignore the RejectedExecutionException.\n"},{"date":"2015-05-22T20:54:53Z","author":"headinthebox","text":"Must be code blind at the moment, where do they get caught?\n"},{"date":"2015-05-22T22:21:28Z","author":"benjchristensen","text":"Okay I'm curious now ... where do we catch that exception to ignore it? :-)\n\nIt definitely throws one: http:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/concurrent\/ExecutorService.html#submit-java.util.concurrent.Callable-\n\nI've been tracing through the code and honestly can't figure out where the try\/catch is at if we do catch and ignore it.\n"},{"date":"2015-05-22T23:56:10Z","author":"iNoles","text":"@benjchristensen It is in https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/schedulers\/ExecutorScheduler.java\n"},{"date":"2015-05-23T14:03:49Z","author":"akarnokd","text":"ScheduledAction.run\nObservable.create\nObservable.lift\n"},{"date":"2015-05-23T15:21:40Z","author":"headinthebox","text":"We cannot rely on the latter two, as schedulers are useful by themselves.\n"}],"opened_by":"headinthebox","reopen":false,"closed_on":"2015-05-22T21:15:43Z","description":"https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/schedulers\/NewThreadWorker.java\n\nThread A calls w.schedule(\u2026), passes the test on line 151, then sits at line 153\nThread B calls w.unsubscribe() and sits at line 213\nThread A enters scheduleActual and executes until line 169 where it calls schedule on an executor that has been shut down.\n","id":"79593071","title":"Race condition in NewThreadWorker","opened_on":"2015-05-22T20:14:43Z","closed_by":"headinthebox"},{"number":"2979","reopenOn":null,"comments":[{"date":"2015-05-22T11:28:33Z","author":"akarnokd","text":"Thanks for discovering this.\n\nWith a little overhead, it is possible to suppress the second `onStart` call in defer by wrapping the subscriber with another subscriber that does nothing in its `onStart`. Would you like to submit a PR?\n"},{"date":"2015-05-22T11:42:25Z","author":"akarnokd","text":"In fact, many other operators suffer from the same issue. You can discover them by altering Subscriber and running the standard tests:\n\n``` java\nfinal AtomicInteger once = new AtomicInteger();\n\/\/ ...\npublic void onStart() {\n    if (once.getAndIncrement() > 0) {\n        throw new IllegalStateException();\n    }\n}\n```\n"},{"date":"2015-07-07T18:59:11Z","author":"ibaca","text":"Closing because has been solved by #2983. Thanks!\n"}],"opened_by":"ibaca","reopen":false,"closed_on":"2015-07-07T18:59:11Z","description":"This test shows the onStart called twice problem. It is a clone of SubscriberTest.testOnStartCalledOnceViaUnsafeSubscribe but adding the defer operator which calls unsafeSubscribe resulting in a nested call to unsafeSubscribe, the one from the test and the second one from OnSubscribeDefer.\n\n``` java\n@Test\npublic void testOnStartCalledOnceViaNestedUnsafeSubscribe() {\n    final AtomicInteger c = new AtomicInteger();\n    Observable.defer(new Func0<Observable<Integer>>() {\n        @Override public Observable<Integer> call() {\n            return Observable.just(1, 2, 3, 4).take(2);\n        }\n    }).unsafeSubscribe(new Subscriber<Integer>() {\n        @Override public void onStart() {\n            c.incrementAndGet();\n            request(1);\n        }\n\n        @Override public void onCompleted() { }\n\n        @Override public void onError(Throwable e) { }\n\n        @Override public void onNext(Integer t) {\n            request(1);\n        }\n    });\n\n    assertEquals(1, c.get());\n}\n```\n\nTwo proposed solutions (first one looks ugly, second one adds more code to Subscriber)\n1. Add a parameter to subscription calls to transfer the 'onStart called' state.\n2. Modify Subscriber so .subscribe() .unsafeSubscribe() calls Subscriber.start() which delegates to the  actual .onStart() protecting for duplicate calls.\n","id":"79410119","title":"Subscriber.onStart is called twice on nested unsafeSubscription","opened_on":"2015-05-22T11:09:00Z","closed_by":"ibaca"},{"number":"2972","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-06-17T11:57:42Z","description":"backpressure support to window(size, skip).\n\nSee #1880.\n","id":"78486657","title":"Fixed window(time) to work properly with unsubscription, added","opened_on":"2015-05-20T11:29:41Z","closed_by":"akarnokd"},{"number":"2961","reopenOn":null,"comments":[{"date":"2015-05-19T07:39:19Z","author":"davidmoten","text":"yeah I like your first suggestion, I'll look at that\n"},{"date":"2015-05-19T08:01:21Z","author":"davidmoten","text":"I've moved the subscription to sources loop into the call method as suggested.\n"},{"date":"2015-05-19T11:12:04Z","author":"davidmoten","text":"I've done that and reduced volatile reads a bit too. Given that `selection` and `selection.choice` are both final fields what is the interaction with the memory barriers? (sorry, a bit of a general question this for my education)\n"},{"date":"2015-05-19T11:21:49Z","author":"akarnokd","text":"Variables tend to be re-read around volatiles and the JIT _may_ be smart enough to optimize it and pull them upfront, but you can't be sure.\n"},{"date":"2015-05-19T11:41:31Z","author":"davidmoten","text":"added `ambSubscribers` final variable\n"},{"date":"2015-05-19T12:15:34Z","author":"davidmoten","text":"ok, done\n"},{"date":"2015-05-19T14:49:46Z","author":"akarnokd","text":"I'd like to review the whole operator but I don't have the time and the focus to do it now. I'll come back to this in a few hours.\n"},{"date":"2015-05-19T16:56:10Z","author":"zsxwing","text":"> if m requests were made before the first emission then m subscriptions were started on each source observable. We only want once subscription on each.\n\nMaybe I missed some discussion about this case. So now we support calling `request` in `onStart` multiple times?\n"},{"date":"2015-05-19T20:59:00Z","author":"davidmoten","text":"> Maybe I missed some discussion about this case. So now we support calling request in onStart multiple times?\n\nYes we do, multiple requests in `onStart` are additive but this is about what happens between subscriptions starting and first emission occurring. The new test `testSubscriptionOnlyHappensOnce` demos the problem in that by subscribing to an `amb` of async sources with an `onStart` request of one and then immediately (post subscription) calling `request(1)` we get a bunch of extra subscriptions.\n"},{"date":"2015-05-20T00:31:21Z","author":"davidmoten","text":"Interesting point but I assume async operators downstream of the `amb` could do what we are trying to simulate with `TestSubscriber`.\n\nSaying that requests between between `onStart` and first emission are forbidden is not something I see documented anywhere, let me know if you see it. \n"},{"date":"2015-05-20T00:36:13Z","author":"zsxwing","text":"> Saying that requests between between onStart and first emission are forbidden is not something I see documented anywhere, let me know if you see it.\n\nI don't mean it. I mean `request` is `protected` to avoid calling out of `Subscriber`.\n"},{"date":"2015-05-20T01:11:51Z","author":"zsxwing","text":"LGTM for the fix. Just some minor comments for the tests.\n"},{"date":"2015-05-20T02:06:31Z","author":"davidmoten","text":"@zsxwing I've updated the test that called `ts.requestMore(1)` before subscription so that it uses the `onStart` method of `TestSubscriber` instead. Thanks for the review.  \n"},{"date":"2015-05-20T02:11:51Z","author":"zsxwing","text":"LGTM. Let's wait for @akarnokd to take a final look.\n"},{"date":"2015-05-20T07:27:44Z","author":"akarnokd","text":"I found a few places for possible optimizations:\n- in `AmbSubscriber`, you can have a plain `boolean chosen` field to avoid the reference comparison:\n\n```\nboolean chosen;\n...\n    private boolean isSelected() {\n        if (chosen) {\n            return true;\n        }\n        if (selection.choice.get() == this) {\n            \/\/ fast-path\n            chosen = true;\n            return true;\n        } else {\n            if (selection.choice.compareAndSet(null, this)) {\n                selection.unsubscribeOthers(this);\n                chosen = true;\n                return true;\n            } else {\n                \/\/ we lost so unsubscribe ... and force cleanup again due to possible race conditions\n                selection.unsubscribeLosers();\n                return false;\n            }\n        }\n    }\n```\n- There is a race between the unsubscription logic at L360 and the loop at L381: while the loop is busy creating and subscribing `AmbSubscriber`s, a concurrent unsubscribe will start cancelling that have reached the queue but any subsequent. Possible solutions:\n  - Move the creation and enqueueing of `AmbSubscriber`s at the beginning, then create the unsubscription logic and finally loop and subscribe the `AmbSubscribers`. This way, the queue will contain all that need to be unsubscribed.\n  - Instead of quitting after the `subscriber.isUnsubscribed()`, drain the queue and unsubscribe its contents, do a similar check after the loop as well to clean up any stragglers.\n  - Have a custom subscription manager, similar to what the subjects use that can unsubscribe latecommers and keep the current one-loop approach (I have plans to cover such custom container in my blog soon.)\n"},{"date":"2015-05-21T00:03:24Z","author":"davidmoten","text":"I like the optimization for `isSelected`. I've also committed the first approach for the unsub race but I think we can do better as you imply. Might go for the second.\n"},{"date":"2015-05-24T05:33:33Z","author":"davidmoten","text":"> Instead of quitting after the subscriber.isUnsubscribed(), drain the queue and unsubscribe its contents, do a similar check after the loop as well to clean up any stragglers.\n\nI've implemented this suggestion @akarnokd. Ready for (another) review, thanks.\n"},{"date":"2015-05-26T07:30:06Z","author":"akarnokd","text":"Looks good. Thanks!\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-05-26T07:30:09Z","description":"The Amb operator has a backpressure bug:\n- if `m` requests were made before the first emission then `m` subscriptions were started on each source observable. We only want once subscription on each.\n\nThis PR adds fix code to  `OnSubscribeAmb` and two unit tests.\n","id":"77945701","title":"fix Amb backpressure bug","opened_on":"2015-05-19T05:48:55Z","closed_by":"akarnokd"},{"number":"2960","reopenOn":null,"comments":[{"date":"2015-05-19T07:36:41Z","author":"davidmoten","text":"Yeah my focus was very narrow. Similar situation to retry so 'ProducerArbiter` will be the go. Those producers sound great, thanks.\n"},{"date":"2015-05-20T07:31:24Z","author":"akarnokd","text":"The new producers have been merged into 1.x.\n"},{"date":"2015-05-20T07:56:44Z","author":"akarnokd","text":"Could you also see if #2876 passes as well?\n"},{"date":"2015-05-27T08:07:17Z","author":"davidmoten","text":"Ok, I've introduced the joys of `ProducerArbiter` to `OperatorConcat`. Tests pass and I've added the test from #2876 which doesn't fail after running for tens of minutes. There is one catch though, I changed the #2876 test to use `Observable.from(Arrays.asList(t))` instead of `Observable.just(t)` so would be backpressure aware. Using `ProducerArbiter` means that sources that emit more than requested like `Observable.just` may induce an `IllegalStateException` from `ProducerArbiter`.\n\nI'm supposing at some stage in the future (2.0?) we will be strict about our sources but till then perhaps we should allow a `ProducerArbiter` to be created in non-strict mode so that if a source emits more than requested it is forgiving about it?\n"},{"date":"2015-05-27T08:18:28Z","author":"akarnokd","text":"No, because it would derail the state validation.\n"},{"date":"2015-05-27T08:55:29Z","author":"davidmoten","text":"Changed the test duration to 2 seconds and added error message to `ProducerArbiter` so users will have a bit more of an idea what went wrong if the produced-more-than-requested IllegalStateException occcurs.\n"},{"date":"2015-05-27T09:07:32Z","author":"davidmoten","text":"Unrelated CI failure, issue #2870 covers it.\n\n```\nrx.internal.operators.OperatorSerializeTest > testMultiThreadedWithNPEinMiddle FAILED\n    java.lang.AssertionError\n        at org.junit.Assert.fail(Assert.java:92)\n        at org.junit.Assert.assertTrue(Assert.java:43)\n        at org.junit.Assert.assertTrue(Assert.java:54)\n        at rx.internal.operators.OperatorSerializeTest.testMultiThreadedWithNPEinMiddle(OperatorSerializeTest.java:134)\n```\n"},{"date":"2015-05-27T09:14:24Z","author":"akarnokd","text":"Maybe it is time to make just() do backpressure properly.\n\nWould you like to pursue a fix for `testMultiThreadedWithNPEinMiddle`? I think if the exception itself is created way upfront and not new'd in place, the chance of it delayed quite to the end should decrease significantly.\n"},{"date":"2015-05-27T09:22:06Z","author":"davidmoten","text":"Sure, I can look at it. \n\nBy the way I've removed unused imports from `OperatorConcatTest` and also changed the `onStart` so that it only requests as many inner observables as it needs. Do you think this is ok?\n"},{"date":"2015-05-27T09:26:03Z","author":"davidmoten","text":"I'd love to see `just` support backpressure though I assume we will take a biggish performance hit if we do.\n"},{"date":"2015-05-27T09:31:27Z","author":"akarnokd","text":"I think requesting 2 was no accident: while working on the current, the next can be 'created' asynchronously. Otherwise, once the current is processed, you need to wait more for the next Observable source to arrive.\n"},{"date":"2015-05-27T09:51:14Z","author":"davidmoten","text":"The only catch is that by requesting 2 we make the assumption that creating this spare in advance doesn't require significant resources. If an unsubscribe occurs while the first inner is emitting then the act of creating the second is wasted (and may have been demanding).\n"},{"date":"2015-05-27T09:59:41Z","author":"davidmoten","text":"There's a compromise either way for sure. Perhaps we could request 2 inners if `Long.MAX_VALUE` is requested and otherwise 1.\n"},{"date":"2015-05-27T10:29:08Z","author":"akarnokd","text":"I'd say, let's have it 2 on default and have another PR which offers an overload to `concat()` and `concatMap()` where the 'prefetch' amount can be specified.\n"},{"date":"2015-05-27T10:49:58Z","author":"davidmoten","text":"Sounds good. We can discuss further in another PR.\n"},{"date":"2015-05-27T11:40:59Z","author":"akarnokd","text":"Looks okay to me now. Thanks!\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-05-27T11:41:02Z","description":"If a request arrives while `ConcatInnerSubscriber` is being constructed ([L199-201](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/bad4d40a7b59cb443c3cb19d00ab80000e017a5f\/src\/main\/java\/rx\/internal\/operators\/OperatorConcat.java#L199-L201)) then that additional request does not induce a request from the subscriber and could stall the stream. The fix is not to pass `requested` value in the constructor but to call `ConcatInnerSubscriber.requestMore` with `requested` only once `currentSubscriber` is set.\n","id":"77868652","title":"fix OperatorConcat race condition where request lost","opened_on":"2015-05-19T00:34:58Z","closed_by":"akarnokd"},{"number":"2943","reopenOn":null,"comments":[{"date":"2015-05-14T20:50:41Z","author":"psliwowski","text":"Confirmed this causes a busy loop and spikes cpu to 100% because of ObjectPool.\n"},{"date":"2015-05-14T20:59:03Z","author":"akarnokd","text":"I guess it is due to the way the next delay is calculated from a constant absolute time position and a time set back will result in 0 delay between subsequent executions. Any tips on fixing it?\n"},{"date":"2015-05-14T23:15:52Z","author":"zsxwing","text":"If we want to measure elapsed time, we should use `System.nanoTime`, which won't be affected by the user's system time. https:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/System.html#nanoTime()\n"},{"date":"2015-05-15T06:33:14Z","author":"akarnokd","text":"I wouldn't trust [nanoTime that much](http:\/\/shipilev.net\/blog\/2014\/nanotrusting-nanotime\/) because the weaker guarantees of its monotonity and consistency across cores.\n"},{"date":"2015-05-15T06:41:50Z","author":"headinthebox","text":"This is not an easy thing ;-) http:\/\/blogs.msdn.com\/b\/rxteam\/archive\/2012\/06\/20\/reactive-extensions-v2-0-release-candidate-available-now.aspx\n"},{"date":"2015-05-15T08:37:58Z","author":"akarnokd","text":"@headinthebox  Especially if you _are_ platform independent to begin with (i.e., what is the Linux equivalent of `SERVICE_CONTROL_TIMECHANGE` callback?)\n\nWhat the solution boils down:\n1. We need a supervising task scheduled on a small, 5-10s period to detect System.currentTimeMillis() drift or change (i.e., now - last is: > 5s + tolerance \/ negative).\n2. We need to capture tasks scheduled on any Scheduler that sets a delay\/period > 10s and schedule them according to Zeno's paradox.\n3. If the supervising task detects a drastic clock change, it has to catch all those long-delay tasks and re-schedule them based on the new absolute time information, of course, atomically to prevent double-executions.\n\nThese all add some non-trivial overhead to scheduling and task-memory-sizes.\n\nMy first thought was the same as in the article:\n\n> Observable.Timer\/Interval implementation would start its quest to catch up with the new time, draining the battery due to the flood of callbacks it triggered. The fix was more of a band aid, whereby the timer would ignore ticks that occurred in the distant past, resetting the \u201Cnext\u201D state to be based on the current system time.\n\nBut that's still a half-solution at best.\n"},{"date":"2015-05-15T08:44:57Z","author":"psliwowski","text":"Using nanoTime was my temporary solution as well. It is not the best, but the quickest way to fix this bug and doesn't offer anything worst then the current solution.\n"},{"date":"2015-05-15T16:42:29Z","author":"artem-zinnatullin","text":"Some systems like Android give a way to measure time and don't care about system time changes. http:\/\/developer.android.com\/reference\/android\/os\/SystemClock.html\n\nWhat do you think about abstraction for `System.currentTimeMillis()` which can be overridden via [RxJava Plugin](https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Plugins)?\n\nDefault: `System.currentTimeMillis()` -> no breaking changes to the API.\nAndroid: `SystemClock.elapsedRealtime()` -> no breaking changes and guarantees++ for free.\nOthers: users can provide custom implementation, for example for Linux it can be native C call, or in general it can be some implementation of synchronized calls to `System.nanoTime()`.\n"},{"date":"2015-09-03T08:05:40Z","author":"akarnokd","text":"I've implemented compensation logic in [2.x](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/2.x\/src\/main\/java\/io\/reactivex\/Scheduler.java#L128) but I haven't tested it and unsure if the calculation is actually correct.\n"},{"date":"2015-10-22T13:38:35Z","author":"akarnokd","text":"I've proposed a fix for this issue in #3467. I don't know if and when this can get into a release.\n"},{"date":"2016-02-09T13:14:09Z","author":"akarnokd","text":"Fix delivered in 1.1.0.\n"}],"opened_by":"psliwowski","reopen":false,"closed_on":"2016-02-09T13:14:09Z","description":"Scheduler.schedulePeriodically can potentially get into busy loop if you set your system time into the future due to using System.currentTimeMillis() to calculate the next delay.\n","id":"75826185","title":"Scheduler.schedulePeriodically is sensitive to system time changes","opened_on":"2015-05-13T03:22:12Z","closed_by":"akarnokd"},{"number":"2939","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-05-08T21:14:30Z","description":"Yet another fix to the race condition in publish().\n","id":"74329558","title":"publish: Fix another race between terminalEvent and the queue being empty.","opened_on":"2015-05-08T11:23:40Z","closed_by":"akarnokd"},{"number":"2936","reopenOn":null,"comments":[{"date":"2015-05-06T12:19:20Z","author":"akarnokd","text":"The same error is present on `onError()` and `onCompleted()`. Could you fix those as well?\n"},{"date":"2015-05-06T13:02:55Z","author":"jacek-marchwicki","text":"@akarnokd  Yep... hold a second\n"},{"date":"2015-05-07T06:53:44Z","author":"akarnokd","text":"Looks good. Thanks!\n"}],"opened_by":"jacek-marchwicki","reopen":false,"closed_on":"2015-05-07T06:53:48Z","description":"## Info\n\nProblem is in TestSubject.onNext()\nwhen is called on current time that is not 0 it will be delayed by current time.\ncalling TestSubject.onNext() should execute immediately.\n## Tests\n- TestSubjectTest.testObserverPropagateValueAfterTriggeringActions - represent already working behavior\n- TestSubjectTest.testObserverPropagateValueInFutureTimeAfterTriggeringActions - represent a bug that is fixed by this commit\n","id":"73597162","title":"Fix TestSubject bug","opened_on":"2015-05-06T12:07:22Z","closed_by":"akarnokd"},{"number":"2934","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-05-06T06:35:22Z","description":"Fixes the cause of #2933.\n","id":"73530033","title":"Fix termination race condition in OperatorPublish.dispatch","opened_on":"2015-05-06T06:27:10Z","closed_by":"akarnokd"},{"number":"2930","reopenOn":null,"comments":[{"date":"2015-05-05T11:29:20Z","author":"davidmoten","text":"Awesome, for once I'm happy to see a CI failure! Tilll now #2863  hasn't been repeatable except on my laptop but now has reappeared in the Travis build.\n"},{"date":"2015-05-05T11:56:33Z","author":"akarnokd","text":"If I put in this, I get the missing emission problem:\n\n``` java\nlong cc = consumerCapacity.get();\nif (cc < Long.MAX_VALUE) {\n    consumerCapacity.compareAndSet(cc, cc - 1);\n}\n\nif (rnd.nextDouble() < 0.25) {\n    try {\n        Thread.sleep(1);\n    } catch (InterruptedException ex) {\n        ex.printStackTrace();\n    }\n}\n\nchild.onNext(v);\n```\n\nIf I swap the operations, the test passes for me again.\n\nCould you also update the helper method in the test?\n\n``` java\nstatic <T> StringBuilder sequenceFrequency(Iterable<T> it) {\n        StringBuilder sb = new StringBuilder();\n\n        Object prev = null;\n        int cnt = 0;\n\n        for (Object curr : it) {\n            if (sb.length() > 0) {\n                if (!curr.equals(prev)) {\n                    if (cnt > 1) {\n                        sb.append(\" x \").append(cnt);\n                        cnt = 1;\n                    }\n                    sb.append(\", \");\n                    sb.append(curr);\n                } else {\n                    cnt++;\n                }\n            } else {\n                sb.append(curr);\n                cnt++;\n            }\n            prev = curr;\n        }\n        if (cnt > 1) {\n            sb.append(\" x \").append(cnt);\n        }\n\n        return sb;\n    }\n```\n"},{"date":"2015-05-05T12:05:05Z","author":"davidmoten","text":"@akarnokd while you were putting your last comment up I synchronized the reads and writes of consumerCapacity as in the attached commit and the failures have stopped. Doesn't explain it yet but seems like consumerCapacity is important to this.\n\nI'll add your changes and revert the synchronization once you've had a quick look.\n"},{"date":"2015-05-05T12:17:58Z","author":"davidmoten","text":"I thought as much given our previous conversations and figured that if this is the solution you'd have suggestions for doing it properly. Anyway probably need to figure out the why still I suppose.\n"},{"date":"2015-05-05T12:48:25Z","author":"davidmoten","text":"I'm confused by this `resumeBoundary` business, I hope you fare better, off to bed for me.\n"},{"date":"2015-05-05T12:58:57Z","author":"davidmoten","text":"I've committed the CAS loop. We can drop it as an optimization later based on perfs if we want or of course now if you think\n"},{"date":"2015-05-05T13:03:20Z","author":"akarnokd","text":"Can you devise a benchmark that checks the throughput on a non-throwing source?\n\nIf I remember correctly, the resumeBoundary is there because an exception can happen just after the capacity reached zero but we don't immediately resubscribe until an actual request comes in.\n"},{"date":"2015-05-06T03:04:39Z","author":"davidmoten","text":"I've added some more comments to the code as my understanding improves. I also have marked three places with \/\/TODO, two of which I think are potential race conditions and the third is just a marker for some of the usual optimizations done in the `request`. \n\nAnother addition in the last commit is a check to ensure that the `consumerCapacity` decrement doesn't go below zero which now provokes a `MissingBackpressureException`.\n\nI'm sure @akarnokd will have the red pen out on this stuff then if any of the race conditions stand scrutiny I'll fix them.\n"},{"date":"2015-05-06T05:39:07Z","author":"davidmoten","text":"unrelated test failure `OperatorPublishTest.testObserveOn`. I've raised #2933.\n"},{"date":"2015-05-06T06:19:41Z","author":"davidmoten","text":"I've ruled out one race condition (and left comments explaining why all is ok)\n"},{"date":"2015-05-06T06:35:09Z","author":"akarnokd","text":"I'd say if the change makes your test failure go away, that should be enough for now. I'd defer the full rewrite to 2.0.\n"},{"date":"2015-05-06T06:57:21Z","author":"davidmoten","text":"Righto, I'll concentrate on the fix for the #2863 test failure.  Part of that is probably ruling out surprises like decrementing `consumerCapacity` when it is already 0. My approach in that was to throw a `MissingBackpressureException` because in backpressure mode an operator should not emit more than requested. I would be concerned that this might appear as a breaking change to some though because previously it happily passed them through (with who knows what consequences in the operator). A compromise might be to not decrement when 0 but also not emit an error and then revisit this part of the contract in 2.0. Which way do you think we should go?\n"},{"date":"2015-05-06T06:59:39Z","author":"davidmoten","text":"Hmm I just realized that if not emitting MissingBackpressureException then I should decrement otherwise the accounting is stuffed when more requests come through. I'll avoid the MissingBackpressureException for now but it should probably be part of some future milestone (2.0?).\n"},{"date":"2015-05-06T10:46:16Z","author":"davidmoten","text":"Sorry to say, no progress made. I've protected all reads and writes to `currentProducer` and `consumerCapacity` by a single guard object (without holding a lock on emission or on request or on `worker.schedule` which could be run synchronously using `Schedulers.immediate()` or `Schedulers.trampoline()`) and still get the `OperatorRetryTest.testRetryWithBackpressureParallel` failure on my laptop. I give up for the moment. I'm leaning towards there being something fundamentally wrong that will probably only be fixed by a rewrite.\n"},{"date":"2015-05-07T03:36:38Z","author":"davidmoten","text":"I've pared this PR right down (after the unsuccessful hunt for the cause of #2863) so that it addresses just the race conditions that I can see and can confirm.\n\nThe changes are:\n- The original code to decrement `consumerCapacity` had a race condition, now we use a CAS loop to update\n- the `c == 0` check at [L342](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/0a6e26de73c3707dbd9903c166b7be0f6499b6b7\/src\/main\/java\/rx\/internal\/operators\/OnSubscribeRedo.java#L342) can cause a stall in the stream because if `request` gets called just before [L320](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/0a6e26de73c3707dbd9903c166b7be0f6499b6b7\/src\/main\/java\/rx\/internal\/operators\/OnSubscribeRedo.java#L320) then no restart will occur in that call and it is possible that no further calls to request will be made after L320 has been performed (a common pattern is a request followed by another request only once emissions have occurred).\n- update `sequenceFrequency` helper method in the test as per @akarnokd  request\n\n#2863 is NOT fixed by these changes.\n"},{"date":"2015-05-07T06:51:06Z","author":"akarnokd","text":"I applied some random sleep around the resumeBoundary and these changes worked for me (on top of your changes):\nIn the method with the locked check:\n\n``` java\nif (!isLocked.get() && !child.isUnsubscribed()) {\n    if (consumerCapacity.get() > 0) {\n        worker.schedule(subscribeToSource);\n    }\n}\n```\n\nand in the child's producer:\n\n``` java\nlong c = BackpressureUtils.getAndAddRequest(consumerCapacity, n);\nProducer producer = currentProducer.get();\nif (producer != null) {\n    producer.request(n);\n} else\nif (c == 0) {\n    worker.schedule(subscribeToSource);\n}\n```\n\nSo if there is capacity available, the source will be restarted. If there is no capacity remaining, the first 0 -> n transition will restart the source.\n"},{"date":"2015-05-07T06:58:52Z","author":"davidmoten","text":"I'll try it out, thanks! I'll also include a `n>0` check in the producer so that calls of request(0) are no-ops.\n"},{"date":"2015-05-07T07:12:51Z","author":"davidmoten","text":"Nice simplification. Still getting `testRetryWithBackpressureParallel` failure on my laptop (first time).\n"},{"date":"2015-05-07T07:19:21Z","author":"davidmoten","text":"3 out of 3 failures on laptop, 1 out of 25 failures on fast desktop running all tests in `OperatorRetryTest`. I just run this in a loop:\n\n`.\/gradlew -q   -Dtest.single=OperatorRetry cleanTest test`\n"},{"date":"2015-05-07T07:46:18Z","author":"akarnokd","text":"Apparently, the `resumeBoundary` served to prevent unwanted resubscription.\nOne final try:\nwrap the above places into `synchronized (consumerCapacity)` plus the contents of `terminalDelegatingSubscriber.setProducer` and see if it still fails. If not, start moving out operations from this synchronized block and see which one triggers the failure.\n\nEdit: forgot to mention: readd resumeBoundary as well.\n"},{"date":"2015-05-07T10:28:11Z","author":"davidmoten","text":"This is as far as I got. No failures when everything in the synch blocks.  Then started moving out the baddies for synchronization being calls to `producer.request` and `worker.schedule` (because could be a synchronous worker). Everything ok till I pulled `worker.schedule` out of `onNext` synch block. \n\n``` java\n                    @Override\n                    public void onNext(Object t) {\n                        if (!isLocked.get() && !child.isUnsubscribed()) {\n                            final boolean scheduleNow;\n                            synchronized (consumerCapacity) {\n                                if (consumerCapacity.get() > 0) {\n                                    scheduleNow = true;\n                                } else {\n                                    scheduleNow = false;\n                                    resumeBoundary.compareAndSet(false, true);\n                                }\n                            }\n                            if (scheduleNow)\n                                worker.schedule(subscribeToSource);\n                        }\n                    }\n\n                    @Override\n                    public void setProducer(Producer producer) {\n                        producer.request(Long.MAX_VALUE);\n                    }\n                });\n            }\n        });\n\n        child.setProducer(new Producer() {\n\n            @Override\n            public void request(final long n) {\n                final Producer producer;\n                final boolean requestNow;\n                final boolean scheduleNow;\n                synchronized (consumerCapacity) {\n                    BackpressureUtils.getAndAddRequest(consumerCapacity, n);\n                    producer = currentProducer.get();\n                    if (producer != null) {\n                        requestNow = true;\n                        scheduleNow = false;\n                    } else {\n                        requestNow = false;\n                        scheduleNow = resumeBoundary.compareAndSet(true, false);\n                    }\n                }\n                if (requestNow)\n                    producer.request(n);\n                else if (scheduleNow)\n                    worker.schedule(subscribeToSource);\n            }\n        })\n```\n"},{"date":"2015-05-07T11:28:13Z","author":"akarnokd","text":"When the test fails, how many elements are missing from the output. Does it print beginningEveryTime x 256 ?\n"},{"date":"2015-05-07T12:30:58Z","author":"davidmoten","text":"Yep:\n\n`java.lang.AssertionError: Data content mismatch: 2315={beginningEveryTime x 256}\n        at org.junit.Assert.fail(Assert.java:93)\n        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:763)\n`\n"},{"date":"2015-05-07T12:41:48Z","author":"akarnokd","text":"I'm rewriting just the retry(n) variant and see if there is a general logical error with request accounting or just the OnSubscribeRedo has problems.\n"},{"date":"2015-05-07T13:49:12Z","author":"akarnokd","text":"[Here is a retry implementation](https:\/\/gist.github.com\/akarnokd\/3b110055414a44d320b9) that serializes out the changing of producers and accounting the capacity. Could you try this implementation?\n(Dont forget to change both factory methods in OnSubscribeRedo:\n\n``` java\n    public static <T> Observable<T> retry(Observable<T> source) {\n\/\/        return retry(source, REDO_INIFINITE);\n        return retry(source, Long.MAX_VALUE);\n    }\n\n    public static <T> Observable<T> retry(Observable<T> source, final long count) {\n        if (count < 0)\n            throw new IllegalArgumentException(\"count >= 0 expected\");\n        if (count == 0)\n            return source;\n\/\/        return retry(source, new RedoFinite(count));\n        return create(new OnSubscribeRetry<T>(source, count));\n    }\n```\n\n**Edit:**\n[Here is an alternative](https:\/\/gist.github.com\/akarnokd\/5cb99c6062cea0b23d8b) which doesn't use List as the work queue but instead accounts the changes separately and is a bit faster.\n"},{"date":"2015-05-07T21:05:37Z","author":"davidmoten","text":"Cool, thanks. Got this exception:\n\n```\nrx.internal.operators.OperatorRetryWithPredicateTest > testJustAndRetry FAILED\n    java.util.NoSuchElementException: Sequence contains no elements\n        at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:131)\n        at rx.internal.operators.OnSubscribeRetry$1$1.onCompleted(OnSubscribeRetry.java:66)\n        at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:44)\n        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:44)\n        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:32)\n        at rx.Observable$1.call(Observable.java:144)\n        at rx.Observable$1.call(Observable.java:136)\n        at rx.Observable.unsafeSubscribe(Observable.java:7507)\n        at rx.internal.operators.OnSubscribeRetry$1.call(OnSubscribeRetry.java:75)\n        at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.enqueue(TrampolineScheduler.java:80)\n        at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.schedule(TrampolineScheduler.java:59)\n        at rx.internal.operators.OnSubscribeRetry.call(OnSubscribeRetry.java:86)\n        at rx.internal.operators.OnSubscribeRetry.call(OnSubscribeRetry.java:28)\n        at rx.Observable$1.call(Observable.java:144)\n        at rx.Observable$1.call(Observable.java:136)\n        at rx.Observable.subscribe(Observable.java:7597)\n        at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:442)\n        at rx.observables.BlockingObservable.single(BlockingObservable.java:341)\n        at rx.internal.operators.OperatorRetryWithPredicateTest.testJustAndRetry(OperatorRetryWithPredicateTest.java:296)\n```\n"},{"date":"2015-05-07T21:22:27Z","author":"akarnokd","text":"I went a bit light on the safeguards in OnSubscribeRetry (i.e., not bouncing back any exceptions thrown when calling currentProducer.request()). How does the code work with testRetryWithBackpressureParallel?\n"},{"date":"2015-05-07T21:41:26Z","author":"akarnokd","text":"I've [updated the gist](https:\/\/gist.github.com\/akarnokd\/5cb99c6062cea0b23d8b) so it passes the unit tests.\n"},{"date":"2015-05-07T21:45:40Z","author":"davidmoten","text":"Good so far. I'll stick the test in a loop for ten minutes or so on the laptop.\n"},{"date":"2015-05-07T22:35:11Z","author":"davidmoten","text":"3rd time through:\n\n```\nrx.internal.operators.OperatorRetryTest > testRetryWithBackpressureParallel FAILED\n    java.lang.AssertionError: Data content mismatch: 3628={beginningEveryTime x 256}\n        at org.junit.Assert.fail(Assert.java:93)\n        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:763)\n```\n"},{"date":"2015-05-08T02:13:20Z","author":"davidmoten","text":"For your info I tried using `SynchronizedQueue` instead of `SpscArrayQueue` in `OperatorObserveOn` and got the failure on 30th run on fast desktop (so I'm glad to rule out `SpscArrayQueue` as being the cause):\n\n```\njava.lang.AssertionError: Data content mismatch: 1940={beginningEveryTime x 254}\n    at org.junit.Assert.fail(Assert.java:93)\n    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:763)\n```\n"},{"date":"2015-05-08T06:15:39Z","author":"akarnokd","text":"There is a race in observeOn in main being fixed by #2929 that might attribute to lost onNexts but can't be sure from the AssertionError.\nThe simple fix for observeOn is to replace\n\n``` java\nObject o = queue.poll();\nif (o == null) {\n    if (completed) {\n```\n\nwith\n\n``` java\nboolean c = completed;\nObject o = queue.poll();\nif (o == null) {\n    if (c) {\n```\n\nThis updated test method should print out any additional onCompleted events if they are there:\n\n``` java\n@Test\/\/(timeout = 15000)\npublic void testRetryWithBackpressureParallel() throws InterruptedException {\n    final int NUM_RETRIES = RxRingBuffer.SIZE * 2;\n    int ncpu = Runtime.getRuntime().availableProcessors();\n    ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu \/ 2, 2));\n    try {\n        for (int r = 0; r < 1000; r++) {\n            if (r % 10 == 0) {\n                System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n            }\n\n            final AtomicInteger timeouts = new AtomicInteger();\n            final Map<Integer, List<String>> data = new ConcurrentHashMap<Integer, List<String>>();\n\n            int m = 5000;\n            final CountDownLatch cdl = new CountDownLatch(m);\n            for (int i = 0; i < m; i++) {\n                final int j = i;\n                exec.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        final AtomicInteger nexts = new AtomicInteger();\n                        try {\n                            Observable<String> origin = Observable.create(new FuncWithErrors(NUM_RETRIES));\n                            TestSubscriber<String> ts = new TestSubscriber<String>();\n                            origin.retry()\n                            .observeOn(Schedulers.computation()).unsafeSubscribe(ts);\n                            ts.awaitTerminalEvent(2500, TimeUnit.MILLISECONDS);\n\n                            List<String> onNextEvents = new ArrayList<String>(ts.getOnNextEvents());\n                            List<Throwable> onErrorEvents = new ArrayList<Throwable>(ts.getOnErrorEvents());\n                            List<Notification<String>> onCompletedEvents = new ArrayList<Notification<String>>(ts.getOnCompletedEvents());\n\n                            if (onNextEvents.size() != NUM_RETRIES + 2\n                                    || !onErrorEvents.isEmpty() || onCompletedEvents.isEmpty()) {\n                                for (Throwable t : onErrorEvents) {\n                                    onNextEvents.add(t.toString());\n                                }\n                                for (Object o : onCompletedEvents) {\n                                    onNextEvents.add(\"onCompleted\");\n                                }\n                                data.put(j, onNextEvents);\n                            }\n                        } catch (Throwable t) {\n                            timeouts.incrementAndGet();\n                            System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                        }\n                        cdl.countDown();\n                    }\n                });\n            }\n            cdl.await();\n            assertEquals(0, timeouts.get());\n            if (data.size() > 0) {\n                fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n            }\n        }\n    } finally {\n        exec.shutdown();\n    }\n}\n```\n"},{"date":"2015-05-08T07:30:27Z","author":"davidmoten","text":"I've added the suggested changes to this commit but should have mentioned that I tried the fixes from #2929 with your OperatorRetry and had no effect (still get failures).\n"},{"date":"2015-05-08T07:54:12Z","author":"akarnokd","text":"What does the failure report as the received events? Could you also check whether replacing the TrampolineScheduler with io scheduler still exhibits the failure?\n"},{"date":"2015-05-08T10:20:12Z","author":"davidmoten","text":"29th run on desktop:\n\n```\njava.lang.AssertionError: Data content mismatch: 1828={beginningEveryTime x 109}\n    at org.junit.Assert.fail(Assert.java:93)\n    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:759)\n```\n"},{"date":"2015-05-08T10:24:59Z","author":"akarnokd","text":"I'm running the test on a virtualized ubuntu without CPU virtualization support to emulate a slow machine but it is working so far. What are the specs of your machine which fails the test so often?\n"},{"date":"2015-05-08T10:30:05Z","author":"davidmoten","text":"My laptop is Ubuntu 12.04 64-bit i5-430m 1.2GHz java 1.8u45 but the wind has changed this evening and is not failing that test. My desktop Ubuntu 14.04 64-bit Intel® Core™ i7 CPU 920 @ 2.67GHz × 8, java 1.8u40  is where it's failing at the moment and my best bet for failure is running the whole OperatorRetryTest suite using gradle command mentioned previously.\n"},{"date":"2015-05-08T11:12:29Z","author":"davidmoten","text":"The quick fix for observeOn that you mention above still has the race condition that #2929 was reported on so I might paste in #2929 version of OperatorObserveOn and continue testing with that.\n"},{"date":"2015-05-08T11:18:01Z","author":"davidmoten","text":"Might #2907 have any bearing on this?\n"},{"date":"2015-05-08T11:32:26Z","author":"akarnokd","text":"No, because it is a completely separate scheduler.\n\nI'm running the test on some real debian linux and I the test fails within the first run:\n\n```\n4882={}, 4871={}, 4860={}, 4838={beginningEveryTime x 51}, 4849={}\n```\n"},{"date":"2015-05-08T11:40:14Z","author":"davidmoten","text":"David I don't understand the quick fix in OperatorObserveOn you mentioned above. Is that something new to be added to #2929?  Can you explain it if so?\n"},{"date":"2015-05-08T11:49:03Z","author":"akarnokd","text":"Never mind, I didn't notice the queue.isEmpty() check after it.\n"},{"date":"2015-05-08T12:12:24Z","author":"akarnokd","text":"I've put in doOnNext() between the operators. In case of a test failure, the emission count after the source and retry() match but are less after observeOn() which makes me think observeOn doesn't pick up the values emitted (and it doesn't request for replacements either).\n"},{"date":"2015-05-08T13:27:15Z","author":"davidmoten","text":"The latest commit including #2929 doesn't fail for me on three different machines including the old laptop. 200 runs on i7, 100 runs on laptop and 200 runs on another i7. Did you use the last commit for the failures on the debian machine?\n"},{"date":"2015-05-08T13:48:49Z","author":"akarnokd","text":"With #2929 the test fails after 15 runs:\n\nData: \n- 4875={Loops:128, Request:0, B\/A:[128, 128, 0, 637676, 0]}, 4842={Loops:128, Request:0, B\/A:[128, 128, 0, 664205, 0]}, \n- 4831={beginningEveryTime x 139, Loops:258, Request:10, B\/A:[258, 258, 139, 2491693, 1720371]}, \n- 4853={Loops:128, Request:0, B\/A:[128, 128, 0, 670982, 0]}, 4864={Loops:128, Request:0, B\/A:[128, 128, 0, 664584, 0]}\n\nWhere B\/A means [after source count, after retry count, after observeOn count, latest emission after retry in nanoseconds, latest emission after observeOn in nanoseconds]. Both time values are relative to when the entire stream started.\n\nI've completely rewritten the emission loop in observeOn but the test still fails on my linux machine. \n"},{"date":"2015-05-08T14:28:58Z","author":"akarnokd","text":"I've increased the timeout and added `timeInterval` to the source data and it seems there is a large, seconds-scale hiccup in the stream. Since I'm using SSH, I can't use flight recorder or jvisualvm to see how the threads behave.\n"},{"date":"2015-05-08T21:06:56Z","author":"davidmoten","text":"I've lost the ability to induce failures. Tests ran all night without inducing failure. I might try reverting to an earlier version of the test method.\n"},{"date":"2015-05-09T01:13:19Z","author":"davidmoten","text":"May as well give the latest commit from here a spin again @akarnokd now that it incorporates the request overflow fix from #2929 I just added. I still can't induce failure so the baton is passed to you!\n"},{"date":"2015-05-09T08:23:35Z","author":"akarnokd","text":"So the observeOn changes + my ProducerArbiter works. Great! Now it would be better to remove OnSubscribeRetry and apply its logic on OnSubscribeRedo directly.\n"},{"date":"2015-05-09T09:21:02Z","author":"davidmoten","text":"Super news.  So you mean you'll rewrite Redo now? One thing I was worried\nabout with the original is the possibility of requests getting missed and\nthe new one accounts for that.\n\nOn Sat, 9 May 2015 18:23 David Karnok notifications@github.com wrote:\n\n> So the observeOn changes + my ProducerArbiter works. Great. Now it would\n> be better to remove OnSubscribeRetry and apply its logic on OnSubscribeRedo\n> directly.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2930#issuecomment-100447523.\n"},{"date":"2015-05-09T09:33:23Z","author":"akarnokd","text":"I meant you apply the ProducerArbiter and the calls to OnSubscribeRedo.\n"},{"date":"2015-05-09T09:49:13Z","author":"davidmoten","text":"No worries, can do\n\nOn Sat, 9 May 2015 19:33 David Karnok notifications@github.com wrote:\n\n> I meant you apply the ProducerArbiter and the calls to OnSubscribeRedo.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2930#issuecomment-100455254.\n"},{"date":"2015-05-10T11:25:12Z","author":"davidmoten","text":"Hmm not quite out of the woods. I've adjusted the code to use `ProducerArbiter` (please look it over) but saw our old friend on  the first run on my i7 desktop which also seemed to lock the machine up for me for a minute. Subsequent runs did not fail (150 runs). The latest commit includes the latest version of `OperatorObserveOn` from #2929.\n\n```\njava.lang.AssertionError: Data content mismatch: 1763={beginningEveryTime x 128, onCompleted}, 1767={beginningEveryTime x 21, onCompleted}, 1756={beginningEveryTime x 10, onCompleted}\n    at org.junit.Assert.fail(Assert.java:93)\n    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:759)\n```\n"},{"date":"2015-05-10T11:30:59Z","author":"davidmoten","text":"I forgot to mention that the last failure also included a timeout failure of `OperatorRetryTest. testIssue1900`. \n"},{"date":"2015-05-10T13:09:10Z","author":"akarnokd","text":"Can you monitor the test with JVisualVM and see if there are thread stalls or excess GC?\n"},{"date":"2015-05-10T19:51:26Z","author":"davidmoten","text":"Yeah I'll try that. 28th run on laptop gave \n\n```\nrx.internal.operators.OperatorRetryTest > testRetryWithBackpressureParallel FAILED\n    java.lang.AssertionError: Data content mismatch: 3724={onCompleted}, 3720={beginningEveryTime x 17, onCompleted}\n        at org.junit.Assert.fail(Assert.java:93)\n        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:759)\n```\n"},{"date":"2015-05-11T03:59:28Z","author":"davidmoten","text":"I can see another race condition in `OnSubscribeRedo`. `restarts` must be subscribed to before the first request subscribes to source. I don't think it affects our current test because the `worker` is synchronous but if it was async we would be exposed to it. To fix this in a non-blocking way would require `terminals` to be a slightly different beast than a `PublishSubject` in that it would buffer events till the first subscriber (there should be only one subscriber for `terminals` though the `notificationHandler` could do something weird in theory) and then play all the buffered events to the subscriber. `ReplaySubject` might help out here but I'm not sure what idiom we could use yet. A custom `Subject` would probably be straightforward to build but I'd like to see what ideas you have @akarnokd.\n\nI tried a blocking fix for this using a latch just to play with it but as expected still get our normal failure.\n\nIncidentally I can't seem to break `testRetryWithBackpressureParallel` but just looping it in Eclipse. It only fails looping the gradle command line call. This makes monitoring difficult but I could enable gc logging I suppose.\n"},{"date":"2015-05-11T10:02:24Z","author":"davidmoten","text":"I think I have addressed the race condition mentioned in the previous comment. By using a `BehaviorSubject` instead of a `PublishSubject` and subscribing with a dummy subscriber immediately after creating then an emission between subscribing to source and subscribing to `restarts` will be replayed on subscribe to `restarts` so it is not lost.\n"},{"date":"2015-05-11T20:39:52Z","author":"davidmoten","text":"Failed on run 111 on desktop i7:\n\n```\njava.lang.AssertionError: Data content mismatch: 237={beginningEveryTime x 128}\n    at org.junit.Assert.fail(Assert.java:93)\n    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:759)\n```\n"},{"date":"2015-05-12T00:37:16Z","author":"davidmoten","text":"The race condition I thought had found was what `isLocked` was to prevent. I'm not sure that ignoring a restart instruction because `isLocked` is true is the way to go so I'm going to remove the `isLocked` checks and retest using only the `BehaviorSubject` logic.\n"},{"date":"2015-05-12T03:00:43Z","author":"davidmoten","text":"Three hours without failure on three machines (i7,i7 and i5 laptop). Can you try this commit @akarnokd?\n"},{"date":"2015-05-12T06:24:35Z","author":"davidmoten","text":"Took 5 hours but got failure on laptop only:\n\n```\njava.lang.AssertionError: Data content mismatch: 883={beginningEveryTime x 138}\n        at org.junit.Assert.fail(Assert.java:93)\n        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRet\n```\n\nThis is going to make testing difficult!\n"},{"date":"2015-05-12T12:21:12Z","author":"davidmoten","text":"Using jacoco as per #2937 I noticed that the subscriber to `restarts` never completes so never unsubscribes (though `child` does). To achieve this  (and to simplify `OnSubscribeRedo` a little bit) I ensured that all events are routed through to `filteredTerminals` instead of just the `onNext` events.\n"},{"date":"2015-05-12T20:42:18Z","author":"davidmoten","text":"I've added the fix to `ProducerArbiter` to not reduce the request if already `Long.MAX_VALUE`. Before applying this fix I ran the test which failed on run 207 but in this test I confirmed that count upstream of  `observeOn` was same as downstream so I think the problem is not with `OperatorSubscribeOn` anymore. I'll rerun now we have a fix in `ProducerArbiter`.\n"},{"date":"2015-05-12T20:58:16Z","author":"davidmoten","text":"The fix to `ProducerArbiter` could help the failure because concurrent requests to `FuncWithErrors` one of `Long.MAX_VALUE` and one of less than `Long.MAX_VALUE` could initiate the fast path and the backpressure path simultaneously. \n"},{"date":"2015-05-12T21:44:13Z","author":"davidmoten","text":"Added more concurrency protection to `FuncWithErrors` to prevent fast path and backpressure path from running concurrently\n"},{"date":"2015-05-13T00:54:18Z","author":"davidmoten","text":"Got this 74th run on laptop:\n\n```\norg.mockito.exceptions.verification.VerificationInOrderFailure: \nVerification in order failure:\nobserver.onNext(\"beginningEveryTime\");\nWanted 257 times:\n-> at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressure(OperatorRetryTest.java:702)\nBut was 240 times:\n-> at rx.observers.TestObserver.onNext(TestObserver.java:78)\n\n    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressure(OperatorRetryTest.java:702)\n```\n"},{"date":"2015-05-13T01:12:55Z","author":"davidmoten","text":"Added another race condition fix for `FuncWithErrors` that prevents the subscriber `o` being passed more signals after a terminal signal has been sent to it.\n"},{"date":"2015-05-13T02:19:13Z","author":"davidmoten","text":"54th run on desktop:\n\n```\njava.lang.AssertionError: Data content mismatch: 2408={beginningEveryTime x 128}\n    at org.junit.Assert.fail(Assert.java:93)\n    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:764)\n```\n"},{"date":"2015-05-13T05:19:29Z","author":"davidmoten","text":"despite last commit, 22nd run on desktop:\n\n```\njava.lang.AssertionError: Data content mismatch: 4501={beginningEveryTime x 128}\n    at org.junit.Assert.fail(Assert.java:93)\n    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:768)\n```\n"},{"date":"2015-05-13T05:21:27Z","author":"akarnokd","text":"Try disabling transparent hugepages.\n"},{"date":"2015-05-13T06:36:57Z","author":"davidmoten","text":"With the purpose of making the test fail more often?\n"},{"date":"2015-05-13T06:43:24Z","author":"akarnokd","text":"In the contrary. Linux transparent hugepages (default: on) is known to introduce latency spikes, maybe so extreme our test times out just by that.\n"},{"date":"2015-05-13T06:53:42Z","author":"davidmoten","text":"The catch is that we have a low probability (for the test as it stands) race condition somewhere. If I make the test fail less often then we lose the ability to find that race condition. Which timeout are you thinking  of? The individual timeouts for the tests are commented out, are there scheduler timeouts?\n"},{"date":"2015-05-13T07:19:30Z","author":"akarnokd","text":"I think there is no race condition but your linux system gets overwhelmed by the test and it simply times out. This is why I suggested looking at JVisualVM's thread graph to detect some gaps in the execution that can be attributed to the system.\n"},{"date":"2015-05-13T10:56:29Z","author":"davidmoten","text":"Inspecting with jvisualvm is  tricky because I have only got failures to happen using the gradle command line which means jvm restarts every thirty seconds or so.  I've dug around pretty much everywhere now and may dig around a bit more in the future but perhaps we have achieved enough with this operator for it to be accepted back into the code base. The hunt certainly unearthed a few race conditions in `retry`, its tests, and in `observeOn` so was pretty useful and the original very frequent failure (for me) is now very infrequent.\n\nI can rebase the commits and remove the updates to OperatorObserveOn from this commit so that it's ready for merge once you and Ben and whoever else has reviewed it. It will be good to get the fixes in #2929 merged as well of course as otherwise there will be some test flakiness on this commit. \n\nIs that a reasonable plan or would you like to keep digging?\n"},{"date":"2015-05-14T00:47:02Z","author":"davidmoten","text":"I've rebased commits. Ready for a hopefully final review.\n"},{"date":"2015-05-15T12:48:51Z","author":"akarnokd","text":"I'm quite a bit lost; don't know what worked and what not or did the changes work on your system or not. If the test fails with the outer pool of 1 thread, which should pose the least amount of work, then my suspect is that there is something wrong with Java on Linux or with Linux itself. Perhaps this is just another case of the [recent futex bug](https:\/\/groups.google.com\/forum\/#!topic\/mechanical-sympathy\/QbmpZxp6C64).\n"},{"date":"2015-05-15T23:29:51Z","author":"davidmoten","text":"The futex stuff is interesting, I'll have a close look at that soon. One thing I'm wondering is should we break the retries when a `java.lang.Error` is signalled? At the moment I assume if one occurs it will be suppressed and may have the side effects we see.\n"},{"date":"2015-05-16T08:07:21Z","author":"davidmoten","text":"I did a little test and see that the sort of `Error`s that we care about do stop the retries, so that's not it.\n\nThe futex stuff shouldn't be an issue because it turned up in linux kernel 3.14 and I'm running 3.2.0-80 on my laptop and 3.13.0-49 on my desktop. I'll turn off transparent hugepages on my home desktop and see if the error happens.\n"},{"date":"2015-05-18T21:56:04Z","author":"davidmoten","text":"Turned off transparent hugepages and failed on 18th run of this command:\n\n```\n.\/gradlew -i -Dtest.single=OperatorRetry cleanTest test\n```\n\nThe run times are below. You'll notice that the runtime is not significantly larger for the final failing test which may rule out some types of OS behaviour being involved. \n\nI think we can rule out the futex bug because I run either Ubuntu 12.04 or 14.04:\n\n> Ubuntu 14.04\/Debian 8: have the fix for a long time [0] [1]\n> Ubuntu 12.04\/Debian 7: was never affected [3] [2]. Newer enablement stack kernels for Ubuntu has the same fix as [1].\n> [0] http:\/\/kernel.ubuntu.com\/git\/ubuntu\/linux.git\/log\/?showmsg=1&qt=grep&q=Avoid+taking+the+hb-%3Elock&h=linux-3.13.y\n> [1] http:\/\/kernel.ubuntu.com\/git\/ubuntu\/linux.git\/log\/?showmsg=1&qt=grep&q=Avoid+taking+the+hb-%3Elock&h=linux-3.16.y\n> [2] https:\/\/git.kernel.org\/cgit\/linux\/kernel\/git\/stable\/linux-stable.git\/tree\/kernel\/futex.c?h=linux-3.2.y&id=refs\/tags\/v3.2.69\n> [3] http:\/\/kernel.ubuntu.com\/git\/ubuntu\/ubuntu-precise.git\/tree\/kernel\/futex.c#n186\n\n```\nTotal time: 33.624 secs\nTotal time: 25.215 secs\nTotal time: 25.204 secs\nTotal time: 27.108 secs\nTotal time: 25.532 secs\nTotal time: 27.042 secs\nTotal time: 26.061 secs\nTotal time: 26.199 secs\nTotal time: 26.177 secs\nTotal time: 26.294 secs\nTotal time: 25.974 secs\nTotal time: 26.123 secs\nTotal time: 25.983 secs\nTotal time: 26.475 secs\nTotal time: 26.321 secs\nTotal time: 26.268 secs\nTotal time: 26.459 secs\nTotal time: 27.076 secs\n```\n\n```\nrx.internal.operators.OperatorRetryTest > testRetryWithBackpressureParallel FAILED\n    java.lang.AssertionError: Data content mismatch: 118={beginningEveryTime x 128}\n        at org.junit.Assert.fail(Assert.java:93)\n        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:768)\n```\n"},{"date":"2015-05-20T07:37:34Z","author":"akarnokd","text":"I suggest closing this PR and start with a fresh new PR and perhaps a new discussion.\n"},{"date":"2015-06-01T03:22:00Z","author":"davidmoten","text":"Continuing issue in #2997.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-06-01T03:22:00Z","description":"While searching for the cause of #2863 I bumped into this race condition (which doesn't fix #2863):\n\nIf a request is made between L238 and L239 then `consumerCapacity` may become `Long.MAX_VALUE` on arriving at L239 in which case we don't wish to decrement it. To fix, used `compareAndSet`.\n\nWhat is interesting about this fix is that in the test loop of 5000 in `OperatorRetryTest` I see many more occurrences of the failure on average (3 -> 50) presumably because the extra time to perform the  `compareAndSet` action has expanded the window for the race condition causing the failures.\n","id":"73283440","title":"OnSubscribeRedo - fix race conditions","opened_on":"2015-05-05T11:12:35Z","closed_by":"davidmoten"},{"number":"2929","reopenOn":null,"comments":[{"date":"2015-05-01T00:52:36Z","author":"davidmoten","text":"seeing as I don't use AtomicInteger methods on `status` I may as well just use a byte to store these. I'll update the PR\n"},{"date":"2015-05-01T01:07:26Z","author":"davidmoten","text":"I expect also that the lines below in `onCompleted` and `onError` methods are not required because those methods will not be run at the same time and the methods are not reentrant (I hope that's the right term):\n\n``` java\n if (error != null) {\n    return;\n }\n```\n\nI'll remove them in an update to the PR now\n"},{"date":"2015-05-01T06:10:06Z","author":"akarnokd","text":"Nice catch, but you don't need to introduce that state variable. Remove `failure` and make `error` volatile. In the `pollQueue`, if `completed` is true, read error and if it is nonnull, report it and return. Otherwise, check if queue is empty and if so, send onComplete(). I'm not sure about why there is the `requested == 0` because, I think, it will just make the loop spin until the request value reaches zero by the getAndDecrement below it.\n"},{"date":"2015-05-01T07:04:43Z","author":"davidmoten","text":"Ok I'll have a look at that. I agree that the `pollQueue` logic is weird and needs review. I wanted to leave it basically untouched to just review the race condition fix.\n"},{"date":"2015-05-01T07:51:27Z","author":"davidmoten","text":"Righto, I've run with your suggestion. I also removed the `requested == 0` check because it seems pointless. Apart from that the logic is equivalent. I'm not very keen on the second `if (finished)` block, I'd prefer it to loop around again but might be slightly more performant.\n\nBy the way I renamed `completed` to `finished` so it could carry the sense of either `onComplete` or `onError`. If that is inconsistent with naming elsewhere I can change it back.\n"},{"date":"2015-05-01T09:43:36Z","author":"akarnokd","text":"Looks good. Could you do a perf comparison?\n"},{"date":"2015-05-01T10:15:05Z","author":"davidmoten","text":"Sure\n"},{"date":"2015-05-01T10:31:22Z","author":"davidmoten","text":"Benchmarks improved a few percent in general:\n\n```\n1.x branch:\n\nBenchmark                                         (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5    70535.751    15423.954    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5    10852.111     3038.402    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       29.313        3.500    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5  8477545.925   290748.417    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   130930.008     8774.301    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      119.666        2.875    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5     9045.354     1739.331    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     5090.723      359.544    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       27.364        1.785    ops\/s\n\nobserve-on-race branch:\n\n\nBenchmark                                         (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5    73963.037    20044.651    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5    11155.981     7426.208    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       29.820        1.742    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5  9136674.653   428898.037    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   136164.981     3340.247    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      119.388        2.231    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5     8476.745     1586.126    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     5129.316      586.046    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       31.284        2.868    ops\/s\n```\n\nRan using \n\n`.\/gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*OperatorObserveOn.*'`\n"},{"date":"2015-05-01T10:38:47Z","author":"davidmoten","text":"I'll just fix a comment and I don't think `onNext` needs to check `finished`. Might rerun perfs after that change.\n"},{"date":"2015-05-01T10:46:51Z","author":"davidmoten","text":"The variability in perfs is pretty large. I'll run the full benchmarks and report back on those.\n"},{"date":"2015-05-01T11:14:13Z","author":"akarnokd","text":"i usually run observeOn perf with -r 5 .\n"},{"date":"2015-05-01T11:57:23Z","author":"davidmoten","text":"Thanks, I used \n\n```\n.\/gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 .*OperatorObserveOn.*'\n```\n\nI'd call it a draw:\n\n```\n1.x branch:\n\nBenchmark                                         (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5    79456.426    36108.380    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5    11094.927     2290.069    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       28.735        3.461    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5  8387544.528   589105.152    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   134932.398     3153.000    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      118.703       13.585    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5     8418.924      423.795    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     4879.297      213.291    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       29.267        0.362    ops\/s\n\nobserve-on-race branch:\n\nBenchmark                                         (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5    71650.362     7807.887    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5    10936.904     1868.829    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       29.325        2.208    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5  8297987.180   437741.592    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   135453.628     2471.897    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      121.683       12.504    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5     9304.443      381.064    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     4957.975     1897.498    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       27.492        0.897    ops\/s\n```\n"},{"date":"2015-05-01T12:30:32Z","author":"akarnokd","text":"I think the main cause of the fluctuation is the thread hopping of the emission of the source. If it hops to the observation thread, that is less traffic I guess. If you have time, you could modify the perf by adding subscribeOn which guarantees there is alway a thread boundary crossed.\n"},{"date":"2015-05-03T09:52:23Z","author":"davidmoten","text":"I added `subscribeOn(computation())` (did you want modified perfs or extra perfs?) to the existing `ObserveOn` perfs on 1.x and observe-on-race branches and these are the results:\n\n```\n1.x branch:\n\nBenchmark                                         (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5    39023.468    10714.207    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     5815.699      607.484    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5        8.863        0.779    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5    73664.638    15363.977    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5    28392.278     2229.074    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5       75.900        9.994    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5     9634.822     5069.338    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     5222.449     2559.225    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5        8.931        1.078    ops\/s\n\nobserve-on-race branch:\n\nBenchmark                                         (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5    35758.208     2014.403    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     5797.158      455.773    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5        9.390        0.509    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5    73051.368     5076.367    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5    20619.434     3587.966    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5       77.932        6.377    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5     9311.025      542.003    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     3754.341      271.638    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5        9.473        0.219    ops\/s\n```\n"},{"date":"2015-05-03T10:41:53Z","author":"akarnokd","text":"Extra perfs so they can be compared with the old anytime.\n"},{"date":"2015-05-04T02:12:04Z","author":"davidmoten","text":"Righto, here are the perfs including new onSubscribe ones:\n\n```\n1.x branch:\n\nBenchmark                                                                (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation                                1  thrpt         5    70251.688     8961.723    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation                             1000  thrpt         5     9280.779     8214.742    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation                          1000000  thrpt         5       28.990        3.447    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputationSubscribedOnComputation         1  thrpt         5    36056.035     2511.357    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputationSubscribedOnComputation      1000  thrpt         5     5677.334      735.949    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputationSubscribedOnComputation   1000000  thrpt         5        9.674        0.382    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate                                  1  thrpt         5  8480014.275   172973.770    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate                               1000  thrpt         5   135104.525     1579.495    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate                            1000000  thrpt         5      122.858       13.194    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediateSubscribedOnComputation           1  thrpt         5    72785.494     2701.185    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediateSubscribedOnComputation        1000  thrpt         5    19612.208     4703.085    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediateSubscribedOnComputation     1000000  thrpt         5       73.333       13.677    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread                                  1  thrpt         5     9007.205      571.124    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread                               1000  thrpt         5     5971.174      192.781    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread                            1000000  thrpt         5       31.180        1.258    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThreadSubscribedOnComputation           1  thrpt         5     9540.089      363.964    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThreadSubscribedOnComputation        1000  thrpt         5     3790.601      188.191    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThreadSubscribedOnComputation     1000000  thrpt         5       10.008        0.328    ops\/s\n\nobserve-on-race branch:\n\nBenchmark                                                                (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation                                1  thrpt         5    39214.570   158345.016    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation                             1000  thrpt         5    10669.899     1337.330    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation                          1000000  thrpt         5       29.230        1.805    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputationSubscribedOnComputation         1  thrpt         5    36179.648     6840.388    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputationSubscribedOnComputation      1000  thrpt         5     5844.341      185.774    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputationSubscribedOnComputation   1000000  thrpt         5        9.566        0.294    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate                                  1  thrpt         5  8283063.707   317079.693    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate                               1000  thrpt         5   134060.544     5573.792    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate                            1000000  thrpt         5      120.713       15.779    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediateSubscribedOnComputation           1  thrpt         5   106156.191    43942.564    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediateSubscribedOnComputation        1000  thrpt         5    27984.472     3232.294    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediateSubscribedOnComputation     1000000  thrpt         5       76.865        8.196    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread                                  1  thrpt         5     8890.780     1062.994    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread                               1000  thrpt         5     5024.608      180.168    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread                            1000000  thrpt         5       32.990        2.758    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThreadSubscribedOnComputation           1  thrpt         5     9114.271      314.387    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThreadSubscribedOnComputation        1000  thrpt         5     4271.852      977.703    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThreadSubscribedOnComputation     1000000  thrpt         5        9.647        0.831    ops\/s\n```\n"},{"date":"2015-05-04T04:23:12Z","author":"davidmoten","text":"@akarnokd I can maybe get a few percent improvement in most of the benchmarks by touching the volatile `requested` less in the loop but I'm thinking I should make a new PR out of that if we are happy with the correctness and performance of the current PR.\n\n```\nobserve-on-race branch:\n\nBenchmark                                                                (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation                                1  thrpt         5    39214.570   158345.016    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation                             1000  thrpt         5    10669.899     1337.330    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation                          1000000  thrpt         5       29.230        1.805    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputationSubscribedOnComputation         1  thrpt         5    36179.648     6840.388    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputationSubscribedOnComputation      1000  thrpt         5     5844.341      185.774    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputationSubscribedOnComputation   1000000  thrpt         5        9.566        0.294    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate                                  1  thrpt         5  8283063.707   317079.693    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate                               1000  thrpt         5   134060.544     5573.792    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate                            1000000  thrpt         5      120.713       15.779    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediateSubscribedOnComputation           1  thrpt         5   106156.191    43942.564    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediateSubscribedOnComputation        1000  thrpt         5    27984.472     3232.294    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediateSubscribedOnComputation     1000000  thrpt         5       76.865        8.196    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread                                  1  thrpt         5     8890.780     1062.994    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread                               1000  thrpt         5     5024.608      180.168    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread                            1000000  thrpt         5       32.990        2.758    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThreadSubscribedOnComputation           1  thrpt         5     9114.271      314.387    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThreadSubscribedOnComputation        1000  thrpt         5     4271.852      977.703    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThreadSubscribedOnComputation     1000000  thrpt         5        9.647        0.831    ops\/s\n\nobserve-on-race branch, touch requested less:\n\nBenchmark                                                                (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation                                1  thrpt         5    72839.461    11872.361    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation                             1000  thrpt         5    10953.971     3684.071    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputation                          1000000  thrpt         5       30.553        1.772    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputationSubscribedOnComputation         1  thrpt         5    34296.824     2049.160    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputationSubscribedOnComputation      1000  thrpt         5     6084.331      577.669    ops\/s\nr.o.OperatorObserveOnPerf.observeOnComputationSubscribedOnComputation   1000000  thrpt         5       10.296        0.272    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate                                  1  thrpt         5  8622340.209    78646.722    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate                               1000  thrpt         5   136452.092     3432.061    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediate                            1000000  thrpt         5      122.923       15.274    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediateSubscribedOnComputation           1  thrpt         5    72631.043     3254.035    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediateSubscribedOnComputation        1000  thrpt         5    27904.731     5882.644    ops\/s\nr.o.OperatorObserveOnPerf.observeOnImmediateSubscribedOnComputation     1000000  thrpt         5       79.129        7.015    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread                                  1  thrpt         5     8623.913      898.953    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread                               1000  thrpt         5     5256.389      197.299    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThread                            1000000  thrpt         5       33.302        1.333    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThreadSubscribedOnComputation           1  thrpt         5     9287.645      468.941    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThreadSubscribedOnComputation        1000  thrpt         5     3916.492      176.669    ops\/s\nr.o.OperatorObserveOnPerf.observeOnNewThreadSubscribedOnComputation     1000000  thrpt         5       10.401        0.743    ops\/s\n```\n"},{"date":"2015-05-04T06:09:55Z","author":"akarnokd","text":"Almost good and the performance is mostly okay:\n\n![image](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/7449353\/c979a514-f234-11e4-8a5b-68cb9c9661bf.png)\n"},{"date":"2015-05-04T08:14:19Z","author":"davidmoten","text":"Don't need to update the perfs because the error path not taken. Are you happy with perfs as they are or would you like to add testing of the error path?\n"},{"date":"2015-05-04T08:17:28Z","author":"akarnokd","text":"I'm happy with the perf.\n"},{"date":"2015-05-04T13:12:02Z","author":"akarnokd","text":"Looks good to me, but I'd like to invite @benjchristensen to review it as well.\n"},{"date":"2015-05-04T23:34:53Z","author":"davidmoten","text":"@akarnokd Seeing as error bypasses the queue do you think I should add `queue.clear()` just before calling `child.onError()` so that the entries in the queue can be garbage collected?\n"},{"date":"2015-05-04T23:46:55Z","author":"davidmoten","text":"In fact could clear the queue in `onError` method so that gc can happen before next scheduled `pollQueue`.\n"},{"date":"2015-05-05T06:31:26Z","author":"akarnokd","text":"That would break the queue. Instead, clear the queue on the pollQueue side before emitting onError.\n"},{"date":"2015-05-05T07:11:45Z","author":"davidmoten","text":"PR updated with clearing the queue on the pollQueue side before emitting onError.\n"},{"date":"2015-05-06T06:34:41Z","author":"benjchristensen","text":"I've got this on my list to review.\n"},{"date":"2015-05-09T01:07:08Z","author":"davidmoten","text":"One more race condition. We need to increment `requested` with care because if is Long.MAX_VALUE and gets decremented then a request for one comes in (which uses BackpressureUtils to take us back up to Long.MAX_VALUE) then the increment on request happens and overflows. Fix is to use BackpresureUtils to increment.\n"},{"date":"2015-05-09T08:18:35Z","author":"akarnokd","text":"I never understood why it does that many request updates. Here is a simpler version:\n\n``` java\nint emitted = 0;\ndo {\n    counter = 1;\n    long produced = 0;\n    long r = requested;\n    while (!child.isUnsubscribed()) {\n        Throwable error;\n        if (completed) {\n            if ((error = this.error) != null) {\n                child.onError(error);\n                return;\n            } else\n            if (queue.isEmpty()) {\n                child.onCompleted();\n                return;\n            }\n        }\n        if (r > 0) {\n            Object o = queue.poll();\n            if (o != null) {\n                child.onNext(on.getValue(o));\n                r--;\n                emitted++;\n                produced++;\n            } else {\n                break;\n            }\n        } else {\n            break;\n        }\n    }\n    if (produced > 0) {\n        REQUESTED.addAndGet(this, -produced);\n    }\n} while (COUNTER_UPDATER.decrementAndGet(this) > 0);\nif (emitted > 0) {\n    request(emitted);\n}\n```\n"},{"date":"2015-05-09T08:24:31Z","author":"Eliyana281180","text":"Pada 01\/05\/2015 8:53 AM, \"Dave Moten\" notifications@github.com menulis:\n\n> seeing as I don't use AtomicInteger methods on status I may as well just\n> use a byte to store these. I'll update the PR\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub.\n"},{"date":"2015-05-09T09:15:56Z","author":"davidmoten","text":"Nice David, I was going to do that in a later PR but now seems good!\n\nOn Sat, 9 May 2015 18:24 eliyana281180 notifications@github.com wrote:\n\n> Pada 01\/05\/2015 8:53 AM, \"Dave Moten\" notifications@github.com menulis:\n> \n> > seeing as I don't use AtomicInteger methods on status I may as well just\n> > use a byte to store these. I'll update the PR\n> > \n> > ## \n> > \n> > Reply to this email directly or view it on GitHub.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2929#issuecomment-100447547.\n"},{"date":"2015-05-09T21:52:26Z","author":"davidmoten","text":"I've updated the PR with the new `pollQueue` implementation from @akarnokd and added the `queue.clear()` before calling `child.onError()`.\n"},{"date":"2015-05-09T22:05:43Z","author":"davidmoten","text":"Rebased into 2 commits\n"},{"date":"2015-05-13T06:21:48Z","author":"davidmoten","text":"@akarnokd I was thinking of changing the last lines in the `pollQueue()` method from \n\n``` java\nif (emitted > 0)\n    request(emitted);\n```\n\nto \n\n``` java\nif (emitted > 0) {\n    request(Math.min(RxRingBuffer.SIZE - queue.size(), emitted));\n}\n```\n\nThis was just to reduce the probability of an overflow of the RingBuffer. I haven't seen it happen but it looks to me that it is possible for `emitted` to reach any value you like and we may as well be defensive about it.\n"},{"date":"2015-05-13T06:29:55Z","author":"davidmoten","text":"In `pollQueue` we should only reduce `requested` by `produced` if it is not already at `Long.MAX_VALUE`\n"},{"date":"2015-05-13T06:30:56Z","author":"akarnokd","text":"There is no need for that because the queue is bounded and you'd produce up to the capacity and request only replacements after. Even though the downstream requests more, it isn't directly translated to requests for upstream.\n\nFor example, imagine the queue is full and there are plenty requests available. Now the inner loop can drain the queue completely and exit when it becomes empty. Since the upstream honors backpressure, there won't be any new enqueueing of values during this time and you get `emitting` to equal to the queue capacity.\n"},{"date":"2015-05-13T09:49:25Z","author":"davidmoten","text":"Thanks. I forgot about the counter = 1 line!\n\nOn Wed, 13 May 2015 16:31 David Karnok notifications@github.com wrote:\n\n> There is no need for that because the queue is bounded and you'd produce\n> up to the capacity and request only replacements after. Even though the\n> downstream requests more, it isn't directly translated to requests for\n> upstream.\n> \n> For example, imagine the queue is full and there are plenty requests\n> available. Now the inner loop can drain the queue completely and exit when\n> it becomes empty. Since the upstream honors backpressure, there won't be\n> any new enqueueing of values during this time and you get emitting to\n> equal to the queue capacity.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2929#issuecomment-101530265.\n"},{"date":"2015-05-13T17:16:07Z","author":"benjchristensen","text":"> I never understood why it does that many request updates\n\nI think that's my fault. I had a version that did batching at one point but it was buggy so I got it \"working\" and left that for later optimization. It is far better if we can request in batches.\n"},{"date":"2015-05-13T17:22:31Z","author":"benjchristensen","text":"Ah, wrong `request` piece. I thought it was about batching of requests, which this still doesn't fully do.\n\nChanges look good. \n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-05-13T17:22:33Z","description":"This is a fix for a race condition in `OperatorObserveOn` where if thread A gets to L164 and thread B starts the pollQueue loop then it will act as if the stream had completed normally instead of with an error. \n\nThe effect is that a stream could appear to complete normally when in fact an error had occurred.\n\nUsing two boolean volatiles `completed` and `failed` that as a pair were not atomically updated\/read exposed us to this race condition. \n\nThe fix is to use a single volatile integer `status` to represent the  states ACTIVE, COMPLETED, ERRORED to replace `completed` and `failed`.\n","id":"72318759","title":"OperatorObserveOn onComplete can be emitted despite onError being called","opened_on":"2015-05-01T00:26:33Z","closed_by":"benjchristensen"},{"number":"2928","reopenOn":null,"comments":[{"date":"2015-04-30T20:04:39Z","author":"akarnokd","text":"I haven't benchmarked this because my current, old laptop where I wrote this PR is prone to overheating.\n"},{"date":"2015-05-01T03:13:11Z","author":"davidmoten","text":"I'm stoked you've taken this on. Merge has been a thorn in our side for a while. I've only had a cursory look so far, looks great but can you break up the `emitLoop` method, it's super long (>200 lines)?\n"},{"date":"2015-05-01T04:30:24Z","author":"davidmoten","text":"Somebody go buy this man a laptop (how about you Netflix)!\n\nOn 1 May 2015 at 06:04, David Karnok notifications@github.com wrote:\n\n> I haven't benchmarked this because my current, old laptop where I wrote\n> this PR is prone to overheating.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2928#issuecomment-97951767.\n"},{"date":"2015-05-01T06:37:23Z","author":"akarnokd","text":"I've updated this PR and added safeguard against onNext before request() and made sure the queues are released if the stream is unsubscribed before completing normally.\n"},{"date":"2015-05-01T10:15:34Z","author":"akarnokd","text":"Here is a benchmark comparison on an Intel Celeron 1005M @ 1.9GHz, Windows 7 x64, Java 8u45 (this is not the overheating laptop of mine).\n\n![mergeperf](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/7429057\/129c032c-effb-11e4-8538-c15f911f0805.png)\n\nIt seems the single-shot overhead is greater in general, but note that the baseline merge has bugs especially with scalar sources: such merges may terminate much earlier and not deliver all values.\n\n```\nBenchmark                    (size)      Master     Master err           PR     PR error\nflatMapIntPassthruAsync             1  498695,426   259249,193   412488,433   257250,017\nflatMapIntPassthruAsync        1000       628,490      325,556      826,485     1030,174\nflatMapIntPassthruAsync     1000000         0,372        0,144        0,845        0,266\nflatMapIntPassthruSync            1   2413250,773   340583,441  1380370,980   268957,879\nflatMapIntPassthruSync         1000     16731,496     5159,943    16374,699     6581,767\nflatMapIntPassthruSync      1000000        17,016        4,609       15,445        4,289\nflatMapTwoNestedSync              1   1809099,547   314275,657  1074829,348   214620,187\nflatMapTwoNestedSync           1000      8908,864     1665,210    12105,668     4147,721\nflatMapTwoNestedSync        1000000         8,553        4,492       13,661        3,763\nmerge1SyncStreamOfN               1   2073223,271   624706,196  1340920,111   321874,624\nmerge1SyncStreamOfN            1000     15583,667     5675,705    24295,187      741,011\nmerge1SyncStreamOfN         1000000        16,086        3,177       30,617       14,407\nmergeNAsyncStreamsOfN             1     53251,280     1821,052    77537,033    63762,352\nmergeNAsyncStreamsOfN          1000         6,258        2,367        7,633        4,073\nmergeNSyncStreamsOf1              1   1814390,194   250905,669  1221128,575   523755,940\nmergeNSyncStreamsOf1            100    221860,250    69297,969   149696,874    13363,647\nmergeNSyncStreamsOf1           1000     20576,165     2416,898    16998,408     2414,499\nmergeNSyncStreamsOfN              1   2076685,785   558323,104  1382133,163   931994,488\nmergeNSyncStreamsOfN           1000        16,458        3,175       28,144       15,014\nmergeTwoAsyncStreamsOfN           1     45570,075     8864,806    62306,327    23355,026\nmergeTwoAsyncStreamsOfN        1000      1086,413      260,172     3059,881      554,938\noneStreamOfNthatMergesIn1         1   1894495,101   373234,431  1430870,599   883644,992\noneStreamOfNthatMergesIn1      1000     18433,963     6341,333    18367,707    12874,644\noneStreamOfNthatMergesIn1   1000000        17,750        2,938       17,197        8,896\n```\n"},{"date":"2015-05-02T13:34:25Z","author":"akarnokd","text":"@davidmoten  Can't really do because I need to return two values: the remaining request and how many main elements to request.\n"},{"date":"2015-05-03T01:14:37Z","author":"davidmoten","text":"OK, no worries\n\nOn Sat, 2 May 2015 23:34 David Karnok notifications@github.com wrote:\n\n> @davidmoten https:\/\/github.com\/davidmoten Can't really do because I\n> need to return two values: the remaining request and how many main elements\n> to request.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2928#issuecomment-98357578.\n"},{"date":"2015-05-04T12:58:18Z","author":"akarnokd","text":"i7 4790, Windows 7 x64, Java 8u45:\n\n![image](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/7453819\/931c834a-f26d-11e4-8a94-459da997a9d2.png)\n\nI've tried my best to close the gap with size = 1 cases, but couldn't figure out why it is that slower: even if I remove the emitter loop because of the trivial case, it is still 10% slower. Perhaps someone else can spot some unnecessary operation I missed.\n"},{"date":"2015-05-05T09:07:56Z","author":"akarnokd","text":"Fixed a potential concurrency problem in `MergeProducer.request()`.\n"},{"date":"2015-05-06T06:29:32Z","author":"benjchristensen","text":"@akarnokd I've got this on my list to spend time on ... but it will take several hours to review and some non-trivial time to profile and test, including against our applications. \n\nThank you very much for pursuing this.\n\n@davidmoten You mention it's been a thorn in your side. What issues have you been having and are there test cases for them that we can use to assert this fixes them?\n"},{"date":"2015-05-07T06:04:23Z","author":"davidmoten","text":"Hi Ben, I haven't got any problems with merge at the moment but I have considered it a thorn in our side because it's such an important operator and yet the code isn't pretty (and has stuff in there now that is disabled like batching because we couldn't get it to work). It's no doubt suffered through RxJava's evolution and a nice clean fresh start from @akarnokd would be a great contribution.\n\nIn terms of prettiness, and this might be for @akarnokd to consider in his rewrite, is that there are decisions made in the merge operator about how much to request from each source (the initial and subsequent requests) that I found hard to understand and I suspect would be nice to base on research \/perfs or even make customizable. To this end I'd like to see decoupling of this sort of logic into a MergeRequestStrategy class say. I guess my aims would be \n- to be able to customize the requesting behaviour  of the merge operator under backpressure for my use cases to increase performance\n- to optimise the RxJava default request behaviour for the most common use cases (I guess we'd take a wild stab at what they are)\n"},{"date":"2015-05-07T22:42:40Z","author":"benjchristensen","text":"> optimise the RxJava default request behaviour for the most common use cases\n\nThe choice of 128 for server (and 16 for Android) was made after testing various different settings: https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/util\/RxRingBuffer.java#L162\n\nWhat do you recommend doing differently?\n\n> to be able to customize the requesting behaviour of the merge operator under backpressure for my use cases to increase performance\n\nWhat do you want to see done?\n"},{"date":"2015-05-08T01:46:30Z","author":"davidmoten","text":"128 is the initial request but the requests following were much smaller\nfrom memory (1, 3, 2,1, etc)  and it was hard to figure out what strategy\nfor those secondary requests was at play and if it had been benchmarked\nagainst other strategies.\n\nOn 8 May 2015 at 08:42, Ben Christensen notifications@github.com wrote:\n\n> optimise the RxJava default request behaviour for the most common use cases\n> \n> The choice of 128 was made after testing various different settings:\n> https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/util\/RxRingBuffer.java#L162\n> \n> What do you recommend doing differently?\n> \n> to be able to customize the requesting behaviour of the merge operator\n> under backpressure for my use cases to increase performance\n> \n> What do you want to see done?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2928#issuecomment-100040341.\n"},{"date":"2015-05-08T04:04:24Z","author":"davidmoten","text":"I think I can simplify what I want having thought about it a little bit. I'm happy with 128 as an initial request   and would like further requests to also be for the same number. \n"},{"date":"2015-05-19T20:33:57Z","author":"benjchristensen","text":"> would like further requests to also be for the same number.\n\nAh, that makes sense. I tried that at one point but couldn't get it to work as it got ridiculously complicated and I never went back to solve it. I definitely would like as well.\n"},{"date":"2015-06-06T08:52:36Z","author":"akarnokd","text":"While rewatching old Rx videos, I remembered one can implement flatMap in terms of merge and vice versa. I think if merge was be implemented via flatMap, one could save the allocation cost of the lifted map. Then merge == flatMap(o -> o). Any interest in pursuing this?\n"},{"date":"2015-06-06T09:04:23Z","author":"headinthebox","text":"That should be easy to check.\n"},{"date":"2015-06-10T21:38:17Z","author":"benjchristensen","text":"Perf testing on my MacBook Pro show this PR to be very good in most cases, with small hits in single item usage.\n\n```\nBenchmark                                          (size)      Existing            PR    \nr.o.OperatorMergePerf.merge1SyncStreamOfN               1   4488176.832   3797359.176  -  \nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000     41297.217     66490.338  ++  \nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000        38.634        79.525  ++  \nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1    102128.738    108055.722    \nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000         5.216        13.558  +  \nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1   4390861.330   4299418.343    \nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100    471690.468    599665.596  ++  \nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000     52613.616     60820.047  + \nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1   4363837.871   4116988.261  -  \nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000        38.733        65.728  ++  \nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1     80926.413     86795.725  +  \nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000      2183.016      6377.939  ++  \nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1   4622062.299   4015324.624  -  \nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000     38870.489     61401.234  ++  \nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000        36.085        63.094  ++  \n\n\nBenchmark                                          (size)      Existing           PR\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1    361714.683   394960.426 +\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000       368.362      422.990 +\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000         0.331        0.423 +\nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync          1   5372884.569  4637892.778 -\nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync       1000     38254.799    59231.991 ++\nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync    1000000        34.971       59.548 ++\nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync            1   3850581.086  3783613.293 \nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync         1000     20510.271    34840.826 ++\nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync      1000000        19.049       39.653 ++\n```\n"},{"date":"2015-06-11T07:15:02Z","author":"akarnokd","text":"I've updated the PR to include some scalar merge optimizations:\n\n![image](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/8101689\/d4cbdfb0-1019-11e5-8c7b-28baf28d1172.png)\n\nThe biggest overhead reduction is in `flatMapIntPassthruSync:1`. Unfortunately, these changes couldn't help much with the `OperatorMergePerf` tests of size 1.\n"},{"date":"2015-06-11T08:37:53Z","author":"akarnokd","text":"I've also tried various inlining:\n![image](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/8103007\/3cd257fa-1025-11e5-8f06-f376345e4a2f.png)\n- In ScalarMap, I've inlined the mapping over a scalar.\n- In InlineMap, I've changed the code to calculate `func` in map at construction time for a scalar source (which is incorrect if the `func` depends upon the environment as well)\n- In FixedMerge, I've added checks to merge(Iterable) for a 1 element Iterable.\n\nI measured improvements but either the approach was too special or performance degradation appeared in n > 1 cases.\n"},{"date":"2015-06-11T15:54:31Z","author":"benjchristensen","text":"Since you're updating this PR, can you rebase it and remove all the unrelated changes that touched whitespace in various files?\n\nI'm in process of reviewing this code and we'll do a production canary test with our systems at Netflix due to the high impact of these changes.\n"},{"date":"2015-06-11T20:13:33Z","author":"akarnokd","text":"Done.\n"},{"date":"2015-06-11T20:29:12Z","author":"benjchristensen","text":"Thank you.\n\n@abersnaze Use https:\/\/github.com\/benjchristensen\/RxJava\/tree\/merge-rewrite-from-2928 as a clean merge of this PR on top of 1.x to production canary this code.\n"},{"date":"2015-06-15T18:08:24Z","author":"benjchristensen","text":"I don't see a change in perf results with the updated code.\n\n```\nBenchmark                                          (size)      Existing            PR        PR Update\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1   4488176.832   3797359.176  -   3793580.516\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000     41297.217     66490.338  ++    67796.814\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000        38.634        79.525  ++       75.695\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1    102128.738    108055.722        94091.453\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000         5.216        13.558  +        13.106\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1   4390861.330   4299418.343      3710019.659\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100    471690.468    599665.596  ++   546427.145\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000     52613.616     60820.047  +     60663.164\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1   4363837.871   4116988.261  -   3865008.834 --\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000        38.733        65.728  ++       61.194\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1     80926.413     86795.725  +     78765.125\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000      2183.016      6377.939  ++     6060.544\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1   4622062.299   4015324.624  -   3935245.004 --\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000     38870.489     61401.234  ++    57938.065\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000        36.085        63.094  ++       58.667\n\n\nBenchmark                                          (size)      Existing           PR        Updated PR\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1    361714.683   394960.426 +      389851.694\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000       368.362      422.990 +         423.083\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000         0.331        0.423 +           0.430\nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync          1   5372884.569  4637892.778 -     4672089.981\nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync       1000     38254.799    59231.991 ++      60356.703\nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync    1000000        34.971       59.548 ++         61.814\nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync            1   3850581.086  3783613.293       3913069.169\nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync         1000     20510.271    34840.826 ++      33852.646\nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync      1000000        19.049       39.653 ++         39.805\n```\n"},{"date":"2015-06-15T18:25:55Z","author":"akarnokd","text":"It appears I've accidentally overwritten the scalarMerge optimization with the 3rd try version when I fixed the whitespaces.\n"},{"date":"2015-06-15T18:46:33Z","author":"akarnokd","text":"I've readded the optimization: The results on my i7 4770K, Windows 7 x64, JDK8u45 (the one with ~38M was an i7 4790) running 5 iterations of 5 seconds:\n\n![image](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/8167559\/5b9c81c4-139f-11e5-880d-08c451418ae0.png)\n\nThe drop in `flatMapTwoNestedSync:1` is due to the branch introduced by the optimization. If I change it to use `instanceof`, I get the following picture:\n\n![image](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/8167862\/4f9a85b8-13a1-11e5-9fc1-ba0839623142.png)\n"},{"date":"2015-06-15T19:13:12Z","author":"benjchristensen","text":"With that change perf looks good across the board:\n\n```\n\nBenchmark                                          (size)      Existing            PR       Updated PR\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1   4488176.832   3797359.176  -   4159885.024 (variability within Score Error)\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000     41297.217     66490.338  ++    68923.081 ++\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000        38.634        79.525  ++       81.282 ++\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1    102128.738    108055.722       106696.532\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000         5.216        13.558  +        13.258 +\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1   4390861.330   4299418.343      3989522.580 (variability within Score Error)\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100    471690.468    599665.596  ++   551513.541 ++\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000     52613.616     60820.047  +     59881.347 +\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1   4363837.871   4116988.261  -   3894283.923 (variability within Score Error)\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000        38.733        65.728  ++       58.229 ++\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1     80926.413     86795.725  +     87696.276 +\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000      2183.016      6377.939  ++     6114.703 ++\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1   4622062.299   4015324.624  -   3858413.960 (variability within Score Error)\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000     38870.489     61401.234  ++    60379.171 ++\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000        36.085        63.094  ++       60.046 ++\n\n\nBenchmark                                          (size)      Existing           PR       Updated PR  \nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1    361714.683   394960.426 +     445826.696 ++\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000       368.362      422.990 +        430.198 + \nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000         0.331        0.423 +          0.426 + \nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync          1   5372884.569  4637892.778 -   27905012.198 +++ \nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync       1000     38254.799    59231.991 ++     59401.089 ++ \nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync    1000000        34.971       59.548 ++        59.818 ++ \nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync            1   3850581.086  3783613.293      3673091.400  \nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync         1000     20510.271    34840.826 ++     32466.541 ++ \nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync      1000000        19.049       39.653 ++        36.963 ++ \n```\n"},{"date":"2015-06-15T19:20:08Z","author":"akarnokd","text":"The problem with these:\n\n```\nBenchmark                                          (size)      Existing            PR       Updated PR\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1   4488176.832   3797359.176  -   4159885.024 (variability within Score Error)\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1   4390861.330   4299418.343      3989522.580 (variability within Score Error)\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1   4363837.871   4116988.261  -   3894283.923 (variability within Score Error)\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1   4622062.299   4015324.624  -   3858413.960 (variability within Score Error)\n```\n\nIs that the scalar merge optimization can't apply because they are:\n`merge(just(1).map(v -> just(1)))` so the merge() receives an arbitrary Observable instead of a scalar; the map() hides the first just's scalar nature.\n"},{"date":"2015-06-17T22:56:13Z","author":"benjchristensen","text":"I finally spent the hours to review this thoroughly ... very well written code @akarnokd \n\nI'm going to now add inline comments and questions on the code. Most are clarifications, though there is at least one bug I think I found. \n"},{"date":"2015-06-18T16:56:35Z","author":"benjchristensen","text":"Pulling comments on optimization into the main comments rather than the diffs which are getting hidden as code changes.\n\nModified comment from https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2928#discussion_r32748363:\n\n---\n\nThe downstream requesting unbounded data does not necessarily mean unbounded up. The `merge` operator is an async operator, just like `zip` and `observeOn` since it does queueing. This means the `merge` operator itself IS an async operator and thus has buffered, `request(n)` semantics regardless of whether the downstream requests `Long.MAX_VALUE` or not.\n\nThe only cases I'm aware of where it doesn't need to buffer are the following where no concurrent emission occurs:\n\n1) When `merge` has only a single stream to merge (not a real merge, so not an interesting case)\n2) When `maxConcurrent==1` which is the same as `concat` or effectively the same as usecase 1 above.\n3) When each Observable being merged is synchronous, which can't be known by `merge` ahead of time. In this case it again behaves like `concat`. \n\nSince (3) is the common case to optimize for (ie. many short synchronous streams), we would have to determine this at runtime. Basically we assume that if we never have `missed` occur due to concurrent emission, we stay on the \"fast path\", but as soon as we see concurrency occur we have to use queues.\n\nThis is why the current implementation has an optimization to skip the queues: https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/operators\/OperatorMerge.java#L612 and https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/operators\/OperatorMerge.java#L686\n\nBut it uses the queues as soon as concurrent emissions happen.\n\nSo we can't have an unbounded buffer as an optimization, but we can try to skip use of the buffer when we don't have concurrent emissions. As soon as we have concurrent emissions though we must use the buffer. And we must maintain `request(n)` semantics. \n"},{"date":"2015-06-18T17:34:22Z","author":"akarnokd","text":"Okay. I'll remove the unbounded paths and add a fast-path to the InnerSubscribers.\n\nHowever, I found a few cases that needs further decisions:\n\nIn `OperatorMergeDelayErrorTest.testErrorDelayed1` expects the source to emit \"six\" which doesn't happen in the normal path of this PR because I shut the source down. The test indicates the original merge allowed value emissions after error from the same source.\n\nIn the same test class in `testMergeSourceWhichDoesntPropagateExceptionBack` if the child subscriber's onNext throws, why do we want to keep emitting the subsequent values if delayErrors == true? If the child crashed while trying to work with the value why do we think the next value won't crash it or find it in an inconsistent state?\n\nThe `OperatorFlatMapPerf.flatMapIntPassthruAsync` has a logical error. It runs an async observation but doesn't wait for the completion of it. Basically it floods the system with scheduled tasks. If I add a latched observer, I get ~ 200k ops\/s with both 1.x and this PR.\n"},{"date":"2015-06-18T17:42:22Z","author":"benjchristensen","text":"> I'll remove the unbounded paths and add a fast-path to the InnerSubscribers.\n\nThank you.\n\n> The test indicates the original merge allowed value emissions after error from the same source.\n\nThat sounds wrong. A given `Observable` can't emit after an `onError` so that test would be invalid. \n\n> If the child crashed while trying to work with the value why do we think the next value won't crash it or find it in an inconsistent state?\n\nThat's a hard one. I can see your point, but `mergeDelayError` asks to \"delay errors\", so we delay them. If we change that behavior we will almost certainly break usage. This unit test came from user requirements for `mergeDelayError`.\n\n> The OperatorFlatMapPerf.flatMapIntPassthruAsync has a logical error\n\nThen let's fix it in 1.x and rebase this PR on top so we are comparing the right metrics.\n"},{"date":"2015-06-18T17:55:23Z","author":"akarnokd","text":"> Then let's fix it in 1.x\n\nI'm busy with the changes to this PR. Could you do this?\n"},{"date":"2015-06-18T17:58:26Z","author":"benjchristensen","text":"> Could you do this?\n\nSure.\n"},{"date":"2015-06-18T18:36:43Z","author":"akarnokd","text":"Well, my first try is mostly a disaster:\n\n![image](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/8239035\/a7196aa2-15f9-11e5-8d89-ab9b2abf646b.png)\n"},{"date":"2015-06-18T18:37:38Z","author":"benjchristensen","text":":-)\n"},{"date":"2015-06-18T20:20:56Z","author":"akarnokd","text":"I did recover most of the performance, but still some cases lag behind:\n\n![image](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/8241049\/2cb463c6-1607-11e5-82c7-486e76617302.png)\n\nI managed this by adding a batching request to the InnerSubscriber (same logic as in #3030). I think the remaining performance loss is due to requesting from the main source one by one, but I'm not sure if I want to batch those as well because the maxConcurrent nature. The duplicate tryEmit is due to avoid a bimorphic dispatch: if I implement a common base class, I lose ~5% from the throughput values.\n\nI'm finished for today but I'll try to get back to the 1.x performance in the remaining clases.\n"},{"date":"2015-06-19T14:00:14Z","author":"akarnokd","text":"It seems the merge is quite sensitive to method structuring: just by refactoring the scalar emission path I got some notable performance back, but still, the single-value merge are a bit slower than 1.x. I think, however, that the green improvements are quite worth it.\n\n![image](https:\/\/cloud.githubusercontent.com\/assets\/1269832\/8254716\/f793a302-169a-11e5-951f-9e421a3afc1a.png)\n\nThese are the two 1000 sized tests with their error range:\n\n```\n   flatMapIntPassthruSync       1000  thrpt         5    53754,733     4624,880    ops\/s\noneStreamOfNthatMergesIn1      1000  thrpt         5    55004,627      772,675    ops\/s\n```\n\nThey never got closer to the 1.x line. At one point, I changed merge() to assume MAX_VALUE requests all the time but it didn't affect the number and I have no idea where the performance leaks. They both merge 1000 scalar values which don't touch any queue, don't account the production and just request another value before they return.\n"},{"date":"2015-06-19T19:30:26Z","author":"benjchristensen","text":"Nothing stands out when I do a Flight Recorder profiling ... reviewing code changes.\n"},{"date":"2015-06-22T17:56:40Z","author":"benjchristensen","text":"@akarnokd Do the new unit tests in this PR cover the things that were broken in the current merge impl? If not, what other use cases are broken today that this fixes?\n\nNote that I'm still digging into this revised code and exploring various perf tests.\n"},{"date":"2015-06-22T18:06:10Z","author":"akarnokd","text":"Yes, there was a potential hang when merging only scalar values and when merging a mixture of scalar and non-scalar values.\n"},{"date":"2015-06-22T18:29:43Z","author":"benjchristensen","text":"Were you ever able to reproduce that with a unit test? Do you have that code?\n"},{"date":"2015-06-22T18:32:28Z","author":"akarnokd","text":"They are the 'flatMapRangeMixedAsyncLoop' and 'testFastMergeFullScalar' tests.\n"},{"date":"2015-07-14T18:50:55Z","author":"benjchristensen","text":"I did another pass on this and think it's good for merging and building a snapshot for a few days of final testing before release.\n\nI still question the subscribe\/unsafeSubscribe thing above, but can discuss that further.\n"},{"date":"2015-07-14T18:55:40Z","author":"akarnokd","text":"> I still question the subscribe\/unsafeSubscribe thing above, but can discuss that further.\n\nThat was a simple oversight, it was already fixed before you merged this.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-07-14T18:50:59Z","description":"I've rewritten `merge` and `mergeMaxConcurrent` together from scratch.\n- Added experimental `maxConcurrent` overloads to the array-merge and the mergeDelayError\n- Fixed `OperatorMapNotification` beause it disregarded backpressure on its terminal emissions.\n- While debugging some merge test failures, I've encountered a bug in OperatorPublish with the same underlying logical error (see comment) and fixed it here.\n- Accidentally introduced a few tabs, therefore, I went in and replaced all tabs with spaces.\n- I've changed `OperatorMergeTest.shouldNotCompleteIfThereArePendingScalarSynchronousEmissionsWhenTheLastInnerSubscriberCompletes` because it is legal to get onCompleted without any request.\n","id":"72267411","title":"Merge and MergeMaxConcurrent unified and rewritten","opened_on":"2015-04-30T20:02:47Z","closed_by":"benjchristensen"},{"number":"2921","reopenOn":null,"comments":[{"date":"2015-04-29T07:13:49Z","author":"akarnokd","text":"Looks good, but I don't like what happens in the `ObserveOnSubscriber` constructor since the half-constructed `this` may escape through the `setProducer` call. \n\nIf you could just move the code from the line `child.add(scheduledUnsubscribe);` up until the constructor's end into some `init()` method and make sure it is called after the object is constucted (near `return new ObserveOnSubscriber<T>(scheduler, child);`), that would be great.\n"},{"date":"2015-04-29T07:36:47Z","author":"davidmoten","text":"Ok, done. Haven't squashed commits because I think worthwhile having as a separate entry in the history.\n"},{"date":"2015-04-29T07:57:29Z","author":"akarnokd","text":"Great, thanks!\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-04-29T07:57:34Z","description":"Use `BackpressureUtils.getAndAddRequest` in the `Producer` in `OperatorObserveOn`.\n\nIncludes unit test that failed on codebase before this change.\n","id":"71769247","title":"OperatorObserveOn - handle request overflow correctly","opened_on":"2015-04-29T03:38:03Z","closed_by":"akarnokd"},{"number":"2912","reopenOn":null,"comments":[{"date":"2015-04-23T17:13:06Z","author":"akarnokd","text":"```\nBenchmark      (size)        2912   2912 error       1.0.9  1.0.9 error\nobserveOn           1  198785,487    59066,518  203658,175     2162,208\nobserveOn          10  153990,002    79263,702  178839,814    17425,416\nobserveOn         100  150333,481    20749,482  148706,965    15169,371\nobserveOn        1000   25568,884    24718,878   16911,025     7937,752\nobserveOn        2000   14914,879    17179,009   10022,748    12460,449\nobserveOn        3000   11238,118     2400,207   10359,226     2868,300\nobserveOn        4000    8172,019     1370,653    7084,573     1460,569\nobserveOn       10000    3491,021      606,603    3412,501      527,199\nobserveOn      100000     398,684       20,607     400,360       14,743\nobserveOn     1000000      41,865        1,884      43,887        0,746\nsubscribeOn         1  209443,261     8593,857  169965,326   104264,868\nsubscribeOn        10  175152,648    79449,091  151055,057   152837,825\nsubscribeOn       100  150042,891    84189,199  140177,447   128390,130\nsubscribeOn      1000   72804,521    29222,089   57929,258    19364,337\nsubscribeOn      2000   61834,990    14148,419   36040,899     8608,854\nsubscribeOn      3000   44148,878     4653,713   44982,855     3551,646\nsubscribeOn      4000   35494,660     3338,209   30343,790    24747,587\nsubscribeOn     10000   14890,534     6229,533   13920,062     1897,708\nsubscribeOn    100000    1691,786      230,978    1661,187      141,518\nsubscribeOn   1000000     193,028       22,564     191,835       16,975\n```\n\nThere doesn't seem to be any performance degradation, however, small sized measurements are quite hectic for some reason.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-04-30T05:26:35Z","description":"SubscriptionList.add() and thread unparking.\n\nThis PR partially reverts some changes from earlier scheduler optimizations and fixes a case where if multiple concurrent schedule() calls happen, the order in the SubscriptionList might be different from the actual execution order which degrades performance on task termination due to remove() being O(n).\n\nThis might be the source of degradation in #2857 as well.\n\nI'll post the `ComputationSchedulerPerf` results later.\n","id":"70446864","title":"Fix the performance degradation due to different schedule execution and","opened_on":"2015-04-23T15:53:55Z","closed_by":"benjchristensen"},{"number":"2907","reopenOn":null,"comments":[{"date":"2015-04-30T07:41:53Z","author":"akarnokd","text":"I've discovered another retention problem and updated the PR to fix it as well.\n"},{"date":"2015-05-13T17:56:13Z","author":"benjchristensen","text":"Thanks for the explanation.\n"},{"date":"2015-09-23T22:16:29Z","author":"zhiyanshao","text":"@akarnokd @benjchristensen  \n\nIs this fixed? I still see the following exception on 1.0.14. Below is the stack from our service's log:\n\nERROR [2015-09-23 20:54:00,640] com.mycompany.mobile.dropwizard.exception.AbstractExceptionMapper: Error handling request: \n! java.util.concurrent.RejectedExecutionException: Task rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker@5e731de2 rejected from java.util.concurrent.ThreadPoolExecutor@500df7b6[Running, pool size = 25, active threads = 5, queued tasks = 25, completed tasks = 6741988]\n! at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) ~[na:1.8.0_51]\n! at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) ~[na:1.8.0_51]\n! at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) ~[na:1.8.0_51]\n! at com.google.common.util.concurrent.MoreExecutors$ListeningDecorator.execute(MoreExecutors.java:550) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.schedule(ExecutorScheduler.java:78) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.internal.operators.OperatorSubscribeOn$1.onNext(OperatorSubscribeOn.java:57) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.internal.operators.OperatorSubscribeOn$1.onNext(OperatorSubscribeOn.java:43) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.Observable$2.call(Observable.java:162) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.Observable$2.call(Observable.java:154) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.Observable$2.call(Observable.java:162) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.Observable$2.call(Observable.java:154) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.Observable$2.call(Observable.java:162) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.Observable$2.call(Observable.java:154) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.Observable$2.call(Observable.java:162) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.Observable$2.call(Observable.java:154) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.Observable.subscribe(Observable.java:7804) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.Observable.subscribe(Observable.java:7772) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:432) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at rx.observables.BlockingObservable.first(BlockingObservable.java:159) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.mycompany.mobile.common.concurrency.ObservableUtil.asList(ObservableUtil.java:27) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.mycompany.mobile.token.PushDeviceTokenResource.getTokenByDeviceToken(PushDeviceTokenResource.java:261) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at sun.reflect.GeneratedMethodAccessor23.invoke(Unknown Source) ~[na:na]\n! at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_51]\n! at java.lang.reflect.Method.invoke(Method.java:497) ~[na:1.8.0_51]\n! at com.sun.jersey.spi.container.JavaMethodInvokerFactory$1.invoke(JavaMethodInvokerFactory.java:60) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.server.impl.model.method.dispatch.AbstractResourceMethodDispatchProvider$ResponseOutInvoker._dispatch(AbstractResourceMethodDispatchProvider.java:205) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.server.impl.model.method.dispatch.ResourceJavaMethodDispatcher.dispatch(ResourceJavaMethodDispatcher.java:75) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.codahale.metrics.jersey.InstrumentedResourceMethodDispatchProvider$ExceptionMeteredRequestDispatcher.dispatch(InstrumentedResourceMethodDispatchProvider.java:69) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at io.dropwizard.jersey.guava.OptionalResourceMethodDispatchAdapter$OptionalRequestDispatcher.dispatch(OptionalResourceMethodDispatchAdapter.java:37) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.server.impl.uri.rules.HttpMethodRule.accept(HttpMethodRule.java:302) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:147) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.server.impl.uri.rules.ResourceObjectRule.accept(ResourceObjectRule.java:100) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:147) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.server.impl.uri.rules.RootResourceClassesRule.accept(RootResourceClassesRule.java:84) ~[push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:1542) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:1473) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:1419) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:1409) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.spi.container.servlet.WebComponent.service(WebComponent.java:409) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:540) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:715) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at javax.servlet.http.HttpServlet.service(HttpServlet.java:770) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at io.dropwizard.jetty.NonblockingServletHolder.handle(NonblockingServletHolder.java:49) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1515) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.servlets.UserAgentFilter.doFilter(UserAgentFilter.java:83) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.servlets.GzipFilter.doFilter(GzipFilter.java:348) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at io.dropwizard.jetty.BiDiGzipFilter.doFilter(BiDiGzipFilter.java:127) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1486) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at io.dropwizard.servlets.ThreadNameFilter.doFilter(ThreadNameFilter.java:29) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1486) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at io.dropwizard.jersey.filter.AllowedMethodsFilter.handle(AllowedMethodsFilter.java:44) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at io.dropwizard.jersey.filter.AllowedMethodsFilter.doFilter(AllowedMethodsFilter.java:39) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1486) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:519) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1097) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:448) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1031) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:136) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at com.codahale.metrics.jetty9.InstrumentedHandler.handle(InstrumentedHandler.java:175) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at io.dropwizard.jetty.RoutingHandler.handle(RoutingHandler.java:51) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.server.handler.RequestLogHandler.handle(RequestLogHandler.java:92) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.server.handler.StatisticsHandler.handle(StatisticsHandler.java:162) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.server.Server.handle(Server.java:446) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:271) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:246) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.io.AbstractConnection$ReadCallback.run(AbstractConnection.java:358) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:601) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:532) [push-token-server-0.0.99-shaded.jar:0.0.99]\n! at java.lang.Thread.run(Thread.java:745) [na:1.8.0_51]\n"},{"date":"2015-09-24T07:32:52Z","author":"akarnokd","text":"@zhiyanshao You seem to have a different problem than what this PR fixes. Either your pool has been shutdown in the middle or you are running with a bounded internal queue that gets overflown.\n"},{"date":"2015-09-24T18:18:57Z","author":"zhiyanshao","text":"@akarnokd , thank you for your reply. \n\nDo you know under what circumstances the pool will be shutdown in the middle and how I can tell if I am running with a bounded internal queue? Are these two scenarios by design and can be fixed in my code?\n"},{"date":"2015-09-24T18:29:18Z","author":"akarnokd","text":"It appears you are using some Google threadpool-helper classes. Look where the Executor or ExecutorService is configured in your project.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-05-13T17:56:16Z","description":"Fixes a race condition with the timed schedule (first potentially overwriting the result of the untimed schedule in mas) and a scheduled task retention problem due to not tracking those.\n","id":"70335848","title":"Fixed schedule race and task retention with ExecutorScheduler.","opened_on":"2015-04-23T07:29:50Z","closed_by":"benjchristensen"},{"number":"2904","reopenOn":null,"comments":[{"date":"2015-04-22T06:30:09Z","author":"akarnokd","text":"Excellent!\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-04-22T06:30:06Z","description":"Added request overflow check to `TakeLastQueueProducer` and associated unit test (that failed on existing code base).\n","id":"70009869","title":"TakeLast - add request overflow check","opened_on":"2015-04-22T03:22:12Z","closed_by":"akarnokd"},{"number":"2897","reopenOn":null,"comments":[{"date":"2015-04-21T00:34:49Z","author":"davidmoten","text":"Could you add the unit test from your gist as well?\n"},{"date":"2015-04-21T00:37:53Z","author":"davidmoten","text":"Ah, someone else's gist. Still, as the unit test is there may as well chuck it in.\n"},{"date":"2015-04-21T01:23:07Z","author":"alexwen","text":"Thanks for the feedback. Is it kosher to do a sleep in the test? Its the\nonly way I've been able to get the windows to overlap and reproduce the\ncondition.\n\nAlso, it doesn't seem too reliable to depend upon sleep.\n"},{"date":"2015-04-21T07:04:21Z","author":"akarnokd","text":"Good catch! An unit test would be great, but you don't really need concurrency: reentrancy will do just fine:\n\n``` java\n    @Test\n    public void testWindowNoDuplication() {\n        final PublishSubject<Integer> source = PublishSubject.create();\n        final TestSubscriber<Integer> tsw = new TestSubscriber<Integer>() {\n            boolean once;\n            @Override\n            public void onNext(Integer t) {\n                if (!once) {\n                    once = true;\n                    source.onNext(2);\n                }\n                super.onNext(t);\n            }\n        };\n        TestSubscriber<Observable<Integer>> ts = new TestSubscriber<Observable<Integer>>() {\n            @Override\n            public void onNext(Observable<Integer> t) {\n                t.subscribe(tsw);\n                super.onNext(t);\n            }\n        };\n        source.window(new Func0<Observable<Object>>() {\n            @Override\n            public Observable<Object> call() {\n                return Observable.never();\n            }\n        }).subscribe(ts);\n\n        source.onNext(1);\n        source.onCompleted();\n\n        assertEquals(1, ts.getOnNextEvents().size());\n        assertEquals(Arrays.asList(1, 2), tsw.getOnNextEvents());\n    }\n```\n"},{"date":"2015-04-21T15:39:44Z","author":"alexwen","text":"Thanks @akarnokd - great test!\n"},{"date":"2015-04-21T15:58:20Z","author":"akarnokd","text":"Thanks!\n"},{"date":"2015-04-21T20:48:33Z","author":"benjchristensen","text":"Should I push a patch release with this today?\n"},{"date":"2015-04-21T21:00:12Z","author":"akarnokd","text":"A verification on #2878 would be great. After that, the patch release can commence.\n"}],"opened_by":"alexwen","reopen":false,"closed_on":"2015-04-21T15:58:22Z","description":"Source was emitting t multiple times while holding queue.\n\nFixes #2896\n","id":"69704859","title":"Fix for overlapping windows. ","opened_on":"2015-04-20T23:36:07Z","closed_by":"akarnokd"},{"number":"2894","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-04-21T07:16:54Z","description":"Fixes issue #2890.\n","id":"69527746","title":"Concat: fixed reentrancy problem in completeInner","opened_on":"2015-04-20T07:42:56Z","closed_by":"akarnokd"},{"number":"2892","reopenOn":null,"comments":[{"date":"2015-04-19T12:13:35Z","author":"davidmoten","text":"If this is right I'll submit another PR for `OnSubscribeFromIterable` which has the same problem.\n"},{"date":"2015-04-20T05:21:16Z","author":"akarnokd","text":"Looks good. Thanks.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-04-20T05:21:20Z","description":"In `RangeProducer` if the first two requests come concurrently and are both for `Long.MAX_VALUE` then there is a possible race condition where the fast path is started twice thus emitting some or all elements twice.\n\nThis PR fixes the race by only allowing the fast path if the current request count is 0 (using `compareAndSet`).\n","id":"69418313","title":"Fix Observable.range race condition","opened_on":"2015-04-19T12:11:04Z","closed_by":"akarnokd"},{"number":"2890","reopenOn":null,"comments":[{"date":"2015-04-18T13:21:05Z","author":"ashish-tyagi","text":"Printing a portion of the stack trace.\n\n```\nException in thread \"pool-1-thread-2\" java.lang.StackOverflowError\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetTail(AbstractQueuedSynchronizer.java:2309)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer.enq(AbstractQueuedSynchronizer.java:591)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer.transferForSignal(AbstractQueuedSynchronizer.java:1682)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.doSignal(AbstractQueuedSynchronizer.java:1877)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.signal(AbstractQueuedSynchronizer.java:1944)\n    at java.util.concurrent.LinkedBlockingQueue.signalNotEmpty(LinkedBlockingQueue.java:172)\n    at java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue.java:429)\n    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1364)\n    at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.schedule(ExecutorScheduler.java:81)\n    at rx.internal.util.ScalarSynchronousObservable$NormalScheduledEmission.call(ScalarSynchronousObservable.java:95)\n    at rx.internal.util.ScalarSynchronousObservable$NormalScheduledEmission.call(ScalarSynchronousObservable.java:82)\n    at rx.Observable.subscribe(Observable.java:7585)\n    at rx.Observable.subscribe(Observable.java:7454)\n    at Test$1.call(Test.java:25)\n    at Test$1.call(Test.java:1)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n    at rx.internal.operators.OnSubscribeRange$RangeProducer.request(OnSubscribeRange.java:93)\n    at rx.Subscriber.request(Subscriber.java:145)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:160)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)\n    at rx.Observable.unsafeSubscribe(Observable.java:7495)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)\n    at rx.Observable.unsafeSubscribe(Observable.java:7495)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)\n    at rx.Observable.unsafeSubscribe(Observable.java:7495)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)\n    at rx.Observable.unsafeSubscribe(Observable.java:7495)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)\n    at rx.Observable.unsafeSubscribe(Observable.java:7495)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)\n    at rx.Observable.unsafeSubscribe(Observable.java:7495)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)\n    at rx.Observable.unsafeSubscribe(Observable.java:7495)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)\n    at rx.Observable.unsafeSubscribe(Observable.java:7495)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)\n    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)\n    at rx.Observable.unsafeSubscribe(Observable.java:7495)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)\n```\n"},{"date":"2015-04-20T07:43:52Z","author":"akarnokd","text":"Thanks for reporting. Can you try if PR #2894 fixes the problem for you as well?\n"},{"date":"2015-04-21T07:13:46Z","author":"ashish-tyagi","text":"Hi, I think it worked. I do not see the exception any longer, even with very large n. Thanks.\n"},{"date":"2015-04-21T07:17:20Z","author":"akarnokd","text":"Thanks for confirming. Closing via #2894.\n"}],"opened_by":"ashish-tyagi","reopen":false,"closed_on":"2015-04-21T07:17:20Z","description":"The following test code eventually fails with a StackOverFlowException, provided a sufficient large value of n.\n\n``` java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.Subscriber;\nimport rx.functions.Func1;\nimport rx.internal.operators.BufferUntilSubscriber;\nimport rx.schedulers.Schedulers;\nimport rx.subjects.Subject;\n\n\n\/**\n * @author Ashish.Tyagi\n *\/\npublic class Test {\n    public static void main(String[] args) throws InterruptedException {\n        final ExecutorService executor = Executors.newFixedThreadPool(2);\n\n        Func1<Integer, Observable<Integer>> func = new Func1<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> call(Integer t) {\n                Observable<Integer> observable = Observable.just(t).subscribeOn(Schedulers.from(executor));\n                Subject<Integer, Integer> subject = BufferUntilSubscriber.create();\n                observable.subscribe(subject);\n                return subject;\n            }\n        };\n\n        int n = 10000;\n\n        Observable.range(1, n).concatMap(func).subscribe(new Subscriber<Integer>() {\n            @Override\n            public void onNext(Integer t) {\n                \/\/ Consume after sleep for 1 ms\n                sleep();\n                System.out.println(t);\n            }\n\n            @Override\n            public void onCompleted() {\n                executor.shutdown();\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                executor.shutdown();\n            }\n        });\n\n        executor.awaitTermination(1, TimeUnit.MINUTES);\n    }\n\n    private static void sleep() {\n        try {\n            Thread.sleep(1);\n        } catch (InterruptedException e) {\n            \/\/ Ignore\n        }\n    }\n}\n```\n","id":"69308083","title":"Stack overflow with a combination of BufferTillSubscriber, subscribeOn and concatMap","opened_on":"2015-04-18T13:17:08Z","closed_by":"akarnokd"},{"number":"2884","reopenOn":null,"comments":[{"date":"2015-04-17T06:36:51Z","author":"akarnokd","text":"`from` and `range` already emit `onCompleted` if they are essentially empty or just after the last item so I think that should stay as the behavior.\n"},{"date":"2015-04-17T06:49:46Z","author":"davidmoten","text":"I don't thinks that's the case for `from`. Its `Producer` does nothing at all if request is 0.\n"},{"date":"2015-04-17T06:50:26Z","author":"davidmoten","text":"Same for `range`.\n"},{"date":"2015-04-17T06:54:50Z","author":"akarnokd","text":"@davidmoten you're right, I just checked the code.\n"},{"date":"2015-04-17T07:45:16Z","author":"viktorklang","text":"Hi @davidmoten,\n\nsince `request` is for `elements` and `complete` and `error` are not elements,\nit is intended for these signals to be propagated as soon as they are known.\n\nLet me know if you have any follow-on questions!\n"},{"date":"2015-04-17T10:23:30Z","author":"davidmoten","text":"Thanks @viktorklang. Do you think that intention should be a SHOULD addition to the Publisher rules in reactive-streams-jvm?\n"},{"date":"2015-04-17T10:34:28Z","author":"viktorklang","text":"Given that 2.9 already provisions for this I think a good compromise (I am not a fan of SHOULDs in general) to include this explanation as a part of https:\/\/github.com\/reactive-streams\/reactive-streams-jvm\/issues\/177\n\nWould that cover it?\n"},{"date":"2015-04-17T11:14:03Z","author":"davidmoten","text":"Sounds fine, thanks. \n"},{"date":"2015-04-17T11:15:23Z","author":"viktorklang","text":"@davidmoten Great. I'd like to take the opportunity to encourage you to assist with that Issue, if you have any cycles to spare. :)\n"},{"date":"2015-04-21T00:14:24Z","author":"davidmoten","text":"@akarnokd as you suspected originally `range` does emit `onCompleted` eagerly from an empty range. `from` does not emit `onCompleted` eagerly from an empty iterable so I submitted #2899.\n"},{"date":"2015-05-20T07:55:09Z","author":"akarnokd","text":"Seems to be fixed. Closing.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-05-20T07:55:09Z","description":"What is the _preferred_ behaviour for an observable that supports backpressure but emits nothing when it has been subscribed to with an initial request of 0? Should it report completion as soon as it knows it is empty or wait for a positive request? \n\nI notice that reactive-streams-jvm 2.9 says\n\n> A Subscriber MUST be prepared to receive an onComplete signal with or without a preceding Subscription.request(long n) call.\n\nThis allows us to go either way when developing an `Operator` for instance but perhaps RxJava wants to proffer a preferred or mandated direction for it's internal operators? @benjchristensen \n\nFYI @viktorklang \n","id":"69074028","title":"Backpressure and onComplete from an empty observable","opened_on":"2015-04-17T06:28:23Z","closed_by":"akarnokd"},{"number":"2878","reopenOn":null,"comments":[{"date":"2015-04-29T05:15:46Z","author":"benjchristensen","text":"Is this a replacement for your significant rewrite of `merge`? Are you still trying to rewrite it or just incrementally adjust it as done here? \n"},{"date":"2015-04-29T06:18:28Z","author":"akarnokd","text":"No, this is still incremental. The full rewrite will only happen for 2.0.\n"},{"date":"2015-04-29T16:43:00Z","author":"benjchristensen","text":"Cool, I like that approach better. That context helps me review this. \n\nDon't spend too much time on the 2.0 rewrite quite yet though until we figure out some of the foundational abstractions and contracts.\n"},{"date":"2015-04-30T06:00:53Z","author":"benjchristensen","text":"I'm not ready to proceed with this PR. I've added some comments above. The key part that concerns me is that we are changing to always route through a queue for scalar values when request(n) < Long.MAX_VALUE is happening. \n"},{"date":"2015-04-30T08:01:40Z","author":"akarnokd","text":"Apparently a full rewrite can't be avoided.\n"},{"date":"2015-04-30T18:51:31Z","author":"benjchristensen","text":"If you're going to pursue a full rewrite, make sure to pay attention not just to the JMH throughput numbers, but also the object allocation rates. \n\nI expect a rewrite of merge to take some non-trivial time to write, review and test considering the history and attempts made. It is a far more important operator performance-wise than most.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-04-30T08:01:46Z","description":"FlatMapping over a sequence of scalar observable values while observing them from a different thread did not work: items in the scalar queue where ignored by some terminal checks.\n","id":"68499508","title":"flatMap: fixed scalar-merging.","opened_on":"2015-04-14T21:16:21Z","closed_by":"akarnokd"},{"number":"2876","reopenOn":null,"comments":[{"date":"2015-08-13T00:41:26Z","author":"akarnokd","text":"It crashes with `IllegalStateException:more produced than requested` because `just()` doesn't honor backpressure. The former `concat` version didn't use the arbiter and could end up in an undefined state. Adding `onBackpressureBuffer` makes the test pass for me.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-08-13T00:41:26Z","description":"The following test eventually times out and rarely, it fails to deliver all 1000 elements per loop even though it terminates:\n\n``` java\n@Test\/\/(timeout = 100000)\npublic void concatMapRangeAsyncLoop() {\n    for (int i = 0; i < 1000000; i++) {\n        if (i % 100 == 0) {\n            System.out.println(\"concatMapRangeAsyncLoop > \" + i);\n        }\n        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n        Observable.range(0, 1000)\n        .concatMap(new Func1<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> call(Integer t) {\n                return Observable.just(t);\n            }\n        })\n        .observeOn(Schedulers.computation()).subscribe(ts);\n\n        ts.awaitTerminalEvent(2500, TimeUnit.MILLISECONDS);\n        ts.assertTerminalEvent();\n        ts.assertNoErrors();\n        assertEquals(1000, ts.getOnNextEvents().size());\n        assertEquals((Integer)999, ts.getOnNextEvents().get(999));\n    }\n}\n```\n\nI've looked at the code of `concatMap` but couldn't figure out why it stops emitting values. I've tried interleaving the method executions via debug-stepping but no luck.\n","id":"68468041","title":"concatMap hangs","opened_on":"2015-04-14T18:52:27Z","closed_by":"akarnokd"},{"number":"2875","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-04-14T10:26:57Z","description":"Fixes NPE reported in #2874.\n","id":"68315372","title":"Fix: NPE in requestFromChild method.","opened_on":"2015-04-14T09:26:25Z","closed_by":"akarnokd"},{"number":"2874","reopenOn":null,"comments":[{"date":"2015-04-14T09:23:52Z","author":"akarnokd","text":"Thanks. The issue is with the volatile variable `currentSubscriber` being read several times and it can become null  if the request and completion happen at the same time.\n"},{"date":"2015-04-14T10:27:27Z","author":"akarnokd","text":"Closed via #2875 \n"},{"date":"2015-04-15T10:01:17Z","author":"ashish-tyagi","text":"Thanks! The issue does not produce any longer.\n"}],"opened_by":"ashish-tyagi","reopen":false,"closed_on":"2015-04-14T10:27:27Z","description":"It is difficult to produce this one. It occurs in our production service, which has a code almost like this:\n\n``` java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.functions.Action1;\nimport rx.functions.Func1;\nimport rx.schedulers.Schedulers;\nimport rx.subjects.PublishSubject;\nimport rx.subjects.Subject;\n\n\/**\n * @author Ashish.Tyagi\n *\/\npublic class Test {\n    public static void main(String[] args) throws InterruptedException {\n        Subject<Integer, Integer> subject = PublishSubject.create();\n        ExecutorService executor = Executors.newFixedThreadPool(1);\n\n        subject.concatMap(new Func1<Integer, Observable<? extends Integer>>() {\n            @Override\n            public Observable<? extends Integer> call(Integer t) {\n                return Observable.just(t);\n            }\n        }).observeOn(Schedulers.from(executor)).subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer t) {\n                if (t % 1000 == 0) {\n                    System.out.println(t);\n                }\n            }\n        });\n\n        for (int i = 0; i < 10000000; i++) {\n            subject.onNext(i);\n        }\n        subject.onCompleted();\n\n        executor.shutdown();\n        executor.awaitTermination(5, TimeUnit.MINUTES);\n    }\n}\n\n```\n\n```\nFoolowing is the exception thrown:\nException in thread \"serviceExecutor-1\" java.lang.NullPointerException\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.requestFromChild(OperatorConcat.java:129)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.access$100(OperatorConcat.java:78)\n    at rx.internal.operators.OperatorConcat$ConcatProducer.request(OperatorConcat.java:73)\n    at rx.Subscriber.request(Subscriber.java:141)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:207)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:65)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:155)\n    at rx.schedulers.ExecutorScheduler$ExecutorAction.run(ExecutorScheduler.java:173)\n    at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:99)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:745)\n```\n","id":"68307052","title":"concatMap + observeOn throws a NullPointerException sometimes","opened_on":"2015-04-14T08:48:32Z","closed_by":"akarnokd"},{"number":"2859","reopenOn":null,"comments":[{"date":"2015-04-07T05:53:06Z","author":"davidmoten","text":"Travis failure is unrelated:\n\n`rx.internal.operators.OperatorRetryTest > testRetryWithBackpressureParallel`\n"},{"date":"2015-04-07T09:34:57Z","author":"akarnokd","text":"Thanks.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-04-07T09:35:03Z","description":"When `Observable.doOnRequest` is used it does not pass unsubscription upstream. This PR fixes that and also adds a unit test of the base functionality for `doOnRequest` (no unit tests were present for this operator at all).\n","id":"66780235","title":"OperatorDoOnRequest should unsubscribe from upstream","opened_on":"2015-04-07T05:31:08Z","closed_by":"akarnokd"},{"number":"2854","reopenOn":null,"comments":[{"date":"2015-04-05T10:11:39Z","author":"davidmoten","text":"LGTM beyond trivial changes mentioned above. Thanks @akarnokd for fixing quickly (as usual)!\n"},{"date":"2015-04-07T09:42:34Z","author":"akarnokd","text":"Done.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-04-07T17:14:21Z","description":"Fixes #2853.\n","id":"66087506","title":"Fixes wrong request accounting in AbstractOnSubscribe","opened_on":"2015-04-03T06:24:04Z","closed_by":"akarnokd"},{"number":"2853","reopenOn":null,"comments":[],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-04-07T17:14:21Z","description":"`AbstractOnSubscribe` improperly throws an exception when the `onNext` method in a subscriber makes a call to `request` (all calls synchronous). The error thrown is this:\n\n```\njava.lang.IllegalStateException: This is not reentrant nor threadsafe!\n    at rx.observables.AbstractOnSubscribe$SubscriptionState.use(AbstractOnSubscribe.java:590)\n    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.doNext(AbstractOnSubscribe.java:360)\n    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.request(AbstractOnSubscribe.java:345)\n    at rx.Subscriber.request(Subscriber.java:145)\n    at rx.observables.AbstractOnSubscribeTest$20.onNext(AbstractOnSubscribeTest.java:541)\n    at rx.observables.AbstractOnSubscribeTest$20.onNext(AbstractOnSubscribeTest.java:1)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:130)\n    at rx.observables.AbstractOnSubscribe$SubscriptionState.accept(AbstractOnSubscribe.java:533)\n    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.doNext(AbstractOnSubscribe.java:367)\n    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.request(AbstractOnSubscribe.java:337)\n    at rx.Subscriber.setProducer(Subscriber.java:175)\n    at rx.Subscriber.setProducer(Subscriber.java:171)\n    at rx.observables.AbstractOnSubscribe.call(AbstractOnSubscribe.java:191)\n    at rx.observables.AbstractOnSubscribe.call(AbstractOnSubscribe.java:1)\n    at rx.Observable.subscribe(Observable.java:7585)\n    at rx.observables.AbstractOnSubscribeTest.testCanRequestInOnNext(AbstractOnSubscribeTest.java:527)\n```\n\nHere's a failing unit test:\n\n``` java\n    @Test\n    public void testCanRequestInOnNext() {\n        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {\n            @Override\n            protected void next(SubscriptionState<Integer, Void> state) {\n                state.onNext(1);\n                state.onCompleted();\n            }\n        };\n        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();\n        aos.toObservable().subscribe(new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                exception.set(e);\n            }\n\n            @Override\n            public void onNext(Integer t) {\n                request(1);\n            }\n        });\n        if (exception.get()!=null)\n            exception.get().printStackTrace();\n        assertNull(exception.get());\n    }\n```\n","id":"66051711","title":"AbstractOnSubscribe throws exception when onNext contains a request for more ","opened_on":"2015-04-03T01:54:22Z","closed_by":"akarnokd"},{"number":"2852","reopenOn":null,"comments":[{"date":"2015-04-02T18:42:10Z","author":"benjchristensen","text":"Should I release 1.0.9 with current 1.x branch?\n"},{"date":"2015-04-02T18:49:19Z","author":"akarnokd","text":"Yes.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-04-02T18:41:39Z","description":"Fixes both issue #2826 and [this StackOverflow](http:\/\/stackoverflow.com\/questions\/29324886\/retrywhen-operator-never-retries) problem.\n","id":"65857946","title":"Change retryWhen to eagerly ignore an error'd source's subsequent events","opened_on":"2015-04-02T06:53:35Z","closed_by":"benjchristensen"},{"number":"2851","reopenOn":null,"comments":[{"date":"2015-04-01T10:50:31Z","author":"akarnokd","text":"I'm not sure: why not request(1) for each dropped value similar to `filter()`?\n"},{"date":"2015-04-01T12:19:39Z","author":"zsxwing","text":"I just followed OperatorDebounceWithSelector.\n"},{"date":"2015-04-02T15:57:41Z","author":"zsxwing","text":"@akarnokd other comments?\n"},{"date":"2015-04-02T16:15:35Z","author":"akarnokd","text":"None.\n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2015-04-02T16:24:48Z","description":"Fixed #2850.\n\nThe issue is because OperatorDebounceWithTime will swallow values but not request more items. Just add `request(Long.MAX_VALUE)` since it doesn't support backpressure.\n","id":"65648365","title":"Add 'request(Long.MAX_VALUE)' in 'onStart' to fix the backpressure issue of debounce","opened_on":"2015-04-01T09:55:14Z","closed_by":"zsxwing"},{"number":"2850","reopenOn":null,"comments":[{"date":"2015-03-31T22:30:39Z","author":"marshallpierce","text":"Inserting a PublishSubject between the merge and throttle calls leads to normal operation (no backpressure exception).\n"},{"date":"2015-04-01T01:26:30Z","author":"dlew","text":"I've been looking into this with Marshall, here's some more oddities:\n\n```\nObservable.interval(200, MILLISECONDS)\n    .mergeWith(Observable.just(500L))\n    .debounce(500, MILLISECONDS)\n    .observeOn(Schedulers.newThread())\n    .subscribe(\n        (i) -> System.out.println(\"Got \" + i),\n        (t) -> {\n            t.printStackTrace();\n        }\n    );\n```\n\nIf you remove mergeWith, debounce, or observeOn, it works fine. All three are needed to create a failure situation.\n\nWhat's weirder is that, given the 200ms interval but 500ms debounce, the subscriber should basically never get onNext (by my understanding). Yet it actually does start to emit items (before the backpressure error kicks in).\n"},{"date":"2015-04-01T01:29:01Z","author":"dlew","text":"Oh, and one other thing: I tried using an `DebugHook` from RxJavaDebug to look into the situation, but with the hook attached it worked fine, which mystifies me further.\n"},{"date":"2015-04-01T09:55:43Z","author":"zsxwing","text":"Could you test #2851?\n"},{"date":"2015-04-01T15:55:07Z","author":"marshallpierce","text":"The change in #2851 prevents the error I'm seeing.\n"},{"date":"2015-04-01T15:57:49Z","author":"zsxwing","text":"@marshallpierce thanks for confirming it.\n"},{"date":"2015-04-02T15:54:40Z","author":"yogurtearl","text":"@benjchristensen can we get #2851  into v 1.0.9 . :) \n"},{"date":"2015-04-02T16:25:09Z","author":"zsxwing","text":"@yogurtearl merged.\n"}],"opened_by":"marshallpierce","reopen":false,"closed_on":"2015-04-02T16:24:48Z","description":"Repro: https:\/\/bitbucket.org\/marshallpierce\/rxjava-merge-backpressure\n\nIn text, here's what I'm doing: I have two observables: `Observable.never()`, and another that emits every 200ms. I `merge()` those two and `throttleWithTimeout()` the result with a long timeout. In a few seconds, I'll get this:\n\n```\nrx.exceptions.MissingBackpressureException\n    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:349)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.enqueue(OperatorMerge.java:721)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:698)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:586)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.onNext(SubjectSubscriptionManager.java:224)\n    at rx.subjects.PublishSubject.onNext(PublishSubject.java:114)\n    at org.mpierce.rxjava.merge.ExperimentMain.lambda$main$0(ExperimentMain.java:25)\n    at org.mpierce.rxjava.merge.ExperimentMain$$Lambda$1\/1685538367.call(Unknown Source)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n\nInstead, I would expect that the combo of merge & throttle should simply result in throttle working as expected (never emitting, in this case).\n","id":"65554598","title":"Using merge() with throttleWithTimeout() leads to MissingBackpressureException","opened_on":"2015-03-31T21:49:18Z","closed_by":"zsxwing"},{"number":"2848","reopenOn":null,"comments":[{"date":"2015-03-30T14:39:54Z","author":"akarnokd","text":"Do you mean, for example, sending a NullPointerException via onError instead of throwing?\n"},{"date":"2015-03-30T15:38:31Z","author":"YannRobert","text":"First, is that possible to throw an IllegalStateException or IllegalArgumentException? (instead of NPE) on Observable.java:7495 [rxjava-1.0.8.jar:1.0.8]\nWith a meaningfull description.\n\nAlso, the protected constructor of rx.Observable accepts null parameter. \nIs there any legitimate reason to pass null to this constructor? If not, an assertion in the constructor throwing an IllegalArgumentException may help. Otherwise, maybe document that null is a legal value.\n\nIs that possible to throw an exception in the subscribe() [1] call stack? like this is done here [2] \n\n[1] https:\/\/gist.github.com\/YannRobert\/a07ed294dbaccd4c3705#file-issueinrxjavadefensivecodetest-java-L86\n[2] https:\/\/gist.github.com\/YannRobert\/a07ed294dbaccd4c3705#file-issueinrxjavadefensivecodetest-java-L55\n"},{"date":"2015-04-02T06:58:21Z","author":"akarnokd","text":"Traditionally, we throw\/send NPEs.\n"},{"date":"2015-05-20T08:09:39Z","author":"akarnokd","text":"\/cc @benjchristensen I'd like your thoughts on this.\n"},{"date":"2015-08-13T00:44:42Z","author":"akarnokd","text":"The merge operator in 1.0.14 skips `null` `Observable`s values. I'm closing this due to inactivity.\n"}],"opened_by":"YannRobert","reopen":false,"closed_on":"2015-08-13T00:44:42Z","description":"I get the following stacktrace in one of my test output.\n\n```\njava.lang.NullPointerException: null\n    at rx.Observable.unsafeSubscribe(Observable.java:7495) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.handleNewSource(OperatorMerge.java:215) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:185) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:120) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:96) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.Subscriber.setProducer(Subscriber.java:177) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:33) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable$1.call(Observable.java:144) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable$1.call(Observable.java:136) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable$1.call(Observable.java:144) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable$1.call(Observable.java:136) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable.unsafeSubscribe(Observable.java:7495) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62) ~[rxjava-1.0.8.jar:1.0.8]\n    at rx.schedulers.ExecutorScheduler$ExecutorAction.run(ExecutorScheduler.java:173) [rxjava-1.0.8.jar:1.0.8]\n    at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:99) [rxjava-1.0.8.jar:1.0.8]\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_25]\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_25]\n    at java.lang.Thread.run(Thread.java:745) [na:1.8.0_25]\n```\n\nI found it is because I am using the merge operator with a mocked Subject instance.\n\nPlease see the following gist that describe the problem.\nhttps:\/\/gist.github.com\/YannRobert\/a07ed294dbaccd4c3705\nIf you run it, you will get the following stracktrace\n\n```\njava.lang.NullPointerException: null\n    at rx.Observable.unsafeSubscribe(Observable.java:7495) [rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.handleNewSource(OperatorMerge.java:215) [rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:185) [rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:120) [rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:96) [rxjava-1.0.8.jar:1.0.8]\n    at rx.Subscriber.setProducer(Subscriber.java:177) [rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47) [rxjava-1.0.8.jar:1.0.8]\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:33) [rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable$1.call(Observable.java:144) [rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable$1.call(Observable.java:136) [rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable.subscribe(Observable.java:7585) [rxjava-1.0.8.jar:1.0.8]\n    at rx.Observable.subscribe(Observable.java:7454) [rxjava-1.0.8.jar:1.0.8]\n    at IssueInRxJavaDefensiveCodeTest.shouldThrowIllegalStateExceptionOnMockSubjectSubscribeByMerge(IssueInRxJavaDefensiveCodeTest.java:86) [test-classes\/:na]\n```\n\nIt seems that we could use some defensive code in the merge operator, that would detect and report this, so that's it's easier to find where the problem is.\n","id":"65209218","title":"Improve defensive code in merge when onSubscribe function is null","opened_on":"2015-03-30T13:17:50Z","closed_by":"akarnokd"},{"number":"2845","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-03-25T15:55:11Z","description":"Fixes #2844.\n","id":"64030029","title":"Fix for repeat: wrong target of request","opened_on":"2015-03-24T15:43:30Z","closed_by":"benjchristensen"},{"number":"2844","reopenOn":null,"comments":[{"date":"2015-03-24T15:47:40Z","author":"akarnokd","text":"Thanks. This is a bug with `repeat()` and the fix is in #2845.\n"}],"opened_by":"DaGenix","reopen":false,"closed_on":"2015-03-25T15:55:11Z","description":"The following code:\n\n``` java\npublic class Test {\n    public static void main(final String[] arg) throws Exception {\n        Observable.just(1)\n                .repeat()\n                .concatMap(x -> {\n                    System.out.println(x);\n                    return Observable.empty()\n                            .delay(1, TimeUnit.SECONDS);\n                })\n                .subscribe();\n\n        Thread.sleep(Long.MAX_VALUE);\n    }\n}\n```\n\nPrints out two \"1\"s quickly, and then another \"1\" every second afterward.\n\nIf you change that code just slightly two use the two argument form of `just()` as in:\n\n``` java\npublic class Test {\n    public static void main(final String[] arg) throws Exception {\n        Observable.just(1, 2)\n                .repeat()\n                .concatMap(x -> {\n                    System.out.println(x);\n                    return Observable.empty()\n                            .delay(1, TimeUnit.SECONDS);\n                })\n                .subscribe();\n\n        Thread.sleep(Long.MAX_VALUE);\n    }\n}\n```\n\nThen, it prints \"1\", then \"2\", and then hangs and doesn't do anything afterward.\n\nI have no idea whats going on, but, I don't think that the 2nd piece of code should hang if the first one doesn't.\n\nI tested with 1.0.8 and didn't find any similar looking issue with a quick look.\n","id":"64013999","title":"ConcatMap combined with Delay causes a hang","opened_on":"2015-03-24T14:41:31Z","closed_by":"benjchristensen"},{"number":"2827","reopenOn":null,"comments":[{"date":"2015-03-16T07:45:56Z","author":"akarnokd","text":"To clarify the underlying issue, the problem is that map captures the error and pushes it downstream, which schedules a resubscription. However, just doesn't know about this case, and happily sends out onCompleted which then reaches the subscriber after the retry operator.\n"},{"date":"2015-03-18T17:54:50Z","author":"akarnokd","text":"We've fixed the main build, but this still fails and I don't get why. Could you rebase this to the current master?\n"},{"date":"2015-04-01T21:18:07Z","author":"akarnokd","text":"I found [this](http:\/\/stackoverflow.com\/questions\/29324886\/retrywhen-operator-never-retries) question on StackOverflow which reflects on a similar problem; the fix I suggested instead of this should solve both problems.\n\n> Instead of this, I'd add a done flag to the inner Subscriber to ignore any subsequent events; should be more lightweight.\n"},{"date":"2015-04-02T06:54:22Z","author":"akarnokd","text":"I'm closing this, see #2852 for an extended fix.\n"}],"opened_by":"abersnaze","reopen":false,"closed_on":"2015-04-02T06:54:22Z","description":"For #2826\nThe `ScalarSynchronousObservable` and `OperatorRetryWithPredicate` both assume that everyone else obey the rules so they don't have to.  Bad things happen when they are used together.\n","id":"61902071","title":"The retry with predicate wasn't behaving correctly when it used unsafeSubscribe","opened_on":"2015-03-15T21:19:49Z","closed_by":"akarnokd"},{"number":"2826","reopenOn":null,"comments":[{"date":"2015-05-20T08:26:34Z","author":"akarnokd","text":"The bug has been fixed through #2852. Closing.\n"}],"opened_by":"fatroom","reopen":false,"closed_on":"2015-05-20T08:26:34Z","description":"Hi, can somebody explain me why following piece of code printing only two times message \"Retrying\"? And not 5 times as specified in predicate?\nBTW if i uncomment doOnError line in this sample - i got 5 times message \"Retrying\".\nAny ideas what's going on here?\n\n```\nObservable.just(1)\n                .map(value -> { throw new RuntimeException(\"You shall not pass\"); })\n\/\/                .doOnError(t -> System.out.println(\"Handling error\"))\n                .retry((counter, throwable) -> {\n                    System.out.println(\"Retrying\");\n                    return counter < 5;\n                })\n                .toBlocking()\n                .single();\n```\n","id":"61885316","title":"Why retry method with predicate only retries 2 times?","opened_on":"2015-03-15T19:15:47Z","closed_by":"akarnokd"},{"number":"2810","reopenOn":null,"comments":[{"date":"2015-05-20T08:27:15Z","author":"akarnokd","text":"The operator has been fixed. Closing.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-05-20T08:27:15Z","description":"##### Reconnect issue\n\nThe following test fails because in OperatorPublish, the `state.getOrigin()` still holds the subscriber of a previous connection:\n\n``` java\n@Test\npublic void testSubscribeAfterDisconnectThenConnect() {\n    ConnectableObservable<Integer> source = Observable.just(1).publish();\n\n    TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();\n\n    source.subscribe(ts1);\n\n    Subscription s = source.connect();\n\n    ts1.assertReceivedOnNext(Arrays.asList(1));\n    ts1.assertNoErrors();\n    ts1.assertTerminalEvent();\n\n    TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>();\n\n    source.subscribe(ts2);\n\n    Subscription s2 = source.connect();\n\n    ts2.assertReceivedOnNext(Arrays.asList(1));\n    ts2.assertNoErrors();\n    ts2.assertTerminalEvent();\n\n    System.out.println(s);\n    System.out.println(s2);\n}\n```\n\nHowever, it works with `share()`:\n\n``` java\n@Test\npublic void testShareReconnect() {\n    Observable<Integer> source = Observable.just(1).share();\n\n    TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();\n\n    source.subscribe(ts1);\n\n    TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>();\n\n    source.subscribe(ts2);\n\n    ts1.assertNoErrors();\n    ts1.assertTerminalEvent();\n    ts1.assertReceivedOnNext(Arrays.asList(1));\n\n    ts2.assertNoErrors();\n    ts2.assertTerminalEvent();\n    ts2.assertReceivedOnNext(Arrays.asList(1));\n}\n```\n##### connect() is racy\n\nIn addition, the `OperatorPublish.connect()` method is inherently racy: two concurrent connect calls may succeed, one kicking out the upstream subscriber of the other.\n##### OriginSubscriber.requestMore may overflow\n\n`originOutstanding.addAndGet()` may turn negative\n##### Retention of subscribers after completion event.\n\nAfter making all relevant fields and classes package-private, the following test fails:\n\n``` java\n@Test\npublic void testNoSubscriberRetentionOnCompleted() {\n    OperatorPublish<Integer> source = (OperatorPublish<Integer>)Observable.just(1).publish();\n\n    TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();\n\n    source.unsafeSubscribe(ts1);\n\n    source.connect();\n\n    ts1.assertReceivedOnNext(Arrays.asList(1));\n    ts1.assertNoErrors();\n    ts1.assertTerminalEvent();\n\n    assertTrue(source.requestHandler.state.subscribers.length == 0 \n            && source.requestHandler.state.ss.isEmpty());\n}\n```\n\nNote that blindly evicting values from ss while completing in drainQueues() is wrong too, because if there is a concurrent subscription in the works, its tracking recod in state.ss and subscribers may get deleted as well, instead of letting it wait for the next connect().\n\n\/cc @davidmoten: please look at these issues while you fix OperatorPublish for #2803.\n","id":"60072100","title":"OperatorPublish bugs","opened_on":"2015-03-06T08:16:50Z","closed_by":"akarnokd"},{"number":"2809","reopenOn":null,"comments":[{"date":"2015-03-06T20:51:09Z","author":"benjchristensen","text":"Thanks for figuring this out and fixing. \n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-03-06T20:51:11Z","description":"of a terminal condition.\n\nThis issue came up in [a group discussion](https:\/\/groups.google.com\/forum\/#!topic\/rxjava\/sF2hy5sV5ck) (but is unrelated to the actual problem there). The problem was that takeUntil was unsafeSubscribed to, there was no one to terminate either the main or the other observable on a terminal condition, leaving the connection to upstream active indefinitely.\n","id":"60018003","title":"Fixed takeUntil not unsubscribing from either of the observables in case","opened_on":"2015-03-05T21:21:37Z","closed_by":"benjchristensen"},{"number":"2803","reopenOn":null,"comments":[{"date":"2015-03-05T15:47:37Z","author":"akarnokd","text":"If you don't mind some Reactive-Streams style code, you can look at my [OperatorPublish](https:\/\/github.com\/akarnokd\/RxJavaFlow\/blob\/master\/src\/main\/java\/rx\/internal\/operators\/OperatorPublish.java) which definitely doesn't return null on connec, but due to the half-finished project, I can't run all tests relying on it. \n"},{"date":"2015-03-09T11:35:00Z","author":"davidmoten","text":"Looks to me that `OperatorPublish` needs a good chunk of rework (#2810) and that the ReactiveStreams code could be basis for a rewrite. I'd be happy to have a go at this but haven't much time on my hands this week and anyway it might make more sense for @akarnokd to do it as he's so familiar with the subject already (and would probably do it in the blink of an eye).\n"},{"date":"2015-03-09T11:54:21Z","author":"akarnokd","text":"I'll add this to my todo list for this week.\n"},{"date":"2015-05-20T08:27:57Z","author":"akarnokd","text":"The operator has been rewritten so it never returns null. Closing.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-05-20T08:27:57Z","description":"This is outstanding work from #2774.  I can have a go at it next week if no-one in a rush.\n","id":"59932957","title":"OperatorPublish connect(connection) should not return null","opened_on":"2015-03-05T10:29:41Z","closed_by":"akarnokd"},{"number":"2799","reopenOn":null,"comments":[{"date":"2015-03-05T01:02:47Z","author":"benjchristensen","text":"One of us will take a look. Did this just start happening in 1.0.7?\n"},{"date":"2015-03-05T05:57:34Z","author":"wendigo","text":"I have came across this behaviour when .onBackpressureBlock() was introduced but I was not able to reproduce it nor fully understand under which circumstances  it can be observed. Now it seems that this minimal use case demonstrates this bug.\n"},{"date":"2015-03-05T06:22:27Z","author":"wendigo","text":"Note: lock happens on ArrayBlockingQueue in OperatorOnBackpressureBlock:58:\n\n```\nqueue.put(nl.next(t));\n```\n\nqueue contains maxQueueSize last produced elements just before it hangs.\n"},{"date":"2015-03-05T06:59:30Z","author":"wendigo","text":"Next trail: BackpressureDrainManager was requested for n = RxRingBuffer.size elements. When manager.drain() is called n+1 time requestedCount is equal to 0 in this and subsequent calls. No more request() calls were made.\n"},{"date":"2015-03-05T07:52:54Z","author":"zsxwing","text":"The problem is `.subscribeOn(Schedulers.newThread())`. Because the new thread is blocked, the new request (https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/operators\/OperatorSubscribeOn.java#L90) won't be scheduled to run.\n"},{"date":"2015-03-05T07:56:47Z","author":"wendigo","text":"If I use any other scheduler I will get exactly same behaviour. Also I don't understand why order of .observeOn\/.subscribeOn solves this problem.\n"},{"date":"2015-03-05T07:58:52Z","author":"zsxwing","text":"See #2653 \n\n>  You need to move the subscribeOn before the onBackpressureBlock.\n"},{"date":"2015-03-06T00:28:32Z","author":"benjchristensen","text":"`onBackpressureBlock` still feels so wrong. Perhaps it is too easy to break an app with it and is a failed experiment?\n\n@zsxwing @akarnokd Is there something we can do to make this less likely to break an app, or is the addition of `onBackpressureBlock` fundamentally a bad idea?\n"},{"date":"2015-03-06T07:07:58Z","author":"akarnokd","text":"Blocking and backpressure-continuations don't play well together: the same issue happened in #2466 with a different kind of blocking implementation. The solution is to move the subscribeOn before the blocking part (which can't be done if the very first source is the blocking one). We can put an emphasis on this fact in the javadoc of `onBackpressureBuffer` but if one isn't in control of the downstream, such downstream can introduce subscribeOn and the trouble is back. I'd say lets drop the operator for now.\n"},{"date":"2015-03-06T07:21:46Z","author":"zsxwing","text":"+1 removing it, since it's too easy to hang an app.\n"},{"date":"2015-05-20T08:43:35Z","author":"akarnokd","text":"Added PR #2970 which deprecates this operator, plus a javadoc update warning about the issue.\n"},{"date":"2015-08-28T17:10:38Z","author":"benjchristensen","text":"We deprecated this method. \n"}],"opened_by":"wendigo","reopen":false,"closed_on":"2015-08-28T17:10:38Z","description":"Given this piece of code:\n\n```\n        Observable.create(subscriber -> {\n            long counter = 0;\n\n            while (counter++ < Long.MAX_VALUE) {\n                System.out.println(\"onNext(\" + counter + \")\");\n\n                if (!subscriber.isUnsubscribed()) {\n                    subscriber.onNext(counter);\n                } else {\n                    break;\n                }\n\n                System.out.println(\"Subscribe.onNext(\" + value + \")\");\n            }\n        })\n        .onBackpressureBlock(2)\n        .subscribeOn(Schedulers.newThread())\n        .observeOn(Schedulers.computation())\n        .subscribe(System.out::println);\n```\n\nOn version 1.0.7 above code will hang on producing element on position RxRingBuffer.SIZE + 2 (maxQueueLength):\n\n```\n...\nafterOnNext(127)\nonNext(128)\nafterOnNext(128)\nSubscribe.onNext(128)\nonNext(129)\nafterOnNext(129)\nonNext(130)\nafterOnNext(130)\nonNext(131)\n```\n\nIf we switch order of subscribe\/observeOn (observeOn before subscribeOn) - it will work as expected :)\n\nAlso it will throw _MissingBackpressureException_ without onBackpressure\\* (as expected).\n","id":"59824175","title":"onBackpressureBlock() causes hangs","opened_on":"2015-03-04T16:40:15Z","closed_by":"benjchristensen"},{"number":"2788","reopenOn":null,"comments":[{"date":"2015-03-04T21:54:40Z","author":"benjchristensen","text":"Thanks @zsxwing It looks like a good change to me. Thread-safety seems fine as it is all within the WIP checks. \n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2015-03-04T21:54:42Z","description":"Fixed #2775 and #2596\n","id":"59445234","title":"Fix the bug that 'publish' will cache items when no subscriber","opened_on":"2015-03-02T06:53:37Z","closed_by":"benjchristensen"},{"number":"2779","reopenOn":null,"comments":[{"date":"2015-02-28T23:48:04Z","author":"davidmoten","text":"Thanks @akarnokd, sharp-eyed as ever. I used a final  AtomicReference to help with the == this check, is this the idiom you'd use in this situation?\n"},{"date":"2015-03-02T07:41:21Z","author":"akarnokd","text":"Thanks!\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-03-02T07:41:24Z","description":"See discussion in  #2774 \n\nChanges include \n- fix for #2774 just for `OperatorMulticast` (will do `OperatorPublish` in another PR once have sorted this one out)\n- made fields private that had default visibility\n- renamed `OnSubscribeMulticastTest` to `OperatorMulticastTest`\n- addressed a possible race condition that could provoke an IAE when `Observable.subscribe(sub)` is called with sub=null (unsubscription occurs between L144 and L145 on old code).\n","id":"59339718","title":"OperatorMulticast.connect(connection) should not return null","opened_on":"2015-02-28T12:16:22Z","closed_by":"akarnokd"},{"number":"2774","reopenOn":null,"comments":[{"date":"2015-02-26T08:55:56Z","author":"davidmoten","text":"I suspect that this is a documentation issue on the method because the source code seems to be quite deliberate in its treatment of this case (can code be deliberate?). No doubt an API expert will comment soon.\n"},{"date":"2015-02-26T09:09:37Z","author":"akarnokd","text":"I think it should return a subscription every time, but all places where `connect(Action1)` is implemented, the action is only called on the first subscription: see `OperatorMulticast` and `OperatorPublish`.\n"},{"date":"2015-02-28T00:30:10Z","author":"davidmoten","text":"I can have a look at making this happen if someone isn't working on it already.\n"},{"date":"2015-02-28T00:53:09Z","author":"akarnokd","text":"@davidmoten I'm working on something else so you can go ahead.\n"},{"date":"2015-03-05T06:06:18Z","author":"benjchristensen","text":"Was merged in https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2779\n"},{"date":"2015-03-05T10:25:36Z","author":"davidmoten","text":"`OperatorPublish` has not been done yet, I'll open up a new issue.\n"}],"opened_by":"lopespm","reopen":false,"closed_on":"2015-03-05T06:06:18Z","description":"Any posterior `connect()` calls to an already connected `ConnectableObservable` return `null`, but I believe the expected behaviour would be for it to return the subscription created for the first connection\n","id":"58924146","title":"ConnectableObservable.connect() returns a null subscription if already connected","opened_on":"2015-02-25T16:06:35Z","closed_by":"benjchristensen"},{"number":"2770","reopenOn":null,"comments":[{"date":"2015-02-24T07:16:56Z","author":"akarnokd","text":"Thanks!\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-02-24T07:16:59Z","description":"Use `BackpressureUtils.getAndAddRequest(requested, n)` instead of `requested.getAndAdd(n)` so that an overflow check takes place. Includes a unit test that failed on original code (but passes with this PR).\n","id":"58673579","title":"OperatorOnBackpressureDrop request overflow check","opened_on":"2015-02-24T00:23:53Z","closed_by":"akarnokd"},{"number":"2759","reopenOn":null,"comments":[{"date":"2015-02-20T05:45:28Z","author":"davidmoten","text":"Thanks @akarnokd, I've made the change and squashed commits.\n"},{"date":"2015-02-20T21:03:47Z","author":"davidmoten","text":"Replaced tabs with spaces, added @Experimental annotation to new overload and fixed typo in javadoc, squashed commits\n"},{"date":"2015-02-21T04:44:52Z","author":"benjchristensen","text":"This seems reasonable to me. I don't use 'using' so trust the conversation you've had to address the necessary functionality. Reading through the other PR this does seem necessary and I agree that 'unsafeSubscribe' is appropriate for this. \n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-02-21T04:44:56Z","description":"See #2604 where it was discovered that `Observable.using` used `subscribe` instead of `unsafeSubscribe` which provoked a race condition leading to an IllegalArgumentException from the merge operator.\n\nThis PR uses `unsafeSubscribe` and adds an overload for `using` to optionally dispose of resources eagerly (just before completion or error). The use case for this is a _synchronous_ observable where a downstream operation wants to reuse a resource (but because the observable is synchronous the resource cannot get disposed till the downstream completes).\n\nUnit tests included.\n","id":"58168559","title":"Observable.using should use unsafeSubscribe and enable eager disposal","opened_on":"2015-02-19T05:09:23Z","closed_by":"benjchristensen"},{"number":"2656","reopenOn":null,"comments":[{"date":"2015-02-16T21:55:38Z","author":"benjchristensen","text":"Thanks for the report. \n"},{"date":"2015-03-05T06:10:48Z","author":"benjchristensen","text":"@abersnaze Since this probably affects work you're doing as well, can you take a look at what we need to fix here? It will be anything using the internal ScalarSynchronousObservable optimization I think. \n"},{"date":"2015-03-05T17:09:57Z","author":"abersnaze","text":"sure.\n"},{"date":"2015-08-13T00:53:36Z","author":"akarnokd","text":"What is the status of this issue? I've lost track of the proposed changes to `ScalarSynchronousObservable`.\n"},{"date":"2016-05-21T08:55:50Z","author":"akarnokd","text":"See #3958.\n"},{"date":"2016-05-23T23:15:57Z","author":"zsxwing","text":"Closing via #3958\n"}],"opened_by":"ronanM","reopen":false,"closed_on":"2016-05-23T23:15:57Z","description":"When using rx.Observable.just(T) the RxJavaObservableExecutionHook is not call.\n\nThis is not like other just(T,...) that call rx.Observable.from(Iterable<? extends T>).\n","id":"57658654","title":"just(T) : RxJavaObservableExecutionHook not called","opened_on":"2015-02-13T21:49:39Z","closed_by":"zsxwing"},{"number":"2655","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-02-16T13:30:53Z","description":"Fix for issue #2654.\n\nBy calling the `super(child)` in SwitchSubscriber's constructor, the upstream's merge producer overwrote the producer placed by the SwitchOnNext operator thus any downstream request went into the upstream an not into the currently active observable.\n","id":"57652343","title":"SwitchOnNext: fix upstream producer replacing the ops own producer","opened_on":"2015-02-13T20:51:33Z","closed_by":"akarnokd"},{"number":"2654","reopenOn":null,"comments":[{"date":"2015-02-13T18:16:47Z","author":"akarnokd","text":"Could you check these with RxJava 1.0.6? We've fixed a bunch of share- and merge-related bugs since 1.0.4.\n"},{"date":"2015-02-13T18:24:30Z","author":"angrycamel","text":"Done, no change\n\n<pre>\n18:22:07.723 [RxComputationThreadPool-2] INFO  MinimalRepro - Value: Hello 125\n18:22:07.744 [RxComputationThreadPool-2] INFO  MinimalRepro - Value: Hello 126\n18:22:10.343 [RxComputationThreadPool-2] INFO  MinimalRepro - Error\nrx.exceptions.MissingBackpressureException: null\n    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:349) ~[rxjava-1.0.6.jar:1.0.6]\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.enqueue(OperatorMerge.java:721) [rxjava-1.0.6.jar:1.0.6]\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:698) [rxjava-1.0.6.jar:1.0.6]\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:586) [rxjava-1.0.6.jar:1.0.6]\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55) [rxjava-1.0.6.jar:1.0.6]\n<\/pre>\n\n_(rxjava 1.0.6, rxscala 0.23.1, scala 2.11.4)_\n"},{"date":"2015-02-13T20:58:02Z","author":"akarnokd","text":"It's a bug in switch. Could you check if #2655 works for you?\n"},{"date":"2015-02-14T12:28:16Z","author":"angrycamel","text":"Yes - it works for me. Nice work!\n"}],"opened_by":"angrycamel","reopen":false,"closed_on":"2015-02-22T18:28:28Z","description":"The first example uses switchMap and fails with the exception below after 128 events, whereas the second example uses flatMap and does not fail. The third example shows that switchMap does not fail if the nested observable is not a product of of the merge operator. \n\nHowever the other variable is the share() on the mainObservable. _Without this, Example 1 works_ (I have called this case Example 4). So you might wonder if it has anything to do with switchMap at all - maybe just sharing a merged observable will also fail (Example 5) - however, this case works fine.\n\nSo we're left with \"sharing a switchMap which produces its result via merge, will stop producing after 128 events\". But why?\n\n_(using rxjava 1.0.4, rxscala 0.23.1, scala 2.11.4)_\n\n<pre>\nrx.exceptions.MissingBackpressureException: null\n    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:338) ~[rxjava-1.0.4.jar:1.0.4]\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.enqueue(OperatorMerge.java:680) [rxjava-1.0.4.jar:1.0.4]\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:657) [rxjava-1.0.4.jar:1.0.4]\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:545) [rxjava-1.0.4.jar:1.0.4]\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55) [rxjava-1.0.4.jar:1.0.4]\n<\/pre>\n\n_Example 1 : This Fails After 128 events_\n\n``` scala\ndef main(args:Array[String]) = {\n    val oneItemOnly = (Observable.just(\"Hello\").merge(Observable.never))\n    val mainObservable = oneItemOnly.switchMap {\n      v => \n        val a = Observable.just(v)\n        val b = Observable.interval(20 milliseconds).map(i => s\"$v $i\")\n        a.merge(b)\n    }\n    .share\n\n    val sub = mainObservable.subscribe( \n      (v) => LOG.info(s\"Value: $v\"),\n      (e) => LOG.info(s\"Error\",e),\n      () => LOG.info(s\"Done\")\n    )\n    Observable.never.toBlocking.first\n}\n```\n\n_Example 2 : This Works Fine_\nNote this is precisely the same code as Example 1, except I've changed  switchMap to flatMap\n\n``` scala\ndef main(args:Array[String]) = {\n    val oneItemOnly = (Observable.just(\"Hello\").merge(Observable.never))\n    val mainObservable = oneItemOnly.flatMap {\n      v => \n        val a = Observable.just(v)\n        val b = Observable.interval(20 milliseconds).map(i => s\"$v $i\")\n        a.merge(b)\n    }\n    .share\n\n    val sub = mainObservable.subscribe( \n      (v) => LOG.info(s\"Value: $v\"),\n      (e) => LOG.info(s\"Error\",e),\n      () => LOG.info(s\"Done\")\n    )\n    Observable.never.toBlocking.first\n}\n```\n\n_Example 3 : This also works fine_\nChanging example 1 again but this time not using merge within the switchMap.\n\n``` scala\ndef main(args:Array[String]) = {\n    val oneItemOnly = (Observable.just(\"Hello\").merge(Observable.never))\n    val mainObservable = oneItemOnly.switchMap {\n      v => \n        Observable.interval(20 milliseconds).map(i => s\"$v $i\")\n    }\n    .share\n\n    val sub = mainObservable.subscribe( \n      (v) => LOG.info(s\"Value: $v\"),\n      (e) => LOG.info(s\"Error\",e),\n      () => LOG.info(s\"Done\")\n    )\n    Observable.never.toBlocking.first\n}\n```\n\n_Example 4 : This also works fine_\nChanging example 1 again but this time not share()ing the mainObservable\n\n``` scala\ndef main(args:Array[String]) = {\n    val oneItemOnly = (Observable.just(\"Hello\").merge(Observable.never))\n    val mainObservable = oneItemOnly.switchMap {\n      v => \n        val a = Observable.just(v)\n        val b = Observable.interval(20 milliseconds).map(i => s\"$v $i\")\n        a.merge(b)\n    }\n\n    val sub = mainObservable.subscribe( \n      (v) => LOG.info(s\"Value: $v\"),\n      (e) => LOG.info(s\"Error\",e),\n      () => LOG.info(s\"Done\")\n    )\n    Observable.never.toBlocking.first\n}\n```\n\n_Example 5 : This also works fine_\nExperiment to find out if the problem is simply sharing a merged observable.... seems not\n\n``` scala\ndef main(args:Array[String]) = {\n    val mainObservable = Observable.just(1).merge(Observable.interval(20 milliseconds))\n        .share\n    val sub = mainObservable.subscribe( \n      (v) => LOG.info(s\"Value: $v\"),\n      (e) => LOG.info(s\"Error\",e),\n      () => LOG.info(s\"Done\")\n    )\n    Observable.never.toBlocking.first\n}\n```\n","id":"57633202","title":"sharing a switchMap which produces its result via merge, will stop producing after 128 events","opened_on":"2015-02-13T18:08:43Z","closed_by":"angrycamel"},{"number":"2648","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-02-11T21:12:39Z","description":"Fixes #2647 issue with TakeWhile.\n","id":"57287188","title":"TakeWhile: don't unsubscribe downstream.","opened_on":"2015-02-11T08:09:03Z","closed_by":"benjchristensen"},{"number":"2647","reopenOn":null,"comments":[{"date":"2015-02-10T21:12:33Z","author":"benjchristensen","text":"\/cc @abersnaze This may be related to the issue you're hunting.\n"},{"date":"2015-02-10T21:23:39Z","author":"benjchristensen","text":"It is not related to `interval` as I can replicate without it:\n\n``` java\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\n\npublic class IntervalTakeWhileExample {\n\n    public static void main(String... args) {\n        Observable\n                .<Integer>create(s -> {\n                    s.onNext(0);\n                    try {\n                        Thread.sleep(5);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                    s.onNext(1);\n                    s.onCompleted();\n                })\n                .doOnEach(a -> System.out.println(\"A ==> \" + a))\n                .takeWhile(aLong -> aLong < 1)\n                .doOnEach(b -> System.out.println(\"B ==> \" + b))\n                .flatMap(aLong -> {\n                    return Observable\n                            .timer(30, TimeUnit.MILLISECONDS)\n                            .doOnUnsubscribe(() -> System.out.println(\"unsubscribed timer?\"))\n                            .doOnEach(c -> System.out.println(\"C ==> \" + c))\n                            .map(aLong1 -> aLong1 + aLong);\n                })\n                .doOnEach(d -> System.out.println(\"D ==> \" + d))\n                .toBlocking().forEach(System.out::println);\n    }\n}\n```\n\nHowever, if I change `takeWhile` to `take(1)` it works fine, so it may be related to `takeWhile`. But `merge` is always a candidate for this and my first thought. \n"},{"date":"2015-02-10T22:12:04Z","author":"bpitman","text":"It's not just takeWhile.  It also fails if replace:\n.takeWhile(aLong -> aLong < 1)\nwith:\nflatMap(aLong -> (aLong < 1) ? Observable.just(i) : Observable.empty)\n"},{"date":"2015-02-13T00:42:18Z","author":"benjchristensen","text":"The `takeWhile` issue was fixed in 1.0.6.\n"},{"date":"2015-02-13T00:44:55Z","author":"benjchristensen","text":"> flatMap(aLong -> (aLong < 1) ? Observable.just(i) : Observable.empty)\n\nI don't understand this one. In the code example, what is variable `i`?\n\nThis works in 1.0.6:\n\n``` java\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\n\npublic class IntervalTakeWhileExample {\n\n    public static void main(String... args) {\n        Observable\n                .<Integer> create(s -> {\n                    s.onNext(0);\n                    try {\n                        Thread.sleep(5);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                    s.onNext(1);\n                    s.onCompleted();\n                })\n                .doOnEach(a -> System.out.println(\"A ==> \" + a))\n                \/\/                .takeWhile(aLong -> aLong < 1)\n                .flatMap(aLong -> (aLong < 1) ? Observable.just(aLong) : Observable.empty())\n                .doOnEach(b -> System.out.println(\"B ==> \" + b))\n                .flatMap(aLong -> {\n                    return Observable\n                            .timer(30, TimeUnit.MILLISECONDS)\n                            .doOnUnsubscribe(() -> System.out.println(\"unsubscribed timer?\"))\n                            .doOnEach(c -> System.out.println(\"C ==> \" + c))\n                            .map(aLong1 -> aLong1 + aLong);\n                })\n                .doOnEach(d -> System.out.println(\"D ==> \" + d))\n                .toBlocking().forEach(System.out::println);\n    }\n}\n```\n"},{"date":"2015-11-22T02:45:17Z","author":"felipecsl","text":"Is this issue still outstanding with `flatMap()`? I'm seeing a similar behavior where I never get a terminal event after a flatMap\n"},{"date":"2015-11-22T09:02:00Z","author":"akarnokd","text":"@felipecsl Could you post a small code example?\n"},{"date":"2015-11-23T19:21:14Z","author":"felipecsl","text":"I'll try to write a small sample to reproduce the issue\n"},{"date":"2015-11-23T20:19:58Z","author":"felipecsl","text":"Never mind, can't reproduce anymore. Was probably doing something stupid :)\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2015-02-11T21:12:39Z","description":"The following code hangs forever as it doesn't emit a terminal event:\n\n``` java\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\n\npublic class IntervalTakeWhileExample {\n\n    public static void main(String... args) {\n        Observable\n                .interval(1, TimeUnit.MILLISECONDS)\n                .doOnEach(a -> System.out.println(\"A ==> \" + a))\n                .takeWhile(aLong -> aLong < 1)\n                .doOnEach(b -> System.out.println(\"B ==> \" + b))\n                .flatMap(aLong -> {\n                    return Observable\n                            .timer(30, TimeUnit.MILLISECONDS)\n                            .doOnUnsubscribe(() -> System.out.println(\"unsubscribed timer?\"))\n                            .doOnEach(c -> System.out.println(\"C ==> \" + c))\n                            .map(aLong1 -> aLong1 + aLong);\n                })\n                .doOnEach(d -> System.out.println(\"D ==> \" + d))\n                .toBlocking().forEach(System.out::println);\n    }\n}\n```\n\nThis emits:\n\n```\nA ==> [rx.Notification@f6adcf11 OnNext 0]\nB ==> [rx.Notification@f6adcf11 OnNext 0]\nA ==> [rx.Notification@f6adcf12 OnNext 1]\nB ==> [rx.Notification@5b2cf4de OnCompleted]\nunsubscribed timer?\n```\n","id":"57237234","title":"flatMap doesn't propagate onComplete with unsubscribe of child","opened_on":"2015-02-10T21:11:57Z","closed_by":"benjchristensen"},{"number":"2642","reopenOn":null,"comments":[{"date":"2015-02-09T13:46:23Z","author":"akarnokd","text":"It is functionally mergeable, but you could have used `MultipleAssignmentSubscription s = ...` and saved an import.\n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2015-02-10T07:57:55Z","description":"There is a potential memory leak in `schedulePeriodically` that may keep a reference to `action` after `unsubscribe`. \n\nBecause `mas.set` is called after `schedule`,  it may replace a new Subscription (created in `recursiveAction`) with the old one. Therefore, `unsubscribe` won't be able to unsubscribe the new Subscription and will keep the reference to `action` until the period time elapses.\n\nThis PR fixed it by calling `mas.set` before `schedule`.\n","id":"57024721","title":"Fix a potential memory leak in schedulePeriodically","opened_on":"2015-02-09T12:31:53Z","closed_by":"akarnokd"},{"number":"2630","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-02-06T11:55:38Z","description":"Rebased #2600.\n","id":"56802467","title":"Cast back Observer to Subscriber if passed to subscribe(Observer)","opened_on":"2015-02-06T11:44:43Z","closed_by":"akarnokd"},{"number":"2604","reopenOn":null,"comments":[{"date":"2015-02-05T00:17:45Z","author":"benjchristensen","text":"Did this happen with version 1.0.5? \n"},{"date":"2015-02-05T00:25:47Z","author":"davidmoten","text":"yes 1.0.5\n"},{"date":"2015-02-05T00:26:51Z","author":"davidmoten","text":"I've updated this issue. No error is occuring in upstream. The only error occuring is the IllegalStateException.\n"},{"date":"2015-02-05T00:44:15Z","author":"benjchristensen","text":"_sigh_ I had hoped we'd fixed this issue in 1.0.5. \n"},{"date":"2015-02-05T00:51:37Z","author":"davidmoten","text":"not sure what fixes went through for that. i see that  #1963 was closed but didn't notice record of the resolution (like a PR number).\n"},{"date":"2015-02-05T00:55:38Z","author":"davidmoten","text":"In #2584 @akarnokd mentions that there is still a small window where this can happen. I imagine he'll enlighten us.\n"},{"date":"2015-02-05T07:17:57Z","author":"akarnokd","text":"The only fix would be not to throw but just exit. We can't distinguish between an upstream ignoring unsubscription and an upstream pushing just after an unsubscription happened.\n"},{"date":"2015-02-05T08:36:43Z","author":"davidmoten","text":"So in my case, I wouldn't expect what you describe because the operators should be consuming all of the input stream. None of the observables should be interrupted by unsubscription before completion. Do you have an alternative theory? \n"},{"date":"2015-02-05T09:23:29Z","author":"akarnokd","text":"Something is unsubscribing because otherwise the queue wouldn't be null.\n"},{"date":"2015-02-05T09:51:31Z","author":"davidmoten","text":"righto, I'll have a close look tomorrow\n"},{"date":"2015-02-06T03:12:06Z","author":"davidmoten","text":"Got it. I think its an `OperatorMerge` bug. The unsubscribe is originating from upstream due to the use of `using`. Here is a failing unit test for your debugging pleasure. \n\n``` java\n    @Test(timeout = 3000)\n    public void testMergeEagerUnsubscribeFromUpstream() {\n        Func0<Object> resourceFactory = new Func0<Object>() {\n            @Override\n            public Object call() {\n                return new Object();\n            }\n        };\n        Func1<Object, Observable<Integer>> observableFactory = new Func1<Object, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> call(Object o) {\n                return Observable.range(1, 1000000);\n            }\n        };\n        Action1<Object> disposeAction = new Action1<Object>() {\n            @Override\n            public void call(Object t) {\n                \/\/ do nothing\n            }\n        };\n        Observable.using(resourceFactory, observableFactory, disposeAction)\n                .toList()\n                .flatMap(new Func1<List<Integer>, Observable<Integer>>() {\n                    @Override\n                    public Observable<Integer> call(List<Integer> list) {\n                        return Observable.from(list).subscribeOn(\n                                Schedulers.computation());\n                    }\n                }).count().toBlocking().single();\n    }\n```\n"},{"date":"2015-02-06T09:50:03Z","author":"akarnokd","text":"Thanks. This is a nasty one. `using` does `subscribe()` on the source which then wraps the downstream into a `SafeSubscriber` which then cancels all work stared by merge immediately after toList sends onCompleted(). So either `using` should do `unsafeSubscribe` or `toList()` should break the chaining of subscribers via the Subscriber constructor.\nThis may affect other operators that do something async after an onError and onCompleted.\n\n``` java\nreturn new Subscriber<T>(child) { .. }\n```\n\nshould become something like this:\n\n``` java\nclass InnerSubscriber<T> extends Subscriber<T> {\n    void requestMore(long n) {\n        request(n);\n    }\n    \/\/ ...\n}\nInnerSubscriber<T> s = new InnerSubscriber<T>();\nchild.setProducer(s::requestMore);\nchild.add(s);\nreturn s;\n```\n"},{"date":"2015-02-06T10:26:30Z","author":"davidmoten","text":"`unsafeSubscribe` in `using` sounds alright to me. Any reasons preventing us doing that?\n"},{"date":"2015-02-09T21:49:51Z","author":"davidmoten","text":"I've rewritten `OnSubscribeUsing` for my applications use so this problem doesn't happen.  I use `unsafeSubscribe` and optional dispose on termination event (which I always set to true) in addition to unsubscription dispose though there is protection to ensure that disposal only occurs once. This sorts the problem for me.  If people are happy with this direction as opposed to handling things downstream instead I'll put in a PR (and write the as yet unwritten unit tests).\n\n``` java\npublic final class OnSubscribeUsing2<T, Resource> implements OnSubscribe<T> {\n\n    private final Func0<Resource> resourceFactory;\n    private final Func1<? super Resource, ? extends Observable<? extends T>> observableFactory;\n    private final Action1<? super Resource> dispose;\n    private final boolean disposeEagerly;\n\n    public OnSubscribeUsing2(\n            Func0<Resource> resourceFactory,\n            Func1<? super Resource, ? extends Observable<? extends T>> observableFactory,\n            Action1<? super Resource> dispose, boolean disposeEagerly) {\n        this.resourceFactory = resourceFactory;\n        this.observableFactory = observableFactory;\n        this.dispose = dispose;\n        this.disposeEagerly = disposeEagerly;\n    }\n\n    @Override\n    public void call(Subscriber<? super T> subscriber) {\n\n        try {\n            \/\/ create the resource\n            final Resource resource = resourceFactory.call();\n            \/\/ create an action that disposes only once\n            final Action0 disposeOnceOnly = createOnceOnlyDisposeAction(resource);\n            \/\/ dispose on unsubscription\n            subscriber.add(Subscriptions.create(disposeOnceOnly));\n            \/\/ create the observable\n            final Observable<? extends T> source = observableFactory\n            \/\/ create the observable\n                    .call(resource);\n            final Observable<? extends T> observable;\n            \/\/ supplement with on termination disposal if requested\n            if (disposeEagerly)\n                observable = source\n                \/\/ dispose on completion or error\n                        .doOnTerminate(disposeOnceOnly);\n            else\n                observable = source;\n            try {\n                \/\/ start\n                observable.unsafeSubscribe(subscriber);\n            } catch (Throwable e) {\n                Throwable disposeError = disposeEagerlyIfRequested(disposeOnceOnly);\n                if (disposeError != null)\n                    subscriber.onError(new CompositeException(Arrays.asList(e,\n                            disposeError)));\n                else\n                    \/\/ propagate error\n                    subscriber.onError(e);\n            }\n        } catch (Throwable e) {\n            \/\/ then propagate error\n            subscriber.onError(e);\n        }\n    }\n\n    private Throwable disposeEagerlyIfRequested(final Action0 disposeOnceOnly) {\n        if (disposeEagerly)\n            try {\n                disposeOnceOnly.call();\n                return null;\n            } catch (Throwable e) {\n                return e;\n            }\n        else\n            return null;\n    }\n\n    private Action0 createOnceOnlyDisposeAction(final Resource resource) {\n        return new Action0() {\n\n            final AtomicBoolean disposed = new AtomicBoolean(false);\n\n            @Override\n            public void call() {\n                \/\/ only want dispose called once\n                if (disposed.compareAndSet(false, true))\n                    dispose.call(resource);\n            }\n        };\n    }\n}\n```\n"},{"date":"2015-03-11T14:03:37Z","author":"akarnokd","text":"I'm closing this as the related PR has been merged some days ago.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-03-11T14:03:37Z","description":"With 1.0.5, I'm getting an `IllegalStateException` from `OperatorMerge`. This is repeatable for me but involves a big input data set being processed in chunks using flatMap\/onSubscribe so I can't give you a quick test case yet. Hopefully just this description is enough otherwise I'll try and distill a test. I think it is happening close to completion.\n\n```\njava.lang.IllegalStateException: This instance has been unsubscribed and the queue is no longer usable.\n        at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:346)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.enqueue(OperatorMerge.java:721)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:698)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:586)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.handleScalarSynchronousObservableWithRequestLimits(OperatorMerge.java:280)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.handleScalarSynchronousObservable(OperatorMerge.java:243)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:176)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:120)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.handleScalarSynchronousObservableWithRequestLimits(OperatorMerge.java:280)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.handleScalarSynchronousObservable(OperatorMerge.java:243)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:176)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:120)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n        at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainScalarValueQueue(OperatorMerge.java:396)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:343)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.access$500(OperatorMerge.java:120)\n        at rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:549)\n        at rx.Subscriber.request(Subscriber.java:130)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:350)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.access$500(OperatorMerge.java:120)\n        at rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:549)\n        at rx.Subscriber.request(Subscriber.java:130)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:350)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.access$500(OperatorMerge.java:120)\n        at rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:549)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1$1$1.call(OperatorSubscribeOn.java:94)\n        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:47)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\nCaused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: au.gov.amsa.ais.Timestamped.class\n        at rx.exceptions.OnErrorThrowable.addValueAsLastCause(OnErrorThrowable.java:98)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:58)\n        ... 27 more\n```\n","id":"56607492","title":"OperatorMerge - RxRingBuffer throws IllegalStateException again","opened_on":"2015-02-05T00:01:09Z","closed_by":"akarnokd"},{"number":"2600","reopenOn":null,"comments":[{"date":"2015-02-05T20:44:00Z","author":"akarnokd","text":"Thanks. Once the master build is fixed, I'm going to merge this.\n"},{"date":"2015-02-06T11:06:36Z","author":"mttkay","text":":+1: \n"},{"date":"2015-02-06T11:45:31Z","author":"akarnokd","text":"Redone in #2630 because of merge conflicts.\n"}],"opened_by":"mttkay","reopen":false,"closed_on":"2015-02-06T11:45:31Z","description":"Fixes https:\/\/github.com\/ReactiveX\/RxJava\/issues\/2599\n","id":"56532237","title":"Make sure we keep a Subscriber\u2019s subscription when passed as Observer","opened_on":"2015-02-04T14:24:59Z","closed_by":"akarnokd"},{"number":"2599","reopenOn":null,"comments":[{"date":"2015-02-04T14:03:20Z","author":"akarnokd","text":"An `instanceof` test shoud do the trick.\n"},{"date":"2015-02-04T14:13:17Z","author":"mttkay","text":"That sums it up nicely. :-)\n"},{"date":"2015-03-11T13:52:17Z","author":"akarnokd","text":"Closing as the requested change was merged via #2630.\n"}],"opened_by":"mttkay","reopen":false,"closed_on":"2015-03-11T13:52:17Z","description":"So this might be a debatable one, but I thought it's worth pointing out because it really leads to surprising and (I think) unexpected behavior on one of the key methods on Observable (`subscribe`).\n\nTo illustrate, consider this:\n\n``` java\n    @Test\n    public void shouldUnsubscribe() {\n        TestSubscriber subscriber = new TestSubscriber();\n        final Subscription subscription = Observable.just(\"item\").subscribe(subscriber);\n        subscription.unsubscribe();\n        expect(subscriber.isUnsubscribed()).toBeTrue();\n    }\n\n```\n\nThis test passes. If I change line 2 of the test to this:\n\n``` java\n        ...\n        final Subscription subscription = Observable.just(\"item\").subscribe((Observer) subscriber);\n        ...\n```\n\nThe test fails. The reason is the widening cast to `Observer`: this causes an overload of `subscribe` to be called which wraps away the observer into another Subscriber, without checking whether the observer isn't also a Subscriber and therefore has a Subscription that must be unsubscribed from. Since it uses the default constructor of Subscriber to perform the composition, no link will be established between the parent and child subscription, thus changing the behavior of the composition. \n\nI find this to be very surprising. The example is contrived, but this widening cast is actually very likely to happen whenever you're keeping a list of observers somewhere that can either be Subscribers or Observers. Doesn't this also mean that it will lead to very subtle bugs, because we're effectively disregarding the Subscription wrapped by the subscriber, which may want to call important cleanup logic in `unsubscribe`?\n\nA simple but arguably not pretty fix for this would be to change the `subscribe` overload in a manner where it first tests whether the Observer is actually a Subscriber, and downcasts it safely, then only wrapping it in a Subscriber if necessary.\n","id":"56524022","title":"Widening cast from Subscriber to Observer changes behavior of subscription chain","opened_on":"2015-02-04T13:08:16Z","closed_by":"akarnokd"},{"number":"2596","reopenOn":null,"comments":[{"date":"2015-02-04T08:04:15Z","author":"FinalVersion","text":"I forgot to mention I'm using rxjava-1.0.4\n"},{"date":"2015-02-04T08:20:34Z","author":"akarnokd","text":"Behaves the same with 1.0.5. \n\nWhat happens in case 1 is that there are practically two clients to pub1: your subscriber and the second publish(). Because publish() does backpressure, it can only request more from the source range if all of its child subscribers have consumed the values so far and have requested more: pub2 buffered the initial burst and stopped responding and your subscriber consumed all 128 elements and is ready for more, but can't get through.\n\nThis is related to case 2 where you experience some replay: due to backpressure, publish() will buffer up to 128 elements regardless if there is anyone to observe it or not (instead what you'd expect from multicasting through a PublishSubject). \n\n\/cc @benjchristensen \n\nIn order to fix these, publish() without clients should drop events, but has the drawback that in case like the code above, sources may burst through all of its values before subscribers have any chance of subscribing to it.\n"},{"date":"2015-02-04T08:54:04Z","author":"FinalVersion","text":"In case 1, it would be very surprising to some observer A that another observer B which A may not even know would affect its observation of the source. Would there be any better way of handling backpressure of publish()? I have been suffering from this for days suspecting a deadlock situation in my code...\n"},{"date":"2015-02-04T12:52:32Z","author":"mttkay","text":"Just found this after posting on the mailing list, since we were running into the same issue with Publish behaving like Replay: https:\/\/groups.google.com\/forum\/#!topic\/rxjava\/tTly_OZyaIs\n\nI find this very confusing, as it seems to violate the behavioral contract? Unless I misunderstood the contract as more being one of minimum guarantees and \"maybe replays\" versus \"always replays\".\n\nWhat this means in practice is that unless your sequences have more than 128 items (which is an implementation detail), Publish and Replay behave the same. I wonder if this is in line with the operators on .NET, which don't support backpressure AFAIK?\n"},{"date":"2015-02-04T18:41:14Z","author":"benjchristensen","text":"I think I know what the issue is. It works fine when a subscriber is subscribed, but if it is just connected but no subscribers then it will indeed buffer, which is wrong, as it thinks that \"zero subscribers\" means it is backpressured.\n\nHere are some examples of it working correctly when connect is immediately followed by a subscribe:\n\n``` java\n        TestScheduler scheduler = Schedulers.test();\n        ConnectableObservable<Long> p = Observable.interval(1, TimeUnit.SECONDS, scheduler).publish();\n\n        p.forEach(i -> System.out.println(\"A -> \" + i));\n        p.connect();\n\n        scheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n\n        p.forEach(i -> System.out.println(\"B -> \" + i));\n\n        scheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n```\n\nThis will emit:\n\n```\nA -> 0\nA -> 1\nA -> 2\nB -> 2\nA -> 3\nB -> 3\n```\n\nNote that B only receives 2 and 3, not 0 and 1.\n\nHere is one with a slow consumer that joins first, then a fast one later:\n\n``` java\n    private static void slowConsumers() {\n        TestScheduler scheduler = Schedulers.test();\n        ConnectableObservable<Long> p = Observable.interval(1, TimeUnit.SECONDS, scheduler).publish();\n\n        p.observeOn(Schedulers.io()).map(i -> {\n            try {\n                Thread.sleep(1000);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return i;\n        }).forEach(i -> System.out.println(\"A -> \" + i));\n        p.connect();\n\n        scheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n\n        p.forEach(i -> System.out.println(\"B -> \" + i));\n\n        scheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n```\nB -> 2\nB -> 3\nA -> 0\nA -> 1\nA -> 2\nA -> 3\n```\n\nB still only gets the 2. \n\nWhere it goes wrong is at this line of code: https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/operators\/OperatorPublish.java#L357\n\nIt sees having zero subscribers as being \"backpressured\", but that is not valid in this case. It should just drop the data if there are no subscribers. \n"},{"date":"2015-02-07T11:18:03Z","author":"FinalVersion","text":"@benjchristensen  Another related problem:\n\n``` Java\n        Observable<Integer> source = Observable.range(0, 1000);\n        Observable<Integer> shared = source.share();\n        ConnectableObservable<Integer> published = shared.publish();\n        published.subscribe(new PrintObserver<Integer>());\n        published.connect();\n```\n\nI expected to see 0 to 999, but again it gives me only 0 to 127.\nIf case 1 is caused by mistaking 'no subscriber' as 'backpressure', what's wrong with this one? I can see there is exact one subscriber for each step in source -> share() -> publish() -> PrintObserver.\n"},{"date":"2015-02-09T10:45:47Z","author":"akarnokd","text":"@FinalVersion the share + publish example works with master for me.\n"},{"date":"2015-02-10T03:57:21Z","author":"FinalVersion","text":"@akarnokd Thanks. It works since 1.0.5. I didn't update in time.\n"},{"date":"2015-03-11T14:05:53Z","author":"akarnokd","text":"There were fixes merged relating to this issue. Could you check if 1.0.8 works for you and if so, close the issue?\n"},{"date":"2015-03-11T16:10:45Z","author":"FinalVersion","text":"Case 2 is good now. However Case 1 still gives the same result. I suppose that pub2 has no subscriber and should not put backpressure on pub1.\n"},{"date":"2015-05-20T09:12:56Z","author":"akarnokd","text":"The `publish()` operator has been completely rewritten. Could you see if it works for you?\n"},{"date":"2015-05-20T11:54:27Z","author":"FinalVersion","text":"All the cases are correct now in my test. \n"},{"date":"2015-05-20T11:55:10Z","author":"akarnokd","text":"Thanks for the confirmation.\n"}],"opened_by":"FinalVersion","reopen":false,"closed_on":"2015-05-20T11:54:27Z","description":"I have experienced some unexpected behaviors of publish() and connect() in my project. \nHopefully it's not my misunderstanding since I'm a newbie to Rx.\n\nI will use an Observer that simply print onNext, onError, onCompleted.\n\n``` Java\n    public static class PrintObserver<T> implements Observer<T> {\n        @Override\n        public void onCompleted() {\n            System.out.println(\"onCompleted\");\n        }\n        @Override\n        public void onError(Throwable e) {\n            System.out.println(\"onError: \" + e);\n        }\n        @Override\n        public void onNext(T t) {\n            System.out.println(\"onNext: \" + t);\n        }\n    }\n```\n\nThe simplified scenarios are as follows:\n\n1) **ConnectableObservable stops emitting without unsubscribing from source.**\n\n``` Java\n    Observable<Integer> source = Observable.range(0, 1000);\n    ConnectableObservable<Integer> pub1 = source.publish();\n    ConnectableObservable<Integer> pub2 = pub1.publish();\n    pub2.connect();\n    \/\/pub2.subscribe();\n    pub1.subscribe(new PrintObserver<Integer>());\n    pub1.connect();\n```\n\nI expected the output to be 'onNext: 0' up to 'onNext: 999', then 'onCompleted', but it stops at onNext: 127 in my test.\nBut if I uncomment `\/\/pub2.subscribe();`, namely have something subscribe to pub2, it will work as expected. Or else if I do not `pub2.connect()`, it will also work.\n\nThe code may looks silly, but it may not if I put some operator which does expensive computations before publishing as pub2. BTW, what I want is to do some intermediate computations only once if pub2 is subscribed by many subscribers or piped to different downstream operators. If there're better ways to do that, please kindly let me know.\n\n2) **`publish()` behaves like `replay()`**\n\n``` Java\n    try {\n        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS).take(10);\n        ConnectableObservable<Long> pub = source.publish();\n        pub.connect();\n\n        Thread.sleep(2500);\n\n        pub.subscribe(new PrintObserver<Long>());\n\n        Thread.sleep(2000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n```\n\nI expected that after `pub.connect()`, source will start emitting, and when `pub` is subscribed after 2.5 sec, 'onNext: 0' and 'onNext: 1' will be missed by this subscriber. However, I got them all together at 2.5 sec, and from 3rd second, I got the following onNext: 2 and so on. This looks like a `replay()` behavior to me. \n","id":"56491804","title":"Unexpected behavior of publish() and connect()","opened_on":"2015-02-04T07:51:34Z","closed_by":"FinalVersion"},{"number":"2593","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-02-04T05:50:22Z","description":"Could also fix #2588 but can't be sure because the test created from the example app works for me.\n","id":"56454819","title":"Zip: emit onCompleted without waiting for request + avoid re-reading fields","opened_on":"2015-02-03T23:21:14Z","closed_by":"benjchristensen"},{"number":"2590","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-02-03T21:10:53Z","description":"Should fix issue reported in #2588.\n\nPs. What are the odds two bug reports issued so close to each other have the same cause and same fix? @davidmoten the `BackpressureUtils` was a fantastic idea.\n","id":"56429334","title":"Zip: fixed unbounded downstream requesting above Long.MAX_VALUE","opened_on":"2015-02-03T20:06:15Z","closed_by":"benjchristensen"},{"number":"2589","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-02-03T21:11:55Z","description":"Reported in #2587.\n","id":"56427185","title":"Repeat\/retry: fixed unbounded downstream requesting above Long.MAX_VALUE","opened_on":"2015-02-03T19:50:17Z","closed_by":"benjchristensen"},{"number":"2588","reopenOn":null,"comments":[{"date":"2015-02-03T18:56:12Z","author":"akarnokd","text":"Did you measure how long the `getRecordsOfQuery` takes?\n"},{"date":"2015-02-03T19:03:09Z","author":"pradhakrishnan","text":"Yes, it is taking 95ms.\n"},{"date":"2015-02-03T19:04:47Z","author":"akarnokd","text":"Does zip ever complete or just hangs?\n"},{"date":"2015-02-03T19:09:36Z","author":"pradhakrishnan","text":"sometimes zip completes without any issue, sometime it is hanging.\n"},{"date":"2015-02-03T19:52:46Z","author":"akarnokd","text":"Could you test something out? Put a return after `subscriber.onError(ex);` and see if it still hangs?\n"},{"date":"2015-02-03T20:06:27Z","author":"pradhakrishnan","text":"Yes, I tried it still it hangs.\n"},{"date":"2015-02-03T20:06:49Z","author":"akarnokd","text":"Found the bug and posted a fix. Could you verify if #2590 works for you?\n"},{"date":"2015-02-03T20:08:55Z","author":"pradhakrishnan","text":"Sure, thanks Akarnokd. I will check and let you know.\n"},{"date":"2015-02-03T21:09:44Z","author":"pradhakrishnan","text":"I have tried with that build, but still it hangs. \n"},{"date":"2015-02-03T21:18:46Z","author":"akarnokd","text":"Could you post a unit test which demonstrates the problem?\n"},{"date":"2015-02-04T01:02:36Z","author":"pradhakrishnan","text":"Hi Akarnokd,\nI think the problem is with the determineItems method. Earlier it just returned Set<Item> but i changed to Observable<Set<Item>> ( Because I wanted to execute that in asynchronous and finally zip all the results). I just debugged using debug mode of eclipse the method getRecordsOfQuery() is gets hangs sometimes, not sure why. Most of the times it works fine. But sometimes it gets hangs there. \nAnything I did wrong in the above code?\n\nNote : Without observable changes it works fine.  \n"},{"date":"2015-02-04T07:33:48Z","author":"akarnokd","text":"There is nothing wrong with the code above.\n"},{"date":"2015-02-04T21:58:25Z","author":"pradhakrishnan","text":"When I Checked the Thread dump. One thread is waiting in Running state always . This happens after i used Scheduler.io()\n\n``````\n\"RxCachedThreadScheduler-1\" daemon prio=5 tid=0x00007fb1ec9bb800 nid=0xa103 runnable [0x0000000115eee000]\n   java.lang.Thread.State: RUNNABLE\n  at java.net.SocketInputStream.socketRead0(Native Method)\n  at java.net.SocketInputStream.read(SocketInputStream.java:152)\n  at java.net.SocketInputStream.read(SocketInputStream.java:122)\n  at oracle.net.ns.Packet.receive(Unknown Source)\n  at oracle.net.ns.DataPacket.receive(Unknown Source)\n  at oracle.net.ns.NetInputStream.getNextPacket(Unknown Source)\n  at oracle.net.ns.NetInputStream.read(Unknown Source)\n  at oracle.net.ns.NetInputStream.read(Unknown Source)\n  at oracle.net.ns.NetInputStream.read(Unknown Source)\n  at oracle.jdbc.driver.T4CMAREngine.unmarshalUB1(T4CMAREngine.java:1104)\n  at oracle.jdbc.driver.T4CMAREngine.unmarshalSB1(T4CMAREngine.java:1075)\n  at oracle.jdbc.driver.T4C8Oall.receive(T4C8Oall.java:480)\n  at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:219)\n  at oracle.jdbc.driver.T4CPreparedStatement.executeForRows(T4CPreparedStatement.java:970)\n  at oracle.jdbc.driver.OraclePreparedStatement.executeBatch(OraclePreparedStatement.java:10690)\n  - locked <0x00000007b13c0988> (a oracle.jdbc.driver.T4CPreparedStatement)\n  - locked <0x00000007b13147b0> (a oracle.jdbc.driver.T4CConnection)\n  at org.hibernate.jdbc.BatchingBatcher.doExecuteBatch(BatchingBatcher.java:70)\n  at org.hibernate.jdbc.AbstractBatcher.executeBatch(AbstractBatcher.java:268)\n  at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:266)\n  at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:168)\n  at org.hibernate.event.def.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:321)\n  at org.hibernate.event.def.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:50)\n  at org.hibernate.impl.SessionImpl.flush(SessionImpl.java:1027)\n  at org.hibernate.impl.SessionImpl.managedFlush(SessionImpl.java:365)\n  at org.hibernate.transaction.JDBCTransaction.commit(JDBCTransaction.java:137)\n  at org.springframework.orm.hibernate3.HibernateTransactionManager.doCommit(HibernateTransactionManager.java:657)\n  at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:755)\n  at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:724)\n  at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:387)\n  at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:120)\n  at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)\n  at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)\n  at com.sun.proxy.$Proxy114.entitlementRecordsOfQuery(Unknown Source)\n  at com.umapranesh.service.DefaultEntitlementStrategy.getRecordsOfQuery(DefaultEntitlementStrategy.java:153)\n  at com.umapranesh.service.DefaultEntitlementStrategy$1.call(DefaultEntitlementStrategy.java:71)\n  at com.umapranesh.service.DefaultEntitlementStrategy$1.call(DefaultEntitlementStrategy.java:1)\n  at rx.Observable.unsafeSubscribe(Observable.java:7326)\n  at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n  at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:47)\n  at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n  at java.util.concurrent.FutureTask.run(FutureTask.java:262)\n  at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\n  at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\n  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n  at java.lang.Thread.run(Thread.java:745)```\n``````\n"}],"opened_by":"pradhakrishnan","reopen":false,"closed_on":"2015-02-04T05:50:22Z","description":"I have an issue with zip operator, I have few observables which execute asynchronously. And finally I am zipping all the results from each observable. It works fine, but sometime zip operator is waiting for long time to get the value from one of the observable.\n\n```\n List<Observable<Set<Item>>> observableList = new ArrayList<Observable<Set<Item>>>();\nfor (ItemProvider ep : itemList) {\n          ItemStrategy strategey = (ItemStrategy) ep.strategy();\n          observableList.add(strategey.determineItems(message).subscribeOn(Schedulers.io()));\n      }\n }\n\nSet<Item> items = Observable.zip(observableList, new FuncN<Set<Item>>() {\n  Set<Item> returnSet = new HashSet<Item>();\n\n  @SuppressWarnings(\"unchecked\")\n  @Override\n  public Set<Item> call(Object... args) {\n      for (int i = 0; i < args.length; i++) {\n        Set<Item> items = (Set<Item>) args[i];\n          returnSet.addAll(items);\n      }\n      return returnSet;\n  }\n}).toBlocking().singleOrDefault(Collections.<Item> emptySet());\n\nThis is the code to get the items in Strategy class\n@Override\n    public Observable<Set<Item>> determineItems(final ItemsMessageExchange message) {\n      return Observable.create(new OnSubscribe<Set<Item>>() {\n\n            @Override\n            public void call(Subscriber<? super Set<Item>> subscriber) {\n                checkPreconditions(message);\n                Set<Record> records = getRecordsOfQuery(message.toRecordQuery());\n                Set<Item> items = new HashSet<Item>();\n                for (Record record : records) {\n                    try {\n                        items.addAll(record.determineItems());\n                    } catch (Exception ex) {\n                        subscriber.onError(ex);\n                    }\n                }\n                subscriber.onNext(items);\n                subscriber.onCompleted();\n            }\n\n        });\n    }\n```\n\nCan anyone help me to fix this.\n","id":"56410465","title":"Questions about Zip operator","opened_on":"2015-02-03T17:36:31Z","closed_by":"benjchristensen"},{"number":"2587","reopenOn":null,"comments":[{"date":"2015-02-03T18:52:34Z","author":"akarnokd","text":"Hello. It is quite odd. The following program works for me on master:\n\n``` java\npublic class Issue2587 {\n    static void logD(String key, Object msg) {\n        System.out.print(key);\n        System.out.print(\" \");\n        System.out.println(msg);\n    }\n    public static void main(String[] args) {\n        Observable<Integer> sequence = Observable.from(Arrays.asList(1, 2, 3, 4, 5))\n                .take(3)\n                .repeat(3);\n\n        sequence.subscribe(new Observer<Integer>() {\n            @Override\n            public void onCompleted() {\n                logD(\"RXJAVA1\", \"Completed\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                logD(\"RXJAVA1\", \"Error\");\n            }\n\n            @Override\n            public void onNext(Integer appInfo) {\n                logD(\"RXJAVA1\", appInfo);\n            }\n        });\n    }\n}\n```\n\nPrints:\n\n```\nRXJAVA1 1\nRXJAVA1 2\nRXJAVA1 3\nRXJAVA1 1\nRXJAVA1 2\nRXJAVA1 3\nRXJAVA1 1\nRXJAVA1 2\nRXJAVA1 3\nRXJAVA1 Completed\n```\n"},{"date":"2015-02-03T19:15:09Z","author":"hamen","text":"Could you try to apply `distinct()` to get rid of the duplicates please?\n"},{"date":"2015-02-03T19:33:23Z","author":"akarnokd","text":"Hmm. If I apply distinct(), I don't get the Completed message either. I'm going to investigate this.\n"},{"date":"2015-02-03T19:48:18Z","author":"akarnokd","text":"It is a bug with repeat. I'll post the fix soon.\n"},{"date":"2015-02-03T20:03:08Z","author":"akarnokd","text":"Could you verify #2589 works for you?\n"},{"date":"2015-02-04T07:19:41Z","author":"akarnokd","text":"The fix is available in 1.0.5. Thanks for reporting.\n"},{"date":"2015-02-04T11:14:01Z","author":"hamen","text":"Sorry for the delay due to the timezone.\nI checked the `1.0.5`: everything is working fine.\nThank you for the awesome response!\n"}],"opened_by":"hamen","reopen":false,"closed_on":"2015-02-04T07:19:41Z","description":"Hi all\nI'm having a hard time trying to figure this out:\n\n``` java\nObservable<AppInfo> sequence = Observable.from(apps)\n                .take(3)\n                .repeat(3);\n\n        sequence.subscribe(new Observer<AppInfo>() {\n            @Override\n            public void onCompleted() {\n                Log.d(\"RXJAVA1\", \"Completed\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Log.e(\"RXJAVA1\", \"Error\");\n            }\n\n            @Override\n            public void onNext(AppInfo appInfo) {\n                Log.d(\"RXJAVA1\", appInfo.getName());\n            }\n        });\n\n        sequence.distinct()\n                .subscribe(new Observer<AppInfo>() {\n                    @Override\n                    public void onCompleted() {\n                        Log.d(\"RXJAVA2\", \"Completed\");\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        Log.e(\"RXJAVA2\", \"Error\");\n                    }\n\n                    @Override\n                    public void onNext(AppInfo appInfo) {\n                        Log.d(\"RXJAVA2\", appInfo.getName());\n                    }\n                });\n```\n\ngives me\n\n```\nD\/RXJAVA1﹕ 9GAG\nD\/RXJAVA1﹕ AdSense\nD\/RXJAVA1﹕ AirDroid\nD\/RXJAVA1﹕ 9GAG\nD\/RXJAVA1﹕ AdSense\nD\/RXJAVA1﹕ AirDroid\nD\/RXJAVA1﹕ 9GAG\nD\/RXJAVA1﹕ AdSense\nD\/RXJAVA1﹕ AirDroid\nD\/RXJAVA1﹕ Completed\nD\/RXJAVA2﹕ 9GAG\nD\/RXJAVA2﹕ AdSense\nD\/RXJAVA2﹕ AirDroid\n```\n\nand the sequence never completes. If I only repeat it twice:\n\n``` java\nObservable<AppInfo> sequence = Observable.from(apps)\n                .take(3)\n                .repeat(2);\n\n        sequence.subscribe(new Observer<AppInfo>() {\n            @Override\n            public void onCompleted() {\n                Log.d(\"RXJAVA1\", \"Completed\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Log.e(\"RXJAVA1\", \"Error\");\n            }\n\n            @Override\n            public void onNext(AppInfo appInfo) {\n                Log.d(\"RXJAVA1\", appInfo.getName());\n            }\n        });\n\n        sequence.distinct()\n                .subscribe(new Observer<AppInfo>() {\n                    @Override\n                    public void onCompleted() {\n                        Log.d(\"RXJAVA2\", \"Completed\");\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        Log.e(\"RXJAVA2\", \"Error\");\n                    }\n\n                    @Override\n                    public void onNext(AppInfo appInfo) {\n                        Log.d(\"RXJAVA2\", appInfo.getName());\n                    }\n                });\n```\n\nI get\n\n```\nD\/RXJAVA1﹕ 9GAG\nD\/RXJAVA1﹕ AdSense\nD\/RXJAVA1﹕ AirDroid\nD\/RXJAVA1﹕ 9GAG\nD\/RXJAVA1﹕ AdSense\nD\/RXJAVA1﹕ AirDroid\nD\/RXJAVA1﹕ Completed\nD\/RXJAVA2﹕ 9GAG\nD\/RXJAVA2﹕ AdSense\nD\/RXJAVA2﹕ AirDroid\nD\/RXJAVA2﹕ Completed\n```\n\nand everything is fine.\nI'm working on some examples and I spotted this weird scenario and it's driving me crazy. Am I missing something or there is actually something wrong with this?\nThanks\n","id":"56400093","title":"take + repeat + distinct not completing","opened_on":"2015-02-03T16:22:46Z","closed_by":"akarnokd"},{"number":"2576","reopenOn":null,"comments":[{"date":"2015-01-31T22:31:13Z","author":"akarnokd","text":"Looking at #2575 I'd say the change is a no-op on our scheduler implementations because all scheduled tasks are tracked and can be cancelled all at once if the worker is unsubscribed. The `testIssue2191_SchedulerUnsubscribe` test however mocks a scheduler and does not do the tracking the `Schedulers` all do.\n"}],"opened_by":"abersnaze","reopen":false,"closed_on":"2015-02-01T05:44:25Z","description":"After thinking about #2575 I added a note to all the places where a Subscription is lost from a Scheduler.\n","id":"56141111","title":"Lost Subscriptions","opened_on":"2015-01-31T21:53:42Z","closed_by":"abersnaze"},{"number":"2575","reopenOn":null,"comments":[{"date":"2015-01-31T10:34:47Z","author":"akarnokd","text":"Looks good.\n"}],"opened_by":"abersnaze","reopen":false,"closed_on":"2015-01-31T16:44:17Z","description":"@mattrjacobs noticed that the unsubscribe from timeouts of Hystrix commands was not being propagated across the subscribeOn.\n\nhttps:\/\/github.com\/Netflix\/Hystrix\/issues\/354\n","id":"56117584","title":"subscribeOn drops the subscriptions returned from the scheduler.","opened_on":"2015-01-31T08:15:22Z","closed_by":"akarnokd"},{"number":"2567","reopenOn":null,"comments":[{"date":"2015-01-30T00:41:56Z","author":"davidmoten","text":"Thanks for chasing this @akarnokd. I'll have a look this weekend.\n"},{"date":"2015-02-03T21:34:28Z","author":"davidmoten","text":"Looks good @akarnokd. There are a couple of my comments that are unclear (referring to Action1) but I can fix those later if you like. Can we squeeze this into 1.0.5?\n"},{"date":"2015-02-03T21:38:55Z","author":"akarnokd","text":"@benjchristensen seems to be eager to release soon, but if your comments are something that can be done within a few minutes, I can do the changes before release.\n"},{"date":"2015-02-03T22:03:03Z","author":"benjchristensen","text":"This looks good to me. @akarnokd Should I proceed with it or would you still like to wait for @davidmoten to review?\n"},{"date":"2015-02-03T22:07:04Z","author":"benjchristensen","text":"I was working off a stale browser tab so hadn't seen your comments. If both of you are okay with this then I'm ready to merge and release. \n"},{"date":"2015-02-03T22:08:29Z","author":"akarnokd","text":"Its getting late here, but we can perhaps give @davidmoten some time while you could review #2592 and  #2493.\n"},{"date":"2015-02-03T22:10:13Z","author":"benjchristensen","text":"Okay, that works for me. \n"},{"date":"2015-02-03T22:58:56Z","author":"akarnokd","text":"Let's merge this as-is and @davidmoten will post a PR with his changes for 1.0.6. I'll leave it up to you @benjchristensen whether to merge #2493 and #2580 for 1.0.5.\n"},{"date":"2015-02-04T00:59:34Z","author":"davidmoten","text":"I was referring to code comments being slightly out of sync with the code\nbut nothing serious. I think it can wait till another release as I'm not\nable to do a PR at the moment. In a few hours can do but happy if release\ngoes with this fix in the meantime.\nOn 4 Feb 2015 09:08, \"David Karnok\" notifications@github.com wrote:\n\n> Its getting late here, but we can perhaps give @davidmoten\n> https:\/\/github.com\/davidmoten some time while you could review #2592\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2592 and #2493\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2493.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2567#issuecomment-72745874.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-02-04T05:47:53Z","description":"This should fix the problem in #2564. @davidmoten I hope you can review the changes and implications.\n\nThe particular issue was caused by the refCount unable to unsubscribe from upstream in case the current client count was greater than 1. If the upstream sent an error and each client had a retry() in its chain, the retry would immediately resubscribe, thus the refCount would see only a 2 -> 1 -> 2 change in sequence as errors are dispatched sequentially. In the change, each client is wrapped and a termination event triggers the refcount to become 0 atomically and unsubscribes the upstream. When each client then call disconnect, that becomes a no-op.\n","id":"55905512","title":"RefCount: disconnect all if upstream terminates","opened_on":"2015-01-29T14:29:48Z","closed_by":"benjchristensen"},{"number":"2566","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-01-31T16:48:54Z","description":"sometimes.\n\nDiscovered in #2560.\n","id":"55890786","title":"CombineLatest: fixed concurrent requestUpTo yielding -1 requests","opened_on":"2015-01-29T12:03:18Z","closed_by":"akarnokd"},{"number":"2564","reopenOn":null,"comments":[{"date":"2015-01-29T12:07:23Z","author":"akarnokd","text":"Hi. This is most likely the manifestation of the publish() bug. Could you check if #2552 works for you?\n"},{"date":"2015-01-29T12:48:38Z","author":"amitai-hoze","text":"Checked it, exactly the same behavior.\n"},{"date":"2015-01-29T13:39:01Z","author":"akarnokd","text":"The problem happens because retry only retries the refCount which never unsubscribes from the upstream due to two subscribers (they both unsubscribe and resubscribe immediately thus the refCount never reaches zero). The upstream keeps sending timer events which the turn into onError events. onErrorResumeNext stops accepting events after the first error and unsubscribes from the upstream but because refCount never re-subscribes, the whole process stops.\n"},{"date":"2015-01-29T14:30:23Z","author":"akarnokd","text":"I think I fixed the problem. Your example above works with it. Could you also check if #2567 works for you?\n"},{"date":"2015-02-03T17:19:12Z","author":"amitai-hoze","text":"I think it fixes it!\nI'm getting now for (the second example with two subscribers and `onErrorResumeNext`):\n\n``` java\nObservable<String> interval =\n        Observable.interval(1,TimeUnit.SECONDS)\n                .doOnSubscribe(() -> System.out.println(\"subscribe interval\"))\n                .doOnUnsubscribe(() -> System.out.println(\"unsubscribe interval\"))\n                .flatMap(onClickEvent -> Observable.defer(() -> Observable.<String>error(new Exception(\"Some exception\"))))\n                .onErrorResumeNext(Observable::error)\n                .publish()\n                .refCount()\n                .doOnSubscribe(() -> System.out.println(\"subscribe refCount\"))\n                .doOnUnsubscribe(() -> System.out.println(\"unsubscribe refCount\"));\n\ninterval\n        .doOnError(throwable -> System.out.println(\"subscriber 1 error: \" + throwable.getMessage()))\n        .retry()\n        .subscribe(s -> System.out.println(\"subscriber 1: \" + s));\n\ninterval\n        .doOnError(throwable -> System.out.println(\"subscriber 2 error: \" + throwable.getMessage()))\n        .retry()\n        .subscribe(s -> System.out.println(\"subscriber 2: \" + s));\n```\n\nThis result:\n\n```\nsubscribe refCount\nsubscribe interval\nsubscribe refCount\nunsubscribe interval\nsubscriber 1 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nsubscribe interval\nsubscriber 2 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nunsubscribe interval\nsubscriber 1 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nsubscribe interval\nsubscriber 2 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nunsubscribe interval\n...\n```\n\nThree dots say it continues infinitely. Notice that it does resubscribe to interval now.\n"},{"date":"2015-02-03T17:51:09Z","author":"akarnokd","text":"Thanks for confirming. I'm still waiting for @davidmoten's review before merging in the fix.\n"},{"date":"2015-02-03T18:45:54Z","author":"amitai-hoze","text":"No problem\n"},{"date":"2015-02-04T07:18:57Z","author":"akarnokd","text":"The fix is available in 1.0.5. Thanks for reporting.\n"},{"date":"2015-02-04T09:21:32Z","author":"amitai-hoze","text":"Great\n"}],"opened_by":"amitai-hoze","reopen":false,"closed_on":"2015-02-04T07:18:57Z","description":"Hi, I noticed some behavior I don't fully understand.\n\nWhen I run this:\n\n``` java\nObservable<String> interval =\n        Observable.interval(1,TimeUnit.SECONDS)\n                .doOnSubscribe(() -> System.out.println(\"subscribe interval\"))\n                .doOnUnsubscribe(() -> System.out.println(\"unsubscribe interval\"))\n                .flatMap(onClickEvent -> Observable.defer(() -> Observable.<String>error(new Exception(\"Some exception\"))))\n                .onErrorResumeNext(Observable::error)\n                .publish()\n                .refCount()\n                .doOnSubscribe(() -> System.out.println(\"subscribe refCount\"))\n                .doOnUnsubscribe(() -> System.out.println(\"unsubscribe refCount\"));\n\ninterval\n        .doOnError(throwable -> System.out.println(\"subscriber 1 error: \" + throwable.getMessage()))\n        .retry()\n        .subscribe(s -> System.out.println(\"subscriber 1: \" + s));\n```\n\nI get:\n\n```\nsubscribe refCount\nsubscribe interval\nunsubscribe interval\nsubscriber 1 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nsubscribe interval\nunsubscribe interval\nsubscriber 1 error: Some exception\nunsubscribe refCount\n...\n```\n\nThe three dots indicate that it continues infinitely.\nNow when I add a second subscriber:\n\n``` java\ninterval\n        .doOnError(throwable -> System.out.println(\"subscriber 2 error: \" + throwable.getMessage()))\n        .retry()\n        .subscribe(s -> System.out.println(\"subscriber 2: \" + s));\n```\n\nI get:\n\n```\nsubscribe refCount\nsubscribe interval\nsubscribe refCount\nunsubscribe interval\nsubscriber 1 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nsubscriber 2 error: Some exception\nunsubscribe refCount\nsubscribe refCount\n```\n\nand that's it, it doesn't retry. More specifically, it unsubscribes from interval and does not resubscribe. When I remove the `onErrorResumeNext` it's working fine like this:\n\n```\nsubscribe refCount\nsubscribe interval\nsubscribe refCount\nsubscriber 1 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nsubscriber 2 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nsubscriber 1 error: Some exception\nunsubscribe refCount\nsubscribe refCount\nsubscriber 2 error: Some exception\nunsubscribe refCount\nsubscribe refCount\n...\n```\n\nWhere the three dots indicate it goes on infinitely. As you notice it doesn't unsubscribe from interval. I'm using `onErrorResumeNext` to \"map\" the error (in this example it's a trivial mapping), maybe I shouldn't use it like this. Still, I don't understand what's going on..\n","id":"55886634","title":"onErrorResumeNext, refCount and retry","opened_on":"2015-01-29T11:17:29Z","closed_by":"akarnokd"},{"number":"2552","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-01-31T16:53:15Z","description":"Reported in a [rxjava group](https:\/\/groups.google.com\/forum\/#!topic\/rxjava\/iOA_wl-fReI) post.\n\nThe shared emissioncounter subtracted from all subscribers accounting made late coming subscribers appear to have received the same amount of events.\n","id":"55762804","title":"Publish: fixed incorrect subscriber requested accounting","opened_on":"2015-01-28T14:32:09Z","closed_by":"akarnokd"},{"number":"2543","reopenOn":null,"comments":[{"date":"2015-01-28T07:38:33Z","author":"akarnokd","text":"We had a conflicting merge. Could you rebase this onto the current master?\n"},{"date":"2015-01-28T10:24:18Z","author":"davidmoten","text":"rebased (I think).\n"},{"date":"2015-01-28T10:30:02Z","author":"akarnokd","text":"Thanks.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-01-28T10:30:51Z","description":"Calling \n\n``` java\nrequest(2);\nrequest(Long.MAX_VALUE-1);\n```\n\nhangs `OperatorMerge` because the internal requested count overflows and becomes negative. \n\nThis PR adds fix and unit test.\n\nI imagine this will be in other operators as well. I'll have a hunt around.\n","id":"55696433","title":"OperatorMerge handle request overflow","opened_on":"2015-01-28T00:24:27Z","closed_by":"akarnokd"},{"number":"2542","reopenOn":null,"comments":[{"date":"2015-01-28T07:29:22Z","author":"akarnokd","text":"This is the usual concurrent unsubscription bug with the current RxRingBuffer. There is a fix (#2333) but it degrades some perf numbers (cost of correctness) and is unlikely to be merged.\n"},{"date":"2015-01-29T00:08:07Z","author":"abersnaze","text":"rebased the test on top of the latest 1.x branch and the unit test is no longer failing.\n"},{"date":"2015-01-29T00:45:03Z","author":"benjchristensen","text":"Excellent! This is a good validation of https:\/\/github.com\/ReactiveX\/RxJava\/pull\/2553\n"}],"opened_by":"abersnaze","reopen":false,"closed_on":"2015-01-29T00:08:08Z","description":"This may be related to #1845 but @neerajrj and I were able to create a unit test that causes an NPE in merge.\n\n```\nException in thread \"RxComputationThreadPool-1\" java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:52)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: rx.exceptions.OnErrorNotImplementedException\n    at rx.Observable$31.onError(Observable.java:7126)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:154)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:111)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.innerError(OperatorMerge.java:463)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.access$6(OperatorMerge.java:442)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:586)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.innerError(OperatorMerge.java:463)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.access$6(OperatorMerge.java:442)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:586)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:672)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:579)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)\n    at rx.internal.operators.TakeLastQueueProducer.emit(TakeLastQueueProducer.java:100)\n    at rx.internal.operators.TakeLastQueueProducer.startEmitting(TakeLastQueueProducer.java:45)\n    at rx.internal.operators.OperatorTakeLast$1.onCompleted(OperatorTakeLast.java:59)\n    at rx.internal.operators.OperatorScan$2.onCompleted(OperatorScan.java:121)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.internal.operators.BufferUntilSubscriber.emit(BufferUntilSubscriber.java:151)\n    at rx.internal.operators.BufferUntilSubscriber.onCompleted(BufferUntilSubscriber.java:164)\n    at rx.internal.operators.OperatorWindowWithTime$ExactSubscriber.replaceSubject(OperatorWindowWithTime.java:200)\n    at rx.internal.operators.OperatorWindowWithTime$ExactSubscriber.nextWindow(OperatorWindowWithTime.java:308)\n    at rx.internal.operators.OperatorWindowWithTime$ExactSubscriber$1.call(OperatorWindowWithTime.java:282)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:47)\n    ... 7 more\nCaused by: java.lang.NullPointerException\n    at rx.internal.util.RxRingBuffer.poll(RxRingBuffer.java:397)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.drainAll(OperatorMerge.java:754)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.drainQueue(OperatorMerge.java:775)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.access$1(OperatorMerge.java:771)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber$1.call(OperatorMerge.java:420)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber$1.call(OperatorMerge.java:1)\n    at rx.internal.util.IndexedRingBuffer.forEach(IndexedRingBuffer.java:471)\n    at rx.internal.util.IndexedRingBuffer.forEach(IndexedRingBuffer.java:437)\n    at rx.internal.util.SubscriptionIndexedRingBuffer.forEach(SubscriptionIndexedRingBuffer.java:131)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.drainChildrenQueues(OperatorMerge.java:376)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:351)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.access$2(OperatorMerge.java:344)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:705)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:579)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:669)\n    ... 21 more\nCaused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: java.lang.Long.class\n    at rx.exceptions.OnErrorThrowable.addValueAsLastCause(OnErrorThrowable.java:98)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:672)\n    ... 21 more\n```\n\nunit test that causes the error\n\n```\n    @Test\n    public void test() {\n        Observable<Long> src = Observable.create(new OnSubscribe<Long>() {\n            @Override\n            public void call(Subscriber<? super Long> t1) {\n                Random rand = new Random();\n                while (true) {\n                    t1.onNext(rand.nextLong());\n                }\n            }\n        });\n\n        Observable<Long> x = src.groupBy(new Func1<Long, Long>() {\n            @Override\n            public Long call(Long t1) {\n                return t1 % 100000;\n            }\n        }).flatMap(new Func1<GroupedObservable<Long, Long>, Observable<Long>>() {\n            @Override\n            public Observable<Long> call(GroupedObservable<Long, Long> group) {\n                return group.observeOn(Schedulers.computation()).timeout(1, TimeUnit.SECONDS, Observable.empty()).window(100, 100, TimeUnit.MILLISECONDS).flatMap(new Func1<Observable<Long>, Observable<Long>>() {\n                    @Override\n                    public Observable<Long> call(Observable<Long> window) {\n                        return window.countLong();\n                    }\n                });\n            }\n        });\n\n        x.subscribe(new Action1<Long>() {\n            @Override\n            public void call(Long t1) {\n                System.out.println(t1);\n            }\n        });\n    }\n```\n","id":"55695563","title":"NullPointerException in merge","opened_on":"2015-01-28T00:14:31Z","closed_by":"abersnaze"},{"number":"2482","reopenOn":null,"comments":[{"date":"2015-01-28T07:33:41Z","author":"akarnokd","text":"I'm going to merge this so other bugfixes\/enhancements can go on.\n"}],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-01-28T07:33:46Z","description":"I think I hunted down the bug that was causing missed value emission if scalar source such as `just()` was involved. This either manifested as completion without a value or non-completion because the missing scalar value would sit in the queue and prevented onCompleted from draining. (I've also fixed some visibility issues which might had an effect in this.)\n\nIn addition, I've discovered a good practice for spuriously failing tests: I create a new `@Test`method with a loop in it, calling the original test method. This way, the original is not disturbed and the likelihood of failure is increased by the looping test.\n\nSince the whole `merge`operator is quite complicated, I can't be 100% certain this works despite local tests passing.\n\nSee also #2480, #2466 and #1941.\n","id":"55141936","title":"Merge: fixed hangs & missed scalar emissions","opened_on":"2015-01-22T11:22:36Z","closed_by":"akarnokd"},{"number":"2480","reopenOn":null,"comments":[{"date":"2015-01-22T08:27:29Z","author":"akarnokd","text":"I usually put a loop around such test methods and get the failure consistently. I'll investigate `OperatorMergeTest.testBackpressureUpstream2`.\n\nEdit: it is most likely the RxRingBuffer reuse bug. If I put in a 10ms sleep between iterations, a 1000 tests pass.\n\nEdit 2: Not related to RxRingBuffer. It seems if `just(-99)` gets in first, the test passes, otherwise, after merging 256 from the first source, merge doesn't resume with `just(-99)`.\n"},{"date":"2015-01-23T19:08:56Z","author":"akarnokd","text":"Could you verify #2482 does work for you?\n"},{"date":"2015-03-11T14:12:42Z","author":"akarnokd","text":"I'm closing this due to inactivity. If you have further problems, please don't hesitate to reopen this issue or post a new one.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2015-03-11T14:12:42Z","description":"`OperatorMergeTest.testBackpressureUpstream2` fails 2 out of 3 times when running the whole suite in Eclipse on an old 2 core laptop. The test passes every time if run singly. \n\nSee also discussion about test isolation #1624\n","id":"55090005","title":"Non deterministic test: OperatorMergeTest.testBackpressureUpstream2","opened_on":"2015-01-21T22:55:44Z","closed_by":"akarnokd"},{"number":"2471","reopenOn":null,"comments":[{"date":"2015-01-21T10:51:36Z","author":"akarnokd","text":"Almost good. Two things:\n- Since we only use offer\/poll, you can use the unbounded PriorityBlockingQueue now\n- Could you move `counter` and `COUNTER_UPDATER` into the `InnerCurrentThreadScheduler` class, both non-static fields?\n"},{"date":"2015-01-23T09:05:11Z","author":"akarnokd","text":"We are using AtomicFieldUpdaters to save on the instance cost of `AtomicInteger`s. Could you change the counter to use `AtomicLongFieldUpdater`?\n"},{"date":"2015-01-23T17:36:27Z","author":"jnlopar","text":"Done. On a related but side-note, do you know if these field updaters are proguard-safe for obfuscation? They reflect on field name for sure. It might be worth looking into. The fix would probably be implementing the abstract setters and getters, which would obviously be a bit more boilerplate and kinda less fun, but might be worth it if it reduces custom proguard rules required to use rx.\n"},{"date":"2015-01-23T17:43:33Z","author":"akarnokd","text":"Thanks for the changes, looks good to me. I don't know about ProGuard.\n"},{"date":"2015-01-23T19:15:18Z","author":"jnlopar","text":"Looks like per the proguard manual, it does indeed recognize FieldUpdater declarations, so this should be fine.\n"},{"date":"2015-01-23T19:16:26Z","author":"JakeWharton","text":"Wow I did not expect that. How uncharacteristically useful of them! Good to know for the future.\n"},{"date":"2015-01-23T19:18:37Z","author":"jnlopar","text":"http:\/\/proguard.sourceforge.net\/manual\/introduction.html\n\nSee the 'Reflection' section (no anchor link). That lists the basic reflection methods it automatically detects.\n"}],"opened_by":"jnlopar","reopen":false,"closed_on":"2015-01-23T17:43:38Z","description":"Also adds a unit test for regression.\n\nIt appears there is a potential race condition if something adds to\/removes from the PQ while it's _inside_ the 'poll' operation, which is where the exceptions in #1702 seem to have actually come from. Therefore, the initial null check didn't really address the original problem. The test here seems to reliably recreate those conditions.\n\nI considered using a PriorityBlockingQueue instead of synchronized, but since the isEmpty and poll calls should not allow something to interleave between them and access the queue, a synchronized block seemed wiser here.\n","id":"54928236","title":"Fixes NPEs reported in ReactiveX#1702 by synchronizing queue.","opened_on":"2015-01-20T19:35:01Z","closed_by":"akarnokd"},{"number":"2466","reopenOn":null,"comments":[{"date":"2015-01-21T05:08:06Z","author":"benjchristensen","text":"This will require some time to dig into.\n"},{"date":"2015-01-21T08:46:10Z","author":"grzechum","text":"Thanks,\n\nI found a workaround for this, which solves the problem for low and medium load.\n- remove backpressure control from producer\n- add onBackpressureBlock() after subscribeOn()\n\n``` java\n    private final class OnSubscribeImpl implements OnSubscribe<String> {\n        private final int id;\n\n        public OnSubscribeImpl(int id) {\n            this.id = id;\n        }\n\n        @Override\n        public void call(Subscriber<? super String> s) {\n            try {\n                long counter = 0;\n                while (true) {\n                    s.onNext(id + \" - \" + (counter++));\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void testX() throws InterruptedException {\n\n        Observable<?> obs0 = Observable.create(new OnSubscribeImpl(0)).subscribeOn(Schedulers.io())\n                .onBackpressureBlock();\n        Observable<?> obs1 = Observable.create(new OnSubscribeImpl(1)).subscribeOn(Schedulers.io())\n                .onBackpressureBlock();\n\n        Observable.merge(obs0, obs1).observeOn(Schedulers.computation()).forEach(s -> System.out.println(s));\n\n        Thread.sleep(Long.MAX_VALUE);\n    }\n```\n\nbut still under heavy load when consumers are slow I see increasing number of events buffered somewhere inside merge() and\/or onBackpressureBuffer() - I will expect buffering around hundreds of messages (ring buffers) but I observe tens of thousands of messages being buffered  - but this is just a quick observation and I need to dig more to understand where the events are buffered.\n"},{"date":"2015-01-21T08:50:39Z","author":"akarnokd","text":"Hi, I'm looking at this issue right now (great test btw, fails all the time as required by debugging :).\n"},{"date":"2015-01-21T10:37:47Z","author":"akarnokd","text":"It seems some downstream requests don't get executed on the SubscribeOn's worker because the same worker is blocked on an acquire. onBackpressureBlock works because it disregards the upstream's backpressure capability. So blocking and backpressure awareness doesn't work well on the same subscribeOn worker.\n"},{"date":"2015-01-21T13:46:09Z","author":"grzechum","text":"I'believe downstream request must be pushed from consuming thread(s) when buffers slots become available. SubscribeOn thread must block to slow down producer ?\n"},{"date":"2015-01-21T14:00:35Z","author":"akarnokd","text":"SubscribeOn schedules a request onto the same thread as the emission took place. The reason is to be consistent with pre-backpressure behavior where all of the values would be emitted from this single thread.\n"},{"date":"2015-01-21T14:46:04Z","author":"grzechum","text":"Thanks, that explains the problem - quick test shows that as you pointed, the same thread is scheduled for request.\n\nBut, I do not see elegant workaround\/solution for this yet...\n    - e.g. when to release subscribeOn thread having the guarantee that request will be called from downstream (when requests == 0?)\n"},{"date":"2015-01-21T15:03:02Z","author":"akarnokd","text":"The whole backpressure logic is based on continuations so you don't need to block\/unblock a thread (and avoid a same-pool deadlock). You could rewriter your Observable with the help of AbstractOnSubscribe which takes care of the backpressure or use onBackpressureBlock.\n"},{"date":"2015-01-22T09:22:37Z","author":"grzechum","text":"Thanks, that works well:\n\n``` java\n    Observable<String> create(int id, long limit) {\n        AtomicLong counter = new AtomicLong();\n        return AbstractOnSubscribe.<String, Void> create(s -> {\n            if (counter.get() < limit) {\n                s.onNext(id + \" - \" + counter.incrementAndGet());\n            } else {\n                s.onCompleted();\n            }\n        }).toObservable();\n    }\n\n    @Test\n    public void testX() throws InterruptedException {\n        Semaphore end = new Semaphore(0);\n\n        Observable<String> obs0 = create(0, 100000).subscribeOn(Schedulers.io());\n        Observable<String> obs1 = create(1, 100000).subscribeOn(Schedulers.io());\n\n        Observable.merge(obs0, obs1).observeOn(Schedulers.computation())\n                .subscribe(System.out::println, System.out::println, () -> end.release());\n\n        end.acquire();\n    }\n```\n"}],"opened_by":"grzechum","reopen":false,"closed_on":"2015-02-23T14:43:58Z","description":"Below test, when run, quickly goes out of requests, merge operator is quite complex and it is difficult to say what exactly causes the problem but it looks like race condition, because each run gives different results.\n\nThis may be related to #1941 but scenario is different.\n\n``` java\n    private final class OnSubscribeImpl implements OnSubscribe<String> {\n        private final int id;\n        private final Semaphore requested = new Semaphore(0); \/\/ back pressure control\n\n        public OnSubscribeImpl(int id) {\n            this.id = id;\n        }\n\n        @Override\n        public void call(Subscriber<? super String> s) {\n            s.setProducer(new Producer() {\n                @Override\n                public void request(long n) {\n                    System.out.println(id + \" - REQUESTED: \" + n);\n                    requested.release((int) n);\n                }\n            });\n\n            try {\n                long counter = 0;\n                while (true) {\n                    requested.acquire();\n                    System.out.println(id + \" - REMAININIG: \" + requested.availablePermits());\n\n                    s.onNext(id + \" - \" + (counter++));\n                }\n            } catch (InterruptedException ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void testX() throws InterruptedException {\n\n        Observable<String> obs0 = Observable.create(new OnSubscribeImpl(0)).subscribeOn(Schedulers.io());\n        Observable<String> obs1 = Observable.create(new OnSubscribeImpl(1)).subscribeOn(Schedulers.io());\n\n        Observable.merge(obs0, obs1).observeOn(Schedulers.computation()).forEach(s -> System.out.println(s));\n\n        Thread.sleep(Long.MAX_VALUE);\n    }\n```\n","id":"54761224","title":"Out of requests in merge","opened_on":"2015-01-19T13:04:18Z","closed_by":"akarnokd"},{"number":"2459","reopenOn":null,"comments":[{"date":"2015-01-16T08:24:06Z","author":"akarnokd","text":"Could you check if #1955 has this problem? Its aim was to make a generic backpressure-buffer manager so basically it can cover all 3 OnBackpressureXXX operators.\n"},{"date":"2015-01-16T08:51:47Z","author":"zsxwing","text":"OK.\n"},{"date":"2015-02-05T15:55:56Z","author":"akarnokd","text":"Should be fixed in 1.0.5.\n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2015-02-05T15:55:56Z","description":"Found some race conditions in `OperatorOnBackpressureBuffer`. Here is the test: https:\/\/github.com\/zsxwing\/RxJava\/commit\/66737b4544d9218e5121e8e65962f7843cba14ee\n\nBecause it's hard to write a test to reproduce it, I have to add `Thread.sleep(...)` in `OperatorOnBackpressureBuffer`.\n\nWe are using the following pattern in `OperatorOnBackpressureBuffer`:\n\n``` Java\n0 Update some state\n1 if (wip.getAndIncrement() == 0) {\n2    while(true) {\n3       \/\/ do something\n4       if (some_condition_about_state is false) {\n5             wip.decrementAndGet();\n6       }\n7    }\n8 }\n```\n\nAssume thread T1 and thread T2 runs the above codes at the same time. At first, T2 is suspended in L0  and T1 runs normally. However, when T1 reaches L5 (before decreasing wip), it's suspended. Then T2 starts to run, it will update the state, and some_condition_about_state becomes true. However, T2 finds wip is not 0, so it won't enter the while loop. T2 will exit. Now T1 is back, it doesn't know some_condition_about_state becomes true, it will directlly desceases `wip` and exits.\n\nIf there is no thread enters the above codes after T1 and T2, `OperatorOnBackpressureBuffer` will swallows the values in the queue.\n","id":"54549071","title":"Race conditions in `OperatorOnBackpressureBuffer`","opened_on":"2015-01-16T07:56:11Z","closed_by":"akarnokd"},{"number":"2333","reopenOn":"2015-01-21T10:42:58Z","comments":[{"date":"2015-01-07T16:42:11Z","author":"daschl","text":"@akarnokd is that ops\/s? Why is it slower in some cases too?\n\nedit: it seems that it's slower in most of the cases? if it is really ops\/s\n"},{"date":"2015-01-07T17:01:57Z","author":"akarnokd","text":"Yes, ops per second. These are the most noticeably slower ones:\n\n```\n1SyncStreamOfN           1000    21250,675 |   18530,542\n1SyncStreamOfN        1000000       20,406 |      17,712\nNSyncStreamsOfN          1000       24,324 |      20,601\n```\n\nI haven't dig into it but my guess is that the atomic increment-and-get on the peek() and poll(). Some queue users first call peek() and if it returns something, then they do a full poll(). This is 2 increments per value instead of none in 1.x. I've been thinking about the option to remove the phaser from peek() since it doesn't change any queue state. (Alternatively, the two might be merged into a `pollIf(Predicate consume)` where the callback would tell to remove the value or not.)\n\nEdit: correction, the only place peek() is used is in zip tick, so it is one atomic increment per poll instead of 0.\n"},{"date":"2015-01-21T11:04:06Z","author":"zsxwing","text":"@akarnokd you can click \"Restart build\" in Travis CI. \n"},{"date":"2015-01-21T11:08:59Z","author":"akarnokd","text":"@zsxwing Thanks, I never logged into Travis so did not see the button.\n"},{"date":"2015-01-21T18:17:53Z","author":"benjchristensen","text":"@akarnokd Is this the one you think is ready for merge? If so I'll do my tests with Flight Recorder to appease my concern on memory and GC behavior. \n"},{"date":"2015-01-21T19:11:07Z","author":"akarnokd","text":"Yes it is.\n"},{"date":"2015-01-22T20:25:23Z","author":"benjchristensen","text":"Here is the outcome of my perf testing on this:\n\n```\n .\/gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*OperatorMergePerf.*'\n\nBenchmark                                          (size)   Mode   Samples          1.x           PR\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5052690.265  4989944.158 \nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    43229.405    34265.533 --\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       41.317       30.750 --\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5   101442.051    95688.061 \nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.776        4.768\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4640498.106  4525502.795\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   446840.647   448934.827\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    39857.078    39870.866\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  4837426.647  5174591.967\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       39.182       29.531 --\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    76236.959    76523.262 \nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3073.535     2556.523 -\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  4984161.207  4745798.100 \nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    37588.942    35720.766\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       34.425       31.146\n```\n\nFlight Recorder testing against first minute of \"Iteration\" stage of this JMH run:\n\n```\n.\/gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 20 .*OperatorMergePerf.merge1SyncStreamOfN.*'\n```\n\n1.x Baseline Overview\n\n![baseline-overview](https:\/\/cloud.githubusercontent.com\/assets\/813492\/5863848\/76eb71b8-a231-11e4-962d-b002dce1a145.png)\n\nThis PR Overview\n![pr-overview](https:\/\/cloud.githubusercontent.com\/assets\/813492\/5863854\/815fd63e-a231-11e4-8f17-6dfd229a7bba.png)\n\n1.x Baseline Allocations\n\n![baseline-allocations](https:\/\/cloud.githubusercontent.com\/assets\/813492\/5863852\/7f45fe78-a231-11e4-93b5-882d0bd77879.png)\n\nThis PR Allocations\n![pr-allocations](https:\/\/cloud.githubusercontent.com\/assets\/813492\/5863858\/892891f8-a231-11e4-95b5-a94560af462c.png)\n"},{"date":"2015-01-22T20:28:09Z","author":"benjchristensen","text":"The CPU usage appears to be higher on this PR (the average is 19 versus 17). Not sure if there are other changes in 1.x that could affect this as this PR is 17 days old. \n\nAs per previous comments there are 3 perf tests that take a noticeable performance hit. \n"},{"date":"2015-01-22T20:30:09Z","author":"benjchristensen","text":"I suggest that we merge the JCTools SpscArrayQueue fixes in via another PR since we want those regardless of what else we do and so comparisons across approaches are equivalent. \n\nI'm not yet ready to accept the performance hit this PR gives. \n"},{"date":"2015-01-22T20:55:19Z","author":"benjchristensen","text":"Here is comparing #2189 and this PR to 1.x. I rebased both PRs onto the current 1.x branch to try and be as accurate as possible:\n\n```\n1.x == current 1.x branch\nPR2333 == PR #2333 after rebasing onto 1.x\nPR2189 == PR #2189 after rebasing onto 1.x\n\nBenchmark                                          (size)   Mode   Samples          1.x        PR2189        PR2333\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4879535.663   4773501.735   4807008.476\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    43295.567     37341.214     34950.819\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       41.255        40.202        32.236\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    99885.768    101321.745     97689.264\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.846         4.715         4.973\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4684222.432   4747380.010   4751592.996\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   456736.726    468609.567    467310.110\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    40504.652     41472.463     41146.594\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  4993477.475   5268523.818   5414652.857\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       44.460        42.820        32.926\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    79546.448     76853.391     73846.697\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3138.932      3140.582      2672.720\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5248113.569   5136570.967   5225289.115\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    39001.895     39254.876     39235.506\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.039        35.282        33.375\n```\n"}],"opened_by":"akarnokd","reopen":true,"closed_on":"2015-01-28T23:27:50Z","description":"This PR contains the fixes and improvements on the RxRingBuffer and its single-consumer-single-producer queue.\n- Added `SWSRPhaser` which is a variant of Gil Tene's WriterReaderPhaser that uses cheaper atomic operations because the single reader and single writer use case. Note that pre Java 8 Unsafe doesn't support atomic addAndGetLong operation. The simplified phaser costs only a single atomic increment per use.\n- Updated `SpscArrayQueue` to match JCTools' current version: the queue now can be fully utilized to its capacity.\n- The `RxRingBuffer` now uses two phasers: one for the offer side and one for the poll\/peek side. The benefits: reduced interference between readers and writers; allows using the simplified phaser because each side is now single threaded (a shared phaser implies up to 2 threads at once).\n\nBenchmark results:\n\n```\nBenchmark              (size)        1.x   |      this   \n1SyncStreamOfN              1  3779678,748 | 3767936,028 \n1SyncStreamOfN           1000    21250,675 |   18530,542 \n1SyncStreamOfN        1000000       20,406 |      17,712 \nNAsyncStreamsOfN            1   115390,116 |  115629,480 \nNAsyncStreamsOfN         1000        2,579 |       2,546 \nNSyncStreamsOf1             1  3543551,254 | 3602242,709 \nNSyncStreamsOf1           100   299166,910 |  301703,721 \nNSyncStreamsOf1          1000    28404,751 |   28420,833 \nNSyncStreamsOfN             1  4054571,577 | 4003156,953 \nNSyncStreamsOfN          1000       24,324 |      20,601 \nTwoAsyncStreamsOfN          1    85846,727 |   85682,983 \nTwoAsyncStreamsOfN       1000     1823,137 |    1889,458 \nreamOfNthatMergesIn1        1  3724179,351 | 3725068,220 \nreamOfNthatMergesIn1     1000    19051,928 |   19392,595 \nreamOfNthatMergesIn1  1000000       18,265 |      18,069\n```\n","id":"53490278","title":"RxRingBuffer fixes and improvements","opened_on":"2015-01-06T07:53:53Z","closed_by":"akarnokd"},{"number":"2291","reopenOn":null,"comments":[{"date":"2014-12-28T15:58:57Z","author":"akarnokd","text":"I just want to mention that the maxConcurrent value may allow the use of a single large buffer split into N element regions. Once a region has completed, that part can be assigned to a new source. Of course, merging 100s of one element sources is wasteful.\n"},{"date":"2015-02-06T05:39:32Z","author":"tappleby","text":"Is the flatMap api still going to get a `maxConcurrent` overload?\n"},{"date":"2015-02-06T06:20:38Z","author":"benjchristensen","text":"I would still like to. I opened this issue for it: https:\/\/github.com\/ReactiveX\/RxJava\/issues\/2626\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2015-02-05T16:15:54Z","description":"The `merge(Observable\/Iterable o, int maxConcurrent)` overloads do not support backpressure. They were missed when implementing the normal `merge`. \n\nThis was first brought up in https:\/\/github.com\/ReactiveX\/RxJava\/issues\/1927#issuecomment-66885487\n\nThis code shows the problem:\n\n``` java\nimport static rx.Observable.*;\nimport rx.Observable;\nimport rx.schedulers.Schedulers;\n\npublic class MergeMaxConcurrent {\n\n    public static void main(String[] args) {\n        Observable<Observable<Integer>> asyncWork = range(1, 1000000)\n                \/\/      .doOnNext(i -> System.out.println(\"Value: \" + i))\n                .doOnRequest(r -> System.out.println(\"request1 \" + r))\n                .map(item -> {\n                    return just(item)\n                            .doOnNext(MergeMaxConcurrent::sleep)\n                            .subscribeOn(Schedulers.io());\n                })\n                .doOnRequest(r -> System.out.println(\"request2 \" + r));\n        merge(asyncWork, 10).toBlocking().forEach(System.out::println);\n    }\n\n    public static void sleep(int value) {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\nRelated to this, we should have a `flatMap` overload that accepts a `maxConcurrent` parameter so that the `merge(o, maxConcurrent)` can be used like this with backpressure:\n\n``` java\n        Observable.range(0, Integer.MAX_VALUE).map(i -> \"lineOfData-\" + i) \/\/ simulate the file with many lines\n                .buffer(100) \/\/ buffer up chunks of work before processing them\n                .flatMap(chunk -> {\n                    return Observable.just(chunk).subscribeOn(Schedulers.io()) \/\/ put each group on a new thread (io scheduler for blocking IO) \n                            .doOnNext(t -> {\n                                \/\/ do work here\n                                try {\n                                    Thread.sleep(1000);\n                                } catch (Exception e) {\n                                }\n                                \/\/ write out on blocking IO as a side-effect\n                                System.out.println(\"Emitting to IO: \" + t);\n                            });\n                }).toBlocking().forEach(System.out::println);\n```\n\nRight now an awkward use of `groupBy` can be used to avoid using `merge` but it is inefficient since it calls the `groupBy` function on every item instead of being able to do the buffering before `flatMap` and just using backpressure to only `merge` the `maxConcurrent` as they are processed.\n\nHere is the `groupBy` approach:\n\n``` java\n        Observable.range(0, Integer.MAX_VALUE).map(i -> \"lineOfData-\" + i) \/\/ simulate the file with many lines\n                .zipWith(Observable.range(0, Integer.MAX_VALUE), (d, i) -> new Object[] { d, i }) \/\/ index it so we can use the index position\n                .groupBy(pair -> (int) pair[1] % 4) \/\/ mod on index for parallelism\n                .flatMap(g -> {\n                    return g.observeOn(Schedulers.computation()) \/\/ put each group on a new CPU \n                            .map(pair -> pair[0]) \/\/ extract just the value\n                            .buffer(100) \/\/ buffer up chunks of work before processing them\n                            .map(t -> {\n                                \/\/ do work here\n                                try {\n                                    Thread.sleep(1000);\n                                } catch (Exception e) {\n                                }\n                                \/\/ generally just pure processing goes in a map function\n                                \/\/ so if IO side-effects are being done here, then it is idiomatic to instead\n                                \/\/ use doOnNext which returns Void. \n                                \/\/ If doing blocking IO here, then use Schedulers.io() instead of computation() above. \n                                return \"processed \" + t;\n                            });\n                }).toBlocking().forEach(System.out::println);\n```\n\nThese last 2 solutions are variants for splitting up a long file of data, processing them in multiple threads and emitting the results over network IO. It is not important whether the IO is blocking or non-blocking. It is not even all that important whether the IO is done as a side-effect on each thread, or the results are merged back into 1 thread and then emitted. The important part is that right now it's not obviously simple to use `flatMap` and achieve backpressured, async parallelism. \n","id":"52973953","title":"Backpressure: flatMap\/merge with maxConcurrent","opened_on":"2014-12-28T06:21:15Z","closed_by":"akarnokd"},{"number":"2290","reopenOn":null,"comments":[{"date":"2014-12-27T23:13:38Z","author":"akarnokd","text":"It has an off-by-one error on L211 and the clear() in L212 clears the consumer and thus not emitting anything further unless the timer fires. This seems to be an odd behavior but conforms the javadoc spec.\n"},{"date":"2014-12-28T00:55:52Z","author":"benjchristensen","text":"Pretty sure the Javadoc is just documenting how it was implemented. This can't be right as what is the point of the max count if it still waits for the time to fire? The only thing it can then do is drop data. \n\ncc @headinthebox\n"},{"date":"2014-12-28T09:56:22Z","author":"akarnokd","text":"Yes one could use take() on a timed window to achieve the same effect. The buffer() operator does an _or_ between the size and time conditions. I can't remember why I implemented window() this way after implementing buffer() the other way. The fix is simple:\n\n``` java\nvoid emitValue(T t) {\n    State<T> s = state;\n    if (s.consumer == null) {\n        replaceSubject();\n        s = state;\n    }\n    s.consumer.onNext(t);\n    if (s.count == size - 1) {\n        s.consumer.onCompleted();\n        s = s.clear();\n    } else {\n        s = s.next();\n    }\n    state = s;\n}\n```\n"},{"date":"2015-01-21T14:11:52Z","author":"akarnokd","text":"Fixed.\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2015-01-21T14:08:20Z","description":"This code only emits 1 window. \n\n``` java\n        Observable.range(0, 10000).window(1, TimeUnit.SECONDS, 20).flatMap(o -> {\n            System.out.println(\"window\");\n           return o.count(); \n        }).toBlocking().forEach(System.out::println);\n```\n\nThere are 2 issues I have with it:\n\n1) Why are there 21 instead of 20 elements in it?\n2) Why does this only emit 1 window? Why does this not just behave like `window(20)` since the time never triggers?\n","id":"52967945","title":"window time+size emits only 1 window","opened_on":"2014-12-27T22:52:27Z","closed_by":"akarnokd"},{"number":"2157","reopenOn":null,"comments":[{"date":"2014-12-22T14:06:44Z","author":"akarnokd","text":"Generally, it is a tradeoff between latency and throughput, and the current RxJava is mostly aimed at throughput of long streams. In your case, latency dominates and the synchronization points introduce overhead not diminished by large amounts of data. The second cause of throughput loss is the backpressure. Merging 5 values backpressure-enabled adds quite an overhead; I was advocating a plain, no-backpressure merge alternative a few times. You can dig up a version from 0.19.\n\nAsync unsubscriptions still issue an interrupting cancel. It is possible to enhance the current ScheduledAction to not interrupt at all if the action body has actually completed, but it can't help if an unsubscription swings around while the action is active.\n\nAt the end it might come to a case where there most operators would need two user-chosable variant: one for short and low latency work and one for long high throughput work.\n"},{"date":"2014-12-22T14:18:49Z","author":"daschl","text":"@akarnokd thanks for your feedback. Now I understand why it is they way it is, but probably there is another way I can write to my scheduler without going through observe?\n\nMy motivation is that I have  ResponseHandler at the event notification side of a Disruptor, and I want to onNext and onComplete a Subject as quickly as possible, but of course not let the user run their Observable operations on my handler, since this would probably stall everything.\n\nDo you think it could work to schedule an action on the scheduler which does the events, which would make me \"be\" on the scheduler thread without using observeOn? Is there anything I need to be aware of?\n\nAlso, if you have some ideas I wouldn't mind writing my own observeOn implementation in this case since its completely under my control, but I don't think that will help I guess.\n"},{"date":"2014-12-22T15:32:35Z","author":"akarnokd","text":"That is a viable option, but you may need to consider backpressure if data amount is above 128 onNexts.\n"},{"date":"2014-12-22T15:56:43Z","author":"daschl","text":"@akarnokd it's a async subject anyway, so only one `onNext` ever.\n\nIs this good:\n\n``` java\nenv().scheduler().createWorker().schedule(new Action0() {\n            @Override\n            public void call() {\n                observable.onNext(response);\n                observable.onCompleted();\n            }\n        }); \n```\n\nI get better performance (although of course not equally to not scheduling it somewhere else) , but do I need to unsubscribe at some point to not risk leaking anything? When would I need to unsubscribe? I think if I cache the worker(), it will always hit the same thread on the computation scheduler I think...\n"},{"date":"2014-12-22T15:59:41Z","author":"akarnokd","text":"You need to unsubscribe the worker in this case. Otherwise, you could use a plain, system-wide cached threadpool and not worry about such 1 shot emissions.\n"},{"date":"2014-12-22T16:05:04Z","author":"daschl","text":"@akarnokd I have my own \"CoreScheduler\" created, which is basically just a Schedulers.computation() spinoff. I wonder if I could just expose the pool from there directly and issue it as a task without going through the scheduler? Do you think I can use the pool from both external and rx at the same time? Or would this break semantics.\n\nActually I'm not sure that's a good idea.. when do I need to unsubscribe the worker? Also, would you recommend caching the worker?\n"},{"date":"2014-12-22T16:20:23Z","author":"akarnokd","text":"If you have access to the underlying pool, you can use it but don't expect the semantics of the Scheduler (i.e., strictly serialized and no thread hopping). So having \"native\" tasks interleaved with RxJava tasks is okay (but adds latency in case of interleaving).\n\nYou need to unsubscribe the worker if the downstream is completed, i.e., after sending out onCompleted. Schedulers.io() will cache the underlying workers so you don't need to worry about that.\n"},{"date":"2014-12-22T16:40:41Z","author":"daschl","text":"So this is giving me a little better perf, does this seem reasonable to you?\n\n``` java\n        final Scheduler.Worker worker = env().scheduler().createWorker();\n        worker.schedule(new Action0() {\n            @Override\n            public void call() {\n                try {\n                    observable.onNext(response);\n                    observable.onCompleted();\n                } catch(Exception ex) {\n                    LOGGER.warn(\"Caught exception while onNext on observable\", ex);\n                    observable.onError(ex);\n                } finally {\n                    worker.unsubscribe();\n                }\n            }\n        });\n```\n"},{"date":"2014-12-22T16:50:56Z","author":"akarnokd","text":"Yes.\n"},{"date":"2014-12-22T20:44:10Z","author":"benjchristensen","text":"> Merging 5 values backpressure-enabled adds quite an overhead\n\n@akarnokd I'm curious as to what overhead are you are referring to. If there is no contention it never queues them. Perhaps you're referring to the extra bookkeeping? \n\nThe performance of merge is measured in millions of ops\/second when uncontended. If there is contention then the cost is paid, but that always exists with concurrent contended access\/emission. \n\n> Do you think I can use the pool from both external and rx at the same time?\n\nThat's fine. We intend on doing something like this when running with Netty where the Computation Scheduler is the same as the Netty EventLoop Groups. \n\n>  at the event notification side of a Disruptor, and I want to onNext and onComplete a Subject as quickly as possible, but of course not let the user run their Observable operations on my handler,\n\nIf you already have Disruptor in your system then you can probably leverage it for faster dispatch and skip the Java ExecutorService stuff completely. In fact, I'd be quite interested in a DisruptorScheduler as a separate plugin that can be opted into. It would be interesting to see the perf difference. \n\nSince you do have Disruptor, why do you need to emit to an Observable directly on the handler thread and then move it to another Scheduler via `observeOn`? Perhaps the handler should just put it directly into a Disruptor queue and then have the `env.Scheduler` draining from Disruptor and emit to the Observable from there? \n"},{"date":"2014-12-22T21:35:21Z","author":"akarnokd","text":"I was talking about the many escaped synchronized block which isn't optimized away by the JVM. This may introduce several microseconds worth of sleep which may help the throughput benchmarks but has bad latency. Merge uses synchronized emitter blocks quite a lot, plus CompositeSubscription is also synchronized.\n\nDisruptor is more than a queue and less than a queue. A DisruptorScheduler would be a multi-producer single consumer setup where the reader thread is where things get dequeues and run. Since one can't let this thread spin and make it eventually sleep, there might be no significant difference compared to a regular threadpoolexecutor. The time it takes to wake up a worker thread is almost the same, but perhaps the fact that concurrent producers don't block each other makes some difference. Note that with observeOn and SerializedObserver, we already have some smart batching because they take the entire piled-up work. Also timed execution and in-queue cancellation might be difficult to accomplish with it.\n"},{"date":"2014-12-23T03:20:52Z","author":"benjchristensen","text":"> This may introduce several microseconds worth of sleep which may help the throughput benchmarks but has bad latency\n\nI agree we have used throughput as our measurement thus far, but we have not consciously optimized one way or another for latency since we have never tracked it sufficiently to do so. At this point latency is treated as \"throughput\/ops\/second\"\n\nIf we're going to discuss latency we'd need to track latency percentiles (such as by using HdrHistogram https:\/\/github.com\/HdrHistogram\/HdrHistogram) and define what specific portions of the lifecycle we are trying to measure such as:\n- latency from subscribe to first onNext\n- latency from subscribe to terminal event\n- single onNext\n- multi onNext\n- contended merge\n- non-contended merge\n- etc\n\nThen we'd have to decide if we're optimizing for a lower and\/or more consistent max latency (say at the 99.99th percentile) while trading off a higher median. This would reduce throughput but give more reliable latency characteristics. \n\nAre either of you suggesting that we need to gather these stats and consider changes in our optimizations? Or is it really just throughput that we're still discussing (which the 30k -> 22k decrease suggests)?\n\n> Since one can't let this thread spin and make it eventually sleep\n\nJust because RxJava never lets a thread spin doesn't mean a DisruptorScheduler couldn't choose to make this trade-off. High-performance systems often do this kind of thing. As a general rule though I don't think it's valuable as it assumes the rest of the system is correctly configured to not try and use the CPU core with the spinning thread. \n\n> concurrent producers don't block each other\n\nThis type of design could offer a very different strategy for merge. I have sometimes considered whether there is room for a different variant of `merge`, or different operator name altogether that accepts a `Scheduler` and effectively is `observeOn` except for many-to-one instead of one-to-one. We could use a non-blocking MPSC queue on the producing side and single thread on the consuming side. I'm curious as to whether we could achieve better performance (throughput and\/or latency) than `merge.observeOn`. I imagine we could. The MPSC queue would however still need to account for backpressure, so it would still need at least those counters per producer. \n\n> Also timed execution and in-queue cancellation might be difficult to accomplish with it.\n\nI don't have enough practical experience with Disruptor to know. \n"},{"date":"2014-12-23T03:33:12Z","author":"benjchristensen","text":"I want to understand where the InterruptedExceptions are coming from again. That could very easily be the source of all the problems here. 18k stacktraces being generated could definitely cause a drop from 30k -> 22k. If we solve that the rest of this discussion may be moot. \n\nI again question why we ever interrupt threads: https:\/\/github.com\/ReactiveX\/RxJava\/issues\/1914\n"},{"date":"2014-12-23T06:43:12Z","author":"daschl","text":"@benjchristensen The thing is my event listeners for the Disruptor RingBuffer are single threaded, and all notifications flow through it. My intention to use observeOn here is that if say a user is doing a blocking operation in a map function or whatever when subscribing, he may stall my only thread and everything else gets stalled as well.\n\nSo I thought \"let's move it off to the computation scheduler right away\", so that if they do weird stuff its dragging the box too, but not as hard as if my only lifeline thread stalls.\n\nRegarding the 30k -> 22k, I think latency is the limiting factor here too, given that we don't start the next 5er batch before the first is completed. My main problem is that I can do lots of stuff, but I also need to play it safe since most of the code I've seen out there: people do more harm than good ;)\n"},{"date":"2014-12-23T06:53:15Z","author":"benjchristensen","text":"Can you define what you mean by latency here? I want to know what we are measuring. It seems like it is actually throughput we are discussing due to the 30k -> 22k number. \n\nProtection against blocking is slightly better on the computation scheduler as it isn't just one thread but it is still limited to the number of cores. So if the developer blocks it is going to block the system regardless of which event loop they end up on. =\n"},{"date":"2014-12-23T07:05:20Z","author":"daschl","text":"@benjchristensen In this example the latency is the full wall clock time for an operation against the database. This of course includes network and everything, but this particular test was run against localhost. I know that throughput often affects latency in the high percentile level, but in this case I think we can observe the other effect:\n\nWhen we reduce the latency for each individual request we are increasing throughput, mainly because we are still single threaded (blocking on the 5 ops). I'm aware that this is mostly not a realistic production workload, but a common test that people run (and the increased latency potentially affects them on every call, even if not single threaded).\n\nI also tried it in a very classical (while(true) { doOp() }) thing that users want to run very often. Note that this is completely driven by latency, since you are more or less benchmarking wall clock time. \n\nHere is the do one op blocking one time with and one without observeOn:\n\n![screen shot 2014-12-23 at 08 01 52](https:\/\/cloud.githubusercontent.com\/assets\/29086\/5535259\/3e1672e4-8a7a-11e4-9b2f-83be01f83f3e.png)\n\nSo I'm mainly concerned about end-to-end latency. I can probably optimize more on my end too, but looking into JFR this was the main offender.\n\nIf we can get rid of the exceptions and it fixes the issues even better, because at some point I need to move it to a computation scheduler (since we also do JSON parsing at a higher level).\n"},{"date":"2014-12-23T07:09:04Z","author":"daschl","text":"And as expected the effect magnifies if you increase the batch size (here code like above, but a range from 1 to 100, leading to a 100 batch get):\n\n![screen shot 2014-12-23 at 08 07 33](https:\/\/cloud.githubusercontent.com\/assets\/29086\/5535282\/d9e883ec-8a7a-11e4-9872-54e3c07d42e8.png)\n\nIf it helps, I could do more precise latency numbers with HdrHistogram as well\n"},{"date":"2015-01-06T05:39:26Z","author":"benjchristensen","text":"I know I need to come back and spend some time on this. During Holidays I didn't spend much time on anything, and I'm rather busy in other \"day job\" items right now. Can this wait? Do you have a proposed change?\n\nIt seems the `InterruptedException` issue is the low hanging fruit I'd like solved. \n"},{"date":"2015-01-06T15:04:30Z","author":"daschl","text":"Well, the only thing at this point is that I'm thinking about avoiding observeOn where possible, but its not a solution. If you grab the low hanging fruit, I'll be more than happy to verify :)\n"},{"date":"2015-01-06T15:26:39Z","author":"akarnokd","text":"In #1207 I was wondering if observeOn can be improved by not using any queue since the schedulers already have their queues.\n\nIn your base case, you have 3 messages per value going through the observeOn: onNext, onCompleted and unsubscribe. I think the onCompleted could be omitted if you know exactly how many onNexts there will be: just use a take(5) after the observeOn so upstream is cleaned up. If you don't have control over onNext, you can always concat\/merge with never(), although they are quite heavy, or create your simple operator which simply swallows onCompleted.\n"},{"date":"2015-01-06T17:32:14Z","author":"benjchristensen","text":"Wouldn't it be more expensive to go through the queue used by the Executor since it would need to schedule a new task each time? The idea was that a single schedule step could drain many items from the queue, instead of each item needing to go through the scheduling overhead. \n\nIt would be interesting to have concrete data comparing the two. \n"},{"date":"2015-02-05T16:09:01Z","author":"akarnokd","text":"I did some performance enhancements in #2603. Could you check if you get your performance back?\n"},{"date":"2015-03-11T14:17:29Z","author":"akarnokd","text":"Several performance enhancements have been merged relating observeOn, so closing. If you have further problems, please don't hesitate to reopen this issue or post a new one.\n"},{"date":"2015-03-11T14:30:26Z","author":"daschl","text":"Sounds great, I'll do that if needed. Cheers and thanks again\n"}],"opened_by":"daschl","reopen":false,"closed_on":"2015-03-11T14:17:29Z","description":"Hi folks,\n\nI'm again hunting lost performance and this time it seems that `observeOn` is a major contributor. I think the workload itself is not so important, but I'm fetching 5 docs in a batch from the server, wait and then the next one.  Something like:\n\n``` java\nwhile(true) {\n\n    Observable\n        .range(1, 5)\n        .flatMap(new Func1<Integer, Observable<GetResponse>>() {\n            @Override\n            public Observable<GetResponse> call(Integer i) {\n                return core.<GetResponse>send(new GetRequest(\"\" + i, \"default\"));\n            }\n        })\n        .doOnNext(new Action1<GetResponse>() {\n            @Override\n            public void call(GetResponse getResponse) {\n                getResponse.content().release();\n            }\n        })\n        .toBlocking()\n        .last();\n}\n```\n\nNow when I run it like this, I get 30k ops\/s against my Couchbase Server cluster, which seems fair relatively. Now when I change the code to:\n\n``` java\n.flatMap(new Func1<Integer, Observable<GetResponse>>() {\n    @Override\n    public Observable<GetResponse> call(Integer i) {\n        return core.<GetResponse>send(new GetRequest(\"\" + i, \"default\")).observeOn(env.scheduler());\n    }\n})\n```\n\nI'm not getting over 22k ops\/s, which means I'm loosing 8k ops\/s just by moving it onto a different scheduler. The thing is, I need to move it somewhere else to prevent users from stalling my IO threads. I expect \"some\" loss, but not that much.\n\nI did JFR runs for both sessions over 5 minute periods. I'm not 100% sure what is causing the issues here, but one interesting thing is that with `observeOn` I get contention reported, without it there is no contention:\n\n![screen shot 2014-12-22 at 13 43 26](https:\/\/cloud.githubusercontent.com\/assets\/29086\/5525064\/9138fec8-89e0-11e4-9c23-0bb8e5f813f5.png)\n\nAlso, it looks like the Interrupt Exceptions are back with observeOn (no shown when omitted):\n\n![screen shot 2014-12-22 at 13 46 16](https:\/\/cloud.githubusercontent.com\/assets\/29086\/5525097\/ff9e1f4c-89e0-11e4-9e2c-abeafef9f015.png)\n\nSo my questions are basically:\n\n1) can we improve the observeOn performance to be mostly on-par (loosing a few 100 ops\/s I'm okay with)\n2) if not, is there an alternative way to go that is faster?\n3) @akarnokd didn't you fix the interrupts?\n\nThis is on 1.0.3\n","id":"52646664","title":"observeOn() slowing things down considerably","opened_on":"2014-12-22T12:48:26Z","closed_by":"akarnokd"},{"number":"1955","reopenOn":"2015-01-21T10:39:54Z","comments":[{"date":"2014-12-11T21:34:28Z","author":"akarnokd","text":"This is complicated stuff, maybe an (internal) helper class should be created to help with future producer-backpressure-consumer management.\n"},{"date":"2014-12-11T23:01:15Z","author":"akarnokd","text":"I hope the new `BackpressureDrainManager` provides a common abstraction that let's build backpressure-providing operators that themselves do buffering of some sorts.\n"},{"date":"2014-12-12T03:43:20Z","author":"benjchristensen","text":"Wow, this is some non-trivial stuff. Thanks for tackling this. It's going to take me a bit to grok it. \n"},{"date":"2014-12-15T03:38:22Z","author":"benjchristensen","text":"Anyone else have the time and interest to also do a code review on the concurrency code in this? I'd appreciate more eyes than my own. \n"},{"date":"2014-12-17T21:43:33Z","author":"benjchristensen","text":"I think this code is good to merge. I've asked a variety of clarifying questions that I want to review with you before I merge and release. \n"},{"date":"2015-01-21T10:39:50Z","author":"akarnokd","text":"Re-trigger travis.\n"},{"date":"2015-01-26T07:59:35Z","author":"zsxwing","text":"Could you change CRLFs to LFs in BackpressureDrainManager? \n"},{"date":"2015-01-26T13:04:20Z","author":"akarnokd","text":"> Looks a.accept(o) will always return false. Right?\n\nWe can't know. The consumer way want to terminate after a certain item has been accepted.\n\n> isTerminated, terminate, terminate are not used. Could you explain why adding them?\n\nThis is a base class, some operators may need to do something after termination and before calling drain.\n\n> This is really a complex class. So I prefer to keep it as simple as possible.\n\nThis is an internal base class to help implement backpressure over an abstract queue. The unavoidable complexity is in `drain()`.\n"},{"date":"2015-01-27T06:02:11Z","author":"zsxwing","text":"LGTM now.\n"},{"date":"2015-01-27T07:20:16Z","author":"akarnokd","text":"@benjchristensen your review would be welcome.\n"}],"opened_by":"akarnokd","reopen":true,"closed_on":"2015-02-03T09:00:35Z","description":"This is quite a complex operator with lots of cases.\n\nProperties:\n1) If there aren't any elements queued up and nothing is requested but terminal event received, emit terminal event and quit.\n2) If there are elements in the queue and a terminal flag, and at least the same amount is requested, deliver the events and the terminal event.\n3) If more was requested and more became available just after the loop and before the synchronized block, keep looping.\n3.a) If more was requested but nothing is available or nothing was requested and something is available: quit and let either the onNext or request do the subsequent drain.\n3.b) If elements and termination was produced but not requested: quit and let the request do the drain\n3.c) If termination was requested and no elements produced: loop , emit terminal event and quit.\n\nIn table form:\n\n```\nAvailable | Terminated | Requested | Action | Reason\n   yes         yes          yes       loop    can deliver available\n   yes         yes          false     quit    can't deliver available\n   yes         no           yes       loop    can deliver available\n   yes         no           no        quit    can't deliver available\n   no          yes          yes       loop    loop will deliver termination only and quit\n   no          yes          no        loop    loop will deliver termination only and quit\n   no          no           yes       quit    nothing to deliver\n   no          no           no        quit    nothing to deliver\n```\n","id":"51739780","title":"OnBackpressureXXX: support for common drain manager & fix for former concurrency bugs","opened_on":"2014-12-11T21:23:58Z","closed_by":"akarnokd"},{"number":"1933","reopenOn":null,"comments":[{"date":"2014-12-07T10:46:14Z","author":"akarnokd","text":"That line is probably unnecessary because th InnerSubscriber already requests 70% of the standard buffer capacity (128). The more troubling cases are when there is no check for request(0) in the Producer and getAndAdd lets in multiple threads into the drain phase; sometimes a req 0 does nothing, sometimes it decrements the wip counter to -1 and causes unexpected hangs.\n"},{"date":"2014-12-07T21:24:15Z","author":"abersnaze","text":"I tried to see what happened when it was removed and async merge test of 1000 observables failed (more than 128 observables).\n"},{"date":"2014-12-09T02:41:30Z","author":"davidmoten","text":"see also #1941 \n"},{"date":"2015-03-11T14:15:58Z","author":"akarnokd","text":"I think the fix for this issue has been merged, so closing.\n"}],"opened_by":"abersnaze","reopen":false,"closed_on":"2015-03-11T14:15:58Z","description":"I was working on the adding back pressure logging to the debug hooks and I noticed some strange behavior in the merge operator.\n\nThe code that I'm tracing does\n\n```\nfrom(1,3).flatMap( i -> from(i*10, (i+1)*10) ).take(3).subscribe()\n```\n\nThe merge subscriber has these methods invoked\n\n```\nrx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\n[\n    {\"observer\": \"rx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\", \"type\": \"OnNext\", \"value\": \"rx.Observable@6ed3ef1\", \"from\": \"rx.internal.operators.OperatorMap@71bc1ae4\", \"to\": \"rx.internal.operators.OperatorMerge@7a7b0070\"},\n    {\"observer\": \"rx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\", \"type\": \"Request\", \"n\": 1},\n    {\"observer\": \"rx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\", \"type\": \"OnNext\", \"value\": \"rx.Observable@2437c6dc\", \"from\": \"rx.internal.operators.OperatorMap@71bc1ae4\", \"to\": \"rx.internal.operators.OperatorMerge@7a7b0070\"},\n    {\"observer\": \"rx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\", \"type\": \"Unsubscribe\", \"from\": \"rx.internal.operators.OperatorMap@71bc1ae4\", \"to\": \"rx.internal.operators.OperatorMerge@7a7b0070\"},\n    {\"observer\": \"rx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\", \"type\": \"Request\", \"n\": 1},\n    {\"observer\": \"rx.internal.operators.OperatorMerge$MergeSubscriber@2957fcb0\", \"type\": \"OnCompleted\", \"from\": \"rx.internal.operators.OperatorMap@71bc1ae4\", \"to\": \"rx.internal.operators.OperatorMerge@7a7b0070\"},\n]\n```\n\nThe thing that I don't expect is the additional request(1) after the unsubscribe.  I set up a break point and the request(1) is coming from this line of code.\n\nhttps:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/operators\/OperatorMerge.java#L189\n\nThere probably just needs to be a check there to see if that request(1) is necessary.\n","id":"51213977","title":"Request more after unsubscription","opened_on":"2014-12-07T10:32:40Z","closed_by":"akarnokd"},{"number":"1919","reopenOn":null,"comments":[{"date":"2014-12-02T09:54:08Z","author":"daschl","text":"One thing that is suspicious is that my rx computation pools should be very silent, because I'm using observeOn my own scheduler (a spinoff of the computation one because it does not allow thread naming manually).\n\nSo while they are quiet (see threads) they have lots in their work queue.\n\n![screen shot 2014-12-02 at 10 51 47](https:\/\/cloud.githubusercontent.com\/assets\/29086\/5260636\/5943b24e-7a11-11e4-95a5-724906cbac32.png)\n\n![screen shot 2014-12-02 at 10 53 38](https:\/\/cloud.githubusercontent.com\/assets\/29086\/5260654\/800ab062-7a11-11e4-9e6a-c900956aa2e7.png)\n"},{"date":"2014-12-02T10:02:24Z","author":"daschl","text":"@akarnokd any idea what a ScheduledAction \"null\" is?\n\n![screen shot 2014-12-02 at 11 01 45](https:\/\/cloud.githubusercontent.com\/assets\/29086\/5260757\/ab261a42-7a12-11e4-8d14-8c5a64493091.png)\n\nLooks like it's carrying a Timeout operation which makes sense to be done on the Rx one because I forgot to move it to our computation scheduler. Probably the leak is in the timeout operator?\n\nQuick update: yup that looks like to be the cause, when I remove the timeout operator and do a manual full GC it goes back to steady, nothing leaking there.\n"},{"date":"2014-12-02T10:13:37Z","author":"akarnokd","text":"ScheduledAction extends AtomicReference<Thread> so unless it has run already, it contains a null value. I did this for the free atomic operator(s).\n\nIn addition, there is a shortcoming in Java 6 ScheduledThreadPool where cancelled far-future tasks remain in the pool's queue until their time has actually passed, at when they get just evicted. Java 7 introduced a `setRemoveOnCancelPolicy()` method to get rid of them ASAP (defaults to false for compatibility reasons). (Historical note: in my RxJava predecessor, I had this method called reflectively when a scheduled pool was instantiated.)\n"},{"date":"2014-12-02T10:14:08Z","author":"daschl","text":"@akarnokd see my last update, it seems to be in timeout() .. when I remove it, no leak.\n"},{"date":"2014-12-02T10:17:05Z","author":"daschl","text":"Here is with the timeout operator removed:\n\n![screen shot 2014-12-02 at 11 16 36](https:\/\/cloud.githubusercontent.com\/assets\/29086\/5260941\/bb104be2-7a14-11e4-82c4-ce67a6362bd6.png)\n"},{"date":"2014-12-02T11:28:20Z","author":"benjchristensen","text":"Is the use case able to be represented in a simple unit test so we can reproduce and fix?\n\nIf not then is it a high volume of timeouts (that don't trigger) causing it?\n"},{"date":"2014-12-02T11:34:18Z","author":"daschl","text":"I'm trying to get it into something testable, although since I'm not familiar with the low level internals I don't know how we can prove that it is not leaking. I'll try to get something that at least shows it in a profiler when running it.\n\nBtw note the code that triggers it is very simple: https:\/\/github.com\/couchbase\/couchbase-java-client\/blob\/master\/src\/main\/java\/com\/couchbase\/client\/java\/CouchbaseBucket.java#L288\n\nCould it also be interplay between `timeout()` and the blocking observable conversion that is not doing something that the timeout operator expects?\n"},{"date":"2014-12-02T11:56:15Z","author":"daschl","text":"Okay with something simple like\n\n``` java\nwhile(true) {\n   Observable\n        .timer(5, TimeUnit.MICROSECONDS)\n        .timeout(1, TimeUnit.SECONDS)\n        .toBlocking()\n        .single();\n}\n```\n\nOr chaining in a different scheduler before the timeout its not reproducible, no leaks there. One difference as well is that the code is observing a `AsyncSubject`, I don't know if that makes a difference in this case though.\n"},{"date":"2014-12-02T12:20:10Z","author":"daschl","text":"@akarnokd  @benjchristensen Wow, actually **it is** reproducible with that code. It shows up when you increase the timeout a lot. Could it be that with the current code the task only vanishes once the timeout is over and the actual onComplete does not cancel it?\n\n``` java\nwhile(true) {\n   Observable\n        .timer(5, TimeUnit.MICROSECONDS)\n        .timeout(1, TimeUnit.SECONDS)\n        .toBlocking()\n        .single();\n}\n```\n\n![screen shot 2014-12-02 at 13 18 07](https:\/\/cloud.githubusercontent.com\/assets\/29086\/5262415\/d97f260a-7a25-11e4-96e7-45294248b8bc.png)\n\n``` java\nwhile(true) {\n   Observable\n        .timer(5, TimeUnit.MICROSECONDS)\n        .timeout(100, TimeUnit.SECONDS)\n        .toBlocking()\n        .single();\n}\n```\n\n![screen shot 2014-12-02 at 13 19 04](https:\/\/cloud.githubusercontent.com\/assets\/29086\/5262426\/e47505b6-7a25-11e4-8926-8520881c1a24.png)\n"},{"date":"2015-02-05T16:25:09Z","author":"akarnokd","text":"We've fixed the task retention problem for JDK 6 in 1.0.5. Does the problem still happen for you?\n"},{"date":"2015-02-05T16:35:06Z","author":"daschl","text":"@akarnokd oh you did? which changeset was that? :)\n"},{"date":"2015-02-05T16:41:07Z","author":"akarnokd","text":"@daschl with #2465. I must add, it only works with `ScheduledThreadPoolExecutor` that the JDK is using because the `ScheduledExecutorService` interface doesn't have a `purge` method.\n"},{"date":"2015-03-11T14:22:57Z","author":"akarnokd","text":"I'm closing this due to inactivity. If you have further problems, please don't hesitate to reopen this issue or post a new one.\n"}],"opened_by":"daschl","reopen":false,"closed_on":"2015-03-11T14:22:57Z","description":"Hi folks,\n\n(update, see below, looks like it's the timeout operator) \n\nI'm raising a ticket earlier than later, because I suspect we have a leak somewhere in the Scheduler logic. It could by in my code too, but from the characteristics it looks more like something rx internal.\n\nI've been able to generate some OOM scenarios where GC takes all the time to clean things up and it's not able to, which pointed me to a leak. A heap dump showed the leak suspect is the ScheduledFutureTask as part of the computation scheduler:\n\n![screen shot 2014-12-02 at 10 40 28](https:\/\/cloud.githubusercontent.com\/assets\/29086\/5260491\/b9420760-7a0f-11e4-874f-e8e9ad22a918.png)\n\nYou can see a full GC kicking in without actually making old gen smaller:\n\n![screen shot 2014-12-02 at 10 42 50](https:\/\/cloud.githubusercontent.com\/assets\/29086\/5260509\/044a317e-7a10-11e4-8cc3-b3a17bd1d1f6.png)\n\nThe code path uses both .observeOn() once to move it onto a scheduler and also blocks .single() at the very end. So I'll start looking in those places. But maybe @akarnokd or @benjchristensen you have an idea where I can start debugging?\n","id":"50630265","title":"(Updated): timeout() operator leaking ScheduledFutureTasks on Scheduler","opened_on":"2014-12-02T09:44:16Z","closed_by":"akarnokd"},{"number":"1904","reopenOn":null,"comments":[{"date":"2014-11-29T21:19:53Z","author":"benjchristensen","text":"Thank you.\n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2014-11-29T21:20:02Z","description":"`Scan` may request 0 when n is 1 and `request(0)` makes the source `Observable` do nothing. The unit test demonstrates this bug.\n","id":"50431068","title":"Fix the bug that Scan may request 0 when n is 1","opened_on":"2014-11-29T16:57:53Z","closed_by":"benjchristensen"},{"number":"1900","reopenOn":null,"comments":[{"date":"2014-11-29T05:07:05Z","author":"benjchristensen","text":"Fixed in #1901\n"}],"opened_by":"neerajrj","reopen":false,"closed_on":"2014-11-29T05:07:05Z","description":"For an operator chain like o.retry().groupBy().... if the source Observable has >= 1024 items the JVM seems to hang. Repeated unsubscribe calls seem to be sent by retry() upwards\nhttps:\/\/gist.github.com\/neerajrj\/8bb9106ca1b81e08a40f\n","id":"49971712","title":"retry() hangs when it is followed by a group by with >= 1024 items","opened_on":"2014-11-25T03:06:57Z","closed_by":"benjchristensen"},{"number":"1891","reopenOn":null,"comments":[{"date":"2014-11-24T08:43:52Z","author":"zsxwing","text":"Is it possible you sent some `null` to `zip`?\n"},{"date":"2014-11-24T16:16:10Z","author":"vadims","text":"No\n"},{"date":"2014-11-30T00:18:02Z","author":"vadims","text":"I can no longer reproduce this with RxJava 1.0.1\n"},{"date":"2014-11-30T03:10:34Z","author":"benjchristensen","text":"Great, thanks for confirming.\n"}],"opened_by":"vadims","reopen":false,"closed_on":"2015-01-21T12:24:47Z","description":"While trying to narrow down #1890 we saw the following exception a couple of times (out of several hundred executions) on RxJava 1.0.0-RC12.\n\n``` java\n    Exception in thread \"RxComputationThreadPool-4\" java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:52)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.NullPointerException\n    at rx.internal.operators.OperatorZip$Zip.tick(OperatorZip.java:234)\n    at rx.internal.operators.OperatorZip$ZipProducer.request(OperatorZip.java:172)\n    at rx.Subscriber.request(Subscriber.java:110)\n    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.requestMore(OperatorConcat.java:191)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.requestFromChild(OperatorConcat.java:116)\n    at rx.internal.operators.OperatorConcat$ConcatSubscriber.access$000(OperatorConcat.java:65)\n    at rx.internal.operators.OperatorConcat$ConcatProducer.request(OperatorConcat.java:60)\n    at rx.Subscriber.request(Subscriber.java:110)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:310)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.access$400(OperatorMerge.java:93)\n    at rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:502)\n    at rx.Subscriber.request(Subscriber.java:110)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:310)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.access$400(OperatorMerge.java:93)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:687)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:541)\n    at rx.internal.operators.OperatorDelay$1$2.call(OperatorDelay.java:76)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)\n    ... 7 more\n```\n","id":"49296802","title":"NullPointerException","opened_on":"2014-11-18T21:38:04Z","closed_by":"akarnokd"},{"number":"1890","reopenOn":null,"comments":[{"date":"2014-11-18T21:56:57Z","author":"abersnaze","text":"As an interesting data point: I saw it complete the first time I ran it in the debugger but not the second.  I was using Hystrix 1.4.0\n"},{"date":"2014-11-18T22:06:02Z","author":"vadims","text":"Adding a `onBackpressureBuffer()` after the first concatMap worked, though I thought concatMap supported backpressure already?\n"},{"date":"2014-11-19T07:02:11Z","author":"benjchristensen","text":"concatMap should be fine. I bet `buffer` is the issue. Someone else the other day told me there may be an issue with it.\n"},{"date":"2014-11-19T14:09:25Z","author":"akarnokd","text":"Assuming I can replace the Hystrix part with Observable::just, I ran this in a loop with the fixes in #1893 and got all 1024 values all the time.\n"},{"date":"2014-11-19T16:32:44Z","author":"vadims","text":"I'm not sure that it's `buffer` since \n\n``` java\n    List<Integer> source = new ArrayList<>(1024);\n    for (int i = 0; i < 1024; i++) {\n      source.add(i);\n    }\n\n    Observable.from(Lists.partition(source, 20))\n        .concatMap(value -> (new EchoCommand<>(value)).toObservable())\n        .flatMap(Observable::from)\n        .concatMap(value -> (new EchoCommand<>(value)).toObservable())\n        .doOnNext(value -> System.out.println(\"value: \" + value))\n        .toBlocking().lastOrDefault(null);\n\n    System.out.println(\"Done\");\n    Hystrix.reset();\n```\n\nstill has the issue and no longer uses `buffer`. `Lists.partition` is from Guava.\n"},{"date":"2014-11-19T16:56:01Z","author":"vadims","text":"#1893 fixes this issue.. tried with the simple Hystrix example above and our actual codebase where we hit this initially. Thanks!\n"},{"date":"2014-11-29T04:51:07Z","author":"benjchristensen","text":"#1893 is merged so closing this. Thanks @vadims for the report and helping fix this. \n"}],"opened_by":"vadims","reopen":false,"closed_on":"2014-11-29T04:51:07Z","description":"The following piece of code used to emit all 1024 items and print \"Done\" using RxJava 0.19.6 \/ Hystrix 1.3.18.\n\nWhen using RxJava versions 0.20 to 1.0.0 the code stops emitting after 20 items and never prints \"Done\". We tried to simplify this further, unfortunately it stops reproducing if we remove any of the operators from the chain below.\n\nWe suspect that it's due to backpressure support since it was added when this stopped working.\n\n``` java\npublic class Test {\n\n  public static void main(String[] args) {\n    Observable.range(0, 1024)\n        .buffer(20)\n        .concatMap(value -> (new EchoCommand<>(value)).toObservable())\n        .flatMap(Observable::from)\n        .concatMap(value -> (new EchoCommand<>(value)).toObservable())\n        .doOnNext(value -> System.out.println(\"value: \" + value))\n        .toBlocking().lastOrDefault(null);\n\n    System.out.println(\"Done\");\n    Hystrix.reset();\n  }\n\n  public static class EchoCommand<T> extends HystrixCommand<T> {\n\n    private final T value;\n\n    public EchoCommand(T value) {\n      super(HystrixCommandGroupKey.Factory.asKey(\"Echo\"));\n      this.value = value;\n    }\n\n    @Override\n    protected T run() throws Exception {\n      return value;\n    }\n  }\n}\n```\n","id":"49296319","title":"Backpressure issue","opened_on":"2014-11-18T21:33:55Z","closed_by":"benjchristensen"},{"number":"1885","reopenOn":null,"comments":[{"date":"2015-01-21T12:24:08Z","author":"akarnokd","text":"I think this issue has been fixed.\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2015-01-21T12:24:08Z","description":"As per discussion in https:\/\/github.com\/ReactiveX\/RxJava\/pull\/1866#issuecomment-62782835 there may be a thread-safety issue in `merge`:\n\n> I don't fully understand the OperatorMerge, but it contains a lot of mutable variables and synchronized blocks and I'm not sure but I found some anomalies in:\n> \n> https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/operators\/OperatorMerge.java#L505\n> \n> It synchronizes on the MergeProducer's this but reads the MergeSubscriber's wip field which generally is accessed through the MergeSubscriber's this. Same seems to be true for the scalarValueQueue.\n","id":"48929484","title":"Possible Thread Safety Issue in Merge","opened_on":"2014-11-15T19:58:17Z","closed_by":"akarnokd"},{"number":"1881","reopenOn":null,"comments":[{"date":"2014-11-15T10:32:23Z","author":"headinthebox","text":"I'd be happy with `Func<0>` as the only way, but then we have to do the same for `reduce` and anything else that takes a seed.\n"},{"date":"2014-11-15T10:35:07Z","author":"headinthebox","text":"BTW, if we do this, then we should consider generalizing to returning `S` since we are side-effecting `R`, so it does not matter to return return the mutable state variable since that is passed in by the implementation.\n\n`scan(Func0<R>, Func2<R, ? super T, S>)`\n"},{"date":"2014-11-15T14:32:25Z","author":"benjchristensen","text":"I have submitted #1883 to fix the ambiguity that happens with lambdas. \n\nI have changed `scan`, `reduce` and `collect`. I don't see anywhere else that needs to change.\n"},{"date":"2014-11-15T17:24:16Z","author":"benjchristensen","text":"I'm going to pull the factory overload until 1.1 so we make sure we get this right. \n"},{"date":"2014-11-15T19:50:03Z","author":"benjchristensen","text":"Fixed in #1884 by deleting the ambiguous new factory overloads for `scan` and `reduce` and modifying `collect` to support the mutable case with a seed factory and side-affection action.\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2014-11-15T19:50:06Z","description":"I think the recent additions to `scan`\/`reduce` may cause issues\n\n``` java\nscan(R, Func2<R, ? super T, R>)\nscan(Func0<R>, Func2<R, ? super T, R>)\n```\n\nThe `Func0` passed in looks like it can be treated like an `Object` and considered ambiguous and match with `R` instead of `Func0`.\n\nHere is a compilation error:\n\n```\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project learnrxjava: Compilation failure: Compilation failure:\n[ERROR] \/Users\/benjchristensen\/development\/github\/learnrxjava\/src\/main\/java\/learnrxjava\/examples\/ScanVsReduceExample.java:[10,32] reference to reduce is ambiguous\n[ERROR] both method <R>reduce(R,rx.functions.Func2<R,? super T,R>) in rx.Observable and method <R>reduce(rx.functions.Func0<R>,rx.functions.Func2<R,? super T,R>) in rx.Observable match\n[ERROR] \/Users\/benjchristensen\/development\/github\/learnrxjava\/src\/main\/java\/learnrxjava\/examples\/ScanVsReduceExample.java:[10,39] incompatible types: cannot infer type-variable(s) R\n[ERROR] (argument mismatch; java.lang.Object is not a functional interface)\n[ERROR] \/Users\/benjchristensen\/development\/github\/learnrxjava\/src\/main\/java\/learnrxjava\/examples\/ScanVsReduceExample.java:[17,32] reference to scan is ambiguous\n[ERROR] both method <R>scan(R,rx.functions.Func2<R,? super T,R>) in rx.Observable and method <R>scan(rx.functions.Func0<R>,rx.functions.Func2<R,? super T,R>) in rx.Observable match\n[ERROR] \/Users\/benjchristensen\/development\/github\/learnrxjava\/src\/main\/java\/learnrxjava\/examples\/ScanVsReduceExample.java:[17,37] incompatible types: cannot infer type-variable(s) R\n[ERROR] (argument mismatch; java.lang.Object is not a functional interface)\n[ERROR] -> [Help 1]\n```\n\nHere is example code: https:\/\/github.com\/jhusain\/learnrxjava\/blob\/master\/src\/main\/java\/learnrxjava\/examples\/ScanVsReduceExample.java\n\n``` java\npackage learnrxjava.examples;\n\nimport java.util.ArrayList;\n\nimport rx.Observable;\n\npublic class ScanVsReduceExample {\n\n    public static void main(String... args) {\n        Observable.range(0, 10).reduce(() -> new ArrayList<Integer>(), (list, i) -> {\n            list.add(i);\n            return list;\n        }).forEach(System.out::println);\n\n        System.out.println(\"... vs ...\");\n\n        Observable.range(0, 10).scan(() -> new ArrayList<Integer>(), (list, i) -> {\n            list.add(i);\n            return list;\n        }).forEach(System.out::println);\n    }\n}\n```\n\nIt looks like we need to do one of 3 things:\n\n1) Remove one of several things:\n\n``` java\nscan(R, Func2<R, ? super T, R>)\nscan(Func0<R>, Func2<R, ? super T, R>)\n```\n\n2) Rename one of them\n\n3) Add an extra argument so arity solves it.\n\nI actually think the most correct thing to do is remove `scan(R, Func2<R, ? super T, R>)` since an initial value is most often intended for mutable state in `scan`\/`reduce`. \n\ncc @headinthebox as this is a last minute API fix we need prior to Monday for 1.0\n","id":"48878398","title":"Scan\/Reduce Overloads & Type Erasure","opened_on":"2014-11-15T06:36:07Z","closed_by":"benjchristensen"},{"number":"1880","reopenOn":null,"comments":[{"date":"2014-11-14T07:54:02Z","author":"akarnokd","text":"The hang is caused by the interplay between the source, take and flatMap. Take terminates the window just after receiving the last observable and terminates the source which never emits an onCompleted required by the flatMap to terminate as well. Adding an s.onCompleted() after the while loop makes the app terminate properly.\n"},{"date":"2014-11-14T08:05:09Z","author":"benjchristensen","text":"If it unsubscribe though it shouldn't need an `onComplete`. This suggests to me there is an issue inside `window`. \n"},{"date":"2014-11-14T08:08:29Z","author":"akarnokd","text":"flatMap  hangs because there is no one to call onCompleted on the last BufferUntilSubscriber being merged by flatMap. So if window is unsubscribed, it has to send out onCompleted events to all of the open windows just in case.\n"},{"date":"2015-02-05T16:31:30Z","author":"akarnokd","text":"Do we still want to pursue this?\n"},{"date":"2015-05-20T11:30:37Z","author":"akarnokd","text":"I think I found the problem: window(time) didn't defer the child unsubscription properly. See #2972 for the resolution.\n"},{"date":"2015-08-13T00:59:07Z","author":"akarnokd","text":"Should be fixed.\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2015-08-13T00:59:07Z","description":"Something about this doesn't let the JVM exit.\n\n``` java\npackage learnrxjava.examples;\n\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.Subscriber;\nimport rx.schedulers.Schedulers;\n\npublic class FlowControlWindowExample {\n\n    public static void main(String args[]) {\n        \/\/ buffer every 500ms (using 999999999 to mark start of output)\n        hotStream().window(500, TimeUnit.MILLISECONDS).take(10).flatMap(w -> w.startWith(999999999)).toBlocking().forEach(System.out::println);\n\n        \/\/ buffer 10 items at a time (using 999999999 to mark start of output)\n        hotStream().window(10).take(2).flatMap(w -> w.startWith(999999999)).toBlocking().forEach(System.out::println);\n\n        System.out.println(\"Done\");\n    }\n\n    \/**\n     * This is an artificial source to demonstrate an infinite stream that bursts intermittently\n     *\/\n    public static Observable<Integer> hotStream() {\n        return Observable.create((Subscriber<? super Integer> s) -> {\n            while (!s.isUnsubscribed()) {\n                \/\/ burst some number of items\n                for (int i = 0; i < Math.random() * 20; i++) {\n                    s.onNext(i);\n                }\n                try {\n                    \/\/ sleep for a random amount of time\n                    \/\/ NOTE: Only using Thread.sleep here as an artificial demo.\n                    Thread.sleep((long) (Math.random() * 1000));\n                } catch (Exception e) {\n                    \/\/ do nothing\n                }\n            }\n        }).subscribeOn(Schedulers.newThread()); \/\/ use newThread since we are using sleep to block\n    }\n\n}\n```\n\nYet this one does so it's not about the use of `Scheduler`s:\n\n``` java\npackage learnrxjava.examples;\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.Subscriber;\nimport rx.schedulers.Schedulers;\n\npublic class FlowControlThrottleExample {\n\n    public static void main(String args[]) {\n        \/\/ first item emitted in each time window\n        hotStream().throttleFirst(500, TimeUnit.MILLISECONDS).take(10).toBlocking().forEach(System.out::println);\n\n        \/\/ last item emitted in each time window\n        hotStream().throttleLast(500, TimeUnit.MILLISECONDS).take(10).toBlocking().forEach(System.out::println);\n    }\n\n    \/**\n     * This is an artificial source to demonstrate an infinite stream that emits randomly\n     *\/\n    public static Observable<Integer> hotStream() {\n        return Observable.create((Subscriber<? super Integer> s) -> {\n            int i = 0;\n            while (!s.isUnsubscribed()) {\n                s.onNext(i++);\n                try {\n                    \/\/ sleep for a random amount of time\n                    \/\/ NOTE: Only using Thread.sleep here as an artificial demo.\n                    Thread.sleep((long) (Math.random() * 100));\n                } catch (Exception e) {\n                    \/\/ do nothing\n                }\n            }\n        }).subscribeOn(Schedulers.newThread());\n    }\n\n}\n```\n","id":"48746441","title":"JVM Doesn't Exit On This Window Example","opened_on":"2014-11-14T07:34:21Z","closed_by":"akarnokd"},{"number":"1867","reopenOn":null,"comments":[{"date":"2014-11-12T17:14:23Z","author":"benjchristensen","text":"Putting on 1.0.x though we might be able to get this in for 1.0.\n\nThank you for the report and sample code. \n"},{"date":"2014-11-19T12:25:18Z","author":"YannRobert","text":"fixed in 1.0.0-RC12\n"}],"opened_by":"YannRobert","reopen":false,"closed_on":"2014-11-19T12:25:18Z","description":"The usage of 2 RxJava buffers with both a timespan and a count will eventually make the events be emitted at a very slow rate to the subscriber.\nThe observed rate will be as slow as 1 item per whatever is the second buffer timespan.\n\nPlease see the following Gist for the JUnit code demonstrating the issue.\nhttps:\/\/gist.github.com\/YannRobert\/32921e8e88c62c5af1f9\n","id":"48520767","title":"usage of 2 buffers with both a timespan and a count","opened_on":"2014-11-12T15:13:28Z","closed_by":"YannRobert"},{"number":"1865","reopenOn":null,"comments":[{"date":"2014-11-12T12:32:28Z","author":"stackfull","text":"tested on 1.0.0-rc.10\n"},{"date":"2014-11-15T20:00:08Z","author":"benjchristensen","text":"I merged the fix.\n"}],"opened_by":"stackfull","reopen":false,"closed_on":"2014-11-15T20:00:08Z","description":"This little baby will grind to a halt do due never letting go of the events:\n\n``` java\nimport rx.subjects.ReplaySubject;\n\npublic class Application {\n  public static void main(String[] args) {\n    ReplaySubject<Integer> subject = ReplaySubject.createWithSize(10);\n    subject.subscribe(x -> {});\n    int ii = 0;\n    while(true) {\n      subject.onNext(ii);\n      ii++;\n    }\n  }\n}\n```\n","id":"48504812","title":"ReplaySubject memory leak","opened_on":"2014-11-12T12:26:45Z","closed_by":"benjchristensen"},{"number":"1845","reopenOn":null,"comments":[{"date":"2014-11-11T02:56:05Z","author":"benjchristensen","text":"Are you able to reproduce this and can you provide a unit test?\n\nDoes this also occur with RxJava 1.0.0-rc.10? \n"},{"date":"2014-11-11T19:25:59Z","author":"laktech","text":"I was able to consistently reproduce this bug with the following:\n\nhttps:\/\/gist.github.com\/laktech\/5bba374f394d12956210\n\nand here is the stack trace for the unit test:\n\nhttps:\/\/gist.github.com\/laktech\/dcac7edb94fde2d037a6\n\nIt fails on both 0.20.6 and 1.0.0-rc.10. Succeeds on 0.19.6.\n"},{"date":"2014-11-11T19:34:28Z","author":"benjchristensen","text":"Thanks. I'll look at this.\n"},{"date":"2014-11-11T21:09:20Z","author":"akarnokd","text":"The queue is null on that line, so either it was released before, or the pool didn't provide one at start or there is a visibility issue because it is not volatile.\n"},{"date":"2014-11-15T20:02:44Z","author":"benjchristensen","text":"> I was able to consistently reproduce this bug with the following:\n\nThank you, very helpful. It fails every time for me ... but if I remove `subscribeOn` it works so there is a race condition somewhere. \n\nWorking on this now.\n"},{"date":"2014-11-15T20:17:39Z","author":"benjchristensen","text":"The code can be fixed by removing the nested `subscribe` and composing things:\n\n``` java\n    private Observable<Integer> keysObservable() {\n        return Observable.range(0, 10000).flatMap(new Func1<Integer, Observable<Integer>>() {\n\n            @Override\n            public Observable<Integer> call(final Integer t1) {\n                return Observable.from(listItems(1)).subscribeOn(executorScheduler);\n\n\/\/                return Observable.create(new OnSubscribe<Integer>() {\n\/\/\n\/\/                    @Override\n\/\/                    public void call(Subscriber<? super Integer> t2) {\n\/\/                        Observable.from(listItems(1)).subscribe(t2);\n\/\/                    }\n\/\/                }).subscribeOn(executorScheduler);\n            }\n        });\n    }\n```\n\nI am still trying to figure out if there is a way to handle the RxRingBuffer issue when it gets unsubscribed prematurely.\n"},{"date":"2014-11-15T20:27:52Z","author":"benjchristensen","text":"This is going to have to be done in 1.0.x as it's going to take some thought and work.\n\nThis is an edge case so I'm comfortable continuing with 1.0 as is since this code has spent a couple months being used.\n\n@laktech I suggest you adopt the composition approach shown in my previous comment and avoid using `subscribe` to compose things together. It chains subscriptions together which can have unexpected results. The composition operators like `merge` (used by `flatMap`) take care of this and use `unsafeSubscribe` to chain subscriptions through.\n\nI'll come back to this and try to figure out a way for RxRingBuffer to behave safely with concurrent unsubscribe while not killing the performance. \n"},{"date":"2014-11-15T20:35:30Z","author":"laktech","text":"@benjchristensen Thanks for looking into this.\n\nAre there any semantical differences between using `subscribe` and the composition approach? My motivation to invoke `subscribe` was to ensure `listFiles(1)` was 1) invoked for each subscriber and 2) not called until there was a subscriber, which is very explicit with `subscribe`. It seems easy to test but thought I'd just ask :-P\n"},{"date":"2014-11-15T20:38:50Z","author":"benjchristensen","text":"Semantically no, it will get invoked the same as what is being done via the manual `Observable.create`.`subscribe`. If you change the `subscribe` to `unsafeSubscribe` you'll get the correct behavior without the over-eager unsubscribe which is causing the issues.\n"},{"date":"2014-11-15T20:39:20Z","author":"laktech","text":"Great, thanks for the work-around.\n"},{"date":"2014-11-15T20:44:41Z","author":"benjchristensen","text":"Reading code again, the `listFiles(1)` is slightly more eager in the composed version and will happen on the emitting thread rather than the `subscribeOn` thread since it happens inside the `flatMap` rather than the `subscribeOn`. \n\nSo if you want to solve that you could use `defer`:\n\n``` java\nreturn Observable.defer(() -> Observable.from(listItems(1))).subscribeOn(executorScheduler);\n```\n\nIn my test this moves the `listItems` from the main thread to the scheduler thread.\n"},{"date":"2014-11-19T16:08:19Z","author":"akarnokd","text":"I've tried to fix this but apart from making the NPE go away by reading queue once everywhere and not adding the RxRingBuffer to the InnerSubscription to be unsubscribed, I'm lost. What I would like to do is to call queue.unsubscribe if the inner subscription receives an onError or onCompleted, but due to backpressure, I'm not certain if putting it into drainRequested and drainAll is enough.\n\nhttps:\/\/gist.github.com\/akarnokd\/fc1f2e1946bb39e8794a\n"},{"date":"2015-02-05T16:31:58Z","author":"akarnokd","text":"Fixed in 1.0.5.\n"}],"opened_by":"laktech","reopen":false,"closed_on":"2015-02-05T16:31:58Z","description":"rx-java version 0.20.6\n\n```\njava.lang.NullPointerException\n        at rx.internal.util.RxRingBuffer.poll(RxRingBuffer.java:282)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.drainAll(OperatorMerge.java:723)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.drainQueue(OperatorMerge.java:744)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.access$300(OperatorMerge.java:505)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber$1.call(OperatorMerge.java:376)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber$1.call(OperatorMerge.java:369)\n        at rx.internal.util.IndexedRingBuffer.forEach(IndexedRingBuffer.java:281)\n        at rx.internal.util.IndexedRingBuffer.forEach(IndexedRingBuffer.java:247)\n        at rx.internal.util.SubscriptionIndexedRingBuffer.forEach(SubscriptionIndexedRingBuffer.java:131)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainChildrenQueues(OperatorMerge.java:331)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:308)\n        at rx.internal.operators.OperatorMerge$MergeSubscriber.access$400(OperatorMerge.java:96)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:674)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:528)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)\n        at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:105)\n        at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:96)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1$1.request(OperatorSubscribeOn.java:88)\n        at rx.Subscriber.setProducer(Subscriber.java:150)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1.setProducer(OperatorSubscribeOn.java:81)\n        at rx.Subscriber.setProducer(Subscriber.java:144)\n        at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47)\n        at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:33)\n        at rx.Observable.subscribe(Observable.java:8680)\n        at ********************\n        at ********************\n        at rx.Observable.unsafeSubscribe(Observable.java:8591)\n        at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n        at rx.schedulers.ExecutorScheduler$ExecutorAction.run(ExecutorScheduler.java:173)\n        at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:99)\n        at java.util.concurrent.ForkJoinTask$AdaptedRunnable.exec(ForkJoinTask.java:1265)\n        at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:334)\n        at java.util.concurrent.ForkJoinWorkerThread.execTask(ForkJoinWorkerThread.java:604)\n        at java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:784)\n        at java.util.concurrent.ForkJoinPool.work(ForkJoinPool.java:646)\n        at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:398)\n```\n","id":"48302315","title":"RxRingBuffer Concurrent Unsubscribe Non-ThreadSafe","opened_on":"2014-11-10T19:18:39Z","closed_by":"akarnokd"},{"number":"1826","reopenOn":null,"comments":[{"date":"2014-11-06T00:21:17Z","author":"benjchristensen","text":"Thanks for the report.\n"}],"opened_by":"alexwen","reopen":false,"closed_on":"2014-11-06T07:05:15Z","description":"Although I have not been able to find a way to reproduce the issue reliably, I have seen the following stack several times now:\n\n```\n ! java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@328cda0 rejected from java.util.concurrent.ScheduledThreadPoolExecutor@2200705d[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 3]\n ! at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) ~[na:1.8.0_20]\n ! at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) [na:1.8.0_20]\n ! at java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:326) ~[na:1.8.0_20]\n ! at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:533) ~[na:1.8.0_20]\n ! at java.util.concurrent.ScheduledThreadPoolExecutor.submit(ScheduledThreadPoolExecutor.java:632) ~[na:1.8.0_20]\n ! at rx.internal.schedulers.NewThreadWorker.scheduleActual(NewThreadWorker.java:66) ~[sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947.jar:0.1-SNAPSHOT]\n ! at rx.schedulers.CachedThreadScheduler$EventLoopWorker.schedule(CachedThreadScheduler.java:149) ~[sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947.jar:0.1-SNAPSHOT]\n ! at rx.schedulers.CachedThreadScheduler$EventLoopWorker.schedule(CachedThreadScheduler.java:139) ~[sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947.jar:0.1-SNAPSHOT]\n```\n\nWhile auditing the CachedThreadScheduler, I noticed a potential race condition when evicting workers from the eviction queue, from CachedThreadScheduler:\n\n```\n        void evictExpiredWorkers() {\n            if (!expiringWorkerQueue.isEmpty()) {\n                long currentTimestamp = now();\n\n                Iterator<ThreadWorker> threadWorkerIterator = expiringWorkerQueue.iterator();\n                while (threadWorkerIterator.hasNext()) {\n                    ThreadWorker threadWorker = threadWorkerIterator.next();\n                    if (threadWorker.getExpirationTime() <= currentTimestamp) {\n                        threadWorkerIterator.remove();\n                        threadWorker.unsubscribe();\n                    } else {\n                        \/\/ Queue is ordered with the worker that will expire first in the beginning, so when we\n                        \/\/ find a non-expired worker we can stop evicting.\n                        break;\n                    }\n                }\n            }\n        }\n```\n\nThe evictor, uses an `iterator#remove` in order to remove the work from the queue, but it does not check that this operation actually occurred. The iterator, though thread safe, is not atomic for .next and .remove, so, the worker could be pulled from the cache by another thread between the .next and the .remove.\n\nIf this occurs then the the NewThreadWorker will be unsubscribed, its executor shutdown, and the next action that executes on that worker would cause the exception above.\n\nIn order to fix this race I believe the evictor would need to check that it removed the worker from the queue, before attempting to unsubscribe the worker.\n","id":"47907671","title":"Race with CachedThreadScheduler Eviction","opened_on":"2014-11-06T00:18:19Z","closed_by":"benjchristensen"},{"number":"1818","reopenOn":null,"comments":[],"opened_by":"benjchristensen","reopen":false,"closed_on":"2014-11-02T06:50:12Z","description":"This unit tests causes `concat` to never complete:\n\n``` java\n    @Test\n    public void testConcatWithNonCompliantSourceDoubleOnComplete() {\n        Observable<String> o = Observable.create(new OnSubscribe<String>() {\n\n            @Override\n            public void call(Subscriber<? super String> s) {\n                s.onNext(\"hello\");\n                s.onCompleted();\n                s.onCompleted();\n            }\n\n        });\n\n        TestSubscriber<String> ts = new TestSubscriber<String>();\n        Observable.concat(o, o).subscribe(ts);\n        ts.awaitTerminalEvent(500, TimeUnit.MILLISECONDS);\n        ts.assertTerminalEvent();\n        ts.assertNoErrors();\n        ts.assertReceivedOnNext(Arrays.asList(\"hello\", \"hello\"));\n    }\n```\n\nThis was found by @mattrjacobs \n","id":"47528944","title":"Concat Breaks with Double onCompleted","opened_on":"2014-11-02T06:41:10Z","closed_by":"benjchristensen"},{"number":"1816","reopenOn":null,"comments":[],"opened_by":"benjchristensen","reopen":false,"closed_on":"2014-11-02T04:08:05Z","description":"If an exception is thrown from a synchronous `OnSubscribe` it will skip the operators such as `onErrorResumeNext`.\n\nFor example:\n\n``` java\nObservable.create(subscriber -> {\n throw new RuntimeException(\"failed!\");\n}).onErrorResumeNext(throwable -> {\n    return Observable.just(\"fallback value\");\n}).subscribe(System.out::println, t -> System.out.println(\"ERROR: \" + t.getMessage()));\n```\n\nIn this case `onErrorResumeNext` is not called and the error passes through.\n","id":"47526283","title":"Synchronous OnSubscribe Exception Skips Operators","opened_on":"2014-11-02T03:57:08Z","closed_by":"benjchristensen"},{"number":"1812","reopenOn":null,"comments":[{"date":"2014-10-31T09:10:47Z","author":"zsxwing","text":"Thanks for reporting it.\n"}],"opened_by":"stevemenke","reopen":false,"closed_on":"2014-10-31T19:28:49Z","description":"The following code never executes the onComplete if the number is greater than 1025. I think it has to due with back pressure which uses a default request of 1024. I am using Java 8 \n\n```\n    Observable merged1 = Observable.zip(Observable.range(0, 1026), Observable.range(0, 1026),\n            (o, e) -> new int[]{o, e});\n    Observable merged2 = Observable.<int[], Integer, int[]>zip(merged1, Observable.range(0, 1026),\n            (o, e) -> new int[]{o[0], o[1], e}).serialize();\n    merged2.subscribe(\n            (o) -> System.out.println(o),\n            e -> {},\n            () -> {\n                System.out.println(\"This never prints\");\n            }\n    );\n```\n\nI am using the following version of Java.\n\njava version \"1.8.0_05\"\nJava(TM) SE Runtime Environment (build 1.8.0_05-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)\n","id":"47305127","title":"Multiple Zipped Observers never complete","opened_on":"2014-10-30T17:55:57Z","closed_by":"benjchristensen"},{"number":"1804","reopenOn":null,"comments":[{"date":"2014-10-28T16:41:15Z","author":"benjchristensen","text":"The only thing in rc8 that seems related is this: https:\/\/github.com\/ReactiveX\/RxJava\/pull\/1793\n"},{"date":"2014-11-02T06:53:43Z","author":"benjchristensen","text":"I can not replicate with this code:\n\n``` java\nimport java.util.List;\n\nimport rx.functions.Func1;\n\npublic class Testing {\n\n    public static void main(String... args) {\n        List<String> subThings = Observable.range(0, 1000)\n                .map(new Func1<Integer, String>() {\n\n                    @Override\n                    public String call(Integer i) {\n                        return String.valueOf(i + 1);\n                    }\n\n                })\n                .filter(new Func1<String, Boolean>() {\n\n                    @Override\n                    public Boolean call(String t) {\n                        return t != null;\n                    }\n\n                }) \/\/\n                .distinct() \/\/\n                .toList() \/\/\n                .toBlocking() \/\/\n                .single();\n\n        System.out.println(subThings);\n    }\n}\n```\n"},{"date":"2014-11-02T07:01:04Z","author":"benjchristensen","text":"The code that is being interrupted is this: https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/observables\/BlockingObservable.java#L473\n\n``` java\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Interrupted while waiting for subscription to complete.\", e);\n        }\n```\n\nThis means the thread was blocked on the latch waiting for a result but while it was waiting it got interrupted. \n\nI don't know what thread you are doing this on, nor do I know much about Android. If Android is using pools of threads it could perhaps retain the right to interrupt and reclaim threads? I know event loops in some frameworks do that kind of thing if something is blocked in them and new work is scheduled. \n\nRxJava itself does not interrupt threads anywhere (that I'm aware of ... and I can't think of any reason we would) so I'm inclined to suggest looking at what thread you are blocking in and see if Android itself could be interrupting it?\n\nAlso, could you move to a model where you don't block and instead compose it all together reactively?\n"},{"date":"2014-11-02T07:02:12Z","author":"benjchristensen","text":"Moving to 1.0.x as it's not obvious yet what is going on here.\n"},{"date":"2014-11-05T04:56:19Z","author":"Alexander--","text":"Encountered this on Jellybean. Code in my Application subclass:\n\n``` java\nObservable<SomeSharedPreferencesWrapper> prefsPrefetch = Async.start(this::prefetchPrefs);\n```\n\nAnd later in same class:\n\n``` java\nreturn prefsPrefetch.toBlocking().single();\n```\n\nI can't grasp exact circumstances, when issue reproduces itself. At first glance they seem to be random, but happens often enough to make prefetching stuff with RxJava pretty much impossible.\n"},{"date":"2014-11-05T05:45:49Z","author":"edenman","text":"I'm gonna work on putting together a minimal test Android app to try and isolate the issue.\n"},{"date":"2014-11-05T06:50:54Z","author":"edenman","text":"https:\/\/dl.dropboxusercontent.com\/u\/7829307\/RxJavaBlockingBug.zip\n\nI wasn't able to repro until I added the PublishSubject layer...maybe the issue is the nested toBlocking() calls?\n"},{"date":"2014-11-06T06:37:31Z","author":"benjchristensen","text":"Does Android ever interrupt a thread based on user or system activity? If so then the `toBlocking()` will always be vulnerable to interruption since anytime a thread is blocked\/waiting it can be interrupted. \n\nIs request.onNext ever being called concurrently, or is it sequentially? I can't tell for sure but it looks okay as it looks like it's only ever the single UI thread that would trigger an onNext. If you intend on calling it concurrently wrap it in a SerializedSubject.\n\nIf the UI event listener triggers before `ObserveThings.start` completes then `request` may not yet be initialized, or the pipeline may not yet be initialized. It looks like that could be race condition ... but I don't understand how `MainActivity` works well enough. Is that all on the UI thread, or does a background thread do that and then the `setOnClickListener` register with the UI thread?\n\nI don't particularly see anything wrong in this code ... though to be more idiomatic I would suggest using the Observable sequence to manipulate the data instead of doing it inside the `subscribe`. You really should never need to use `toBlocking`. The only 3 times that is ever intended are:\n\n1) Example code in a main method\n2) Unit tests (and even then you should probably use TestSubscribe.awaitTerminalEvent instead)\n3) Bridging between a blocking and non-blocking system, such as a Servlet \n\nIn this case, instead of doing flatMap.subscribe(all logic here) do something like this instead:\n\n``` java\nrequest.flatMap(mapResult)\n.map(transformFunction)\n.filter(notNull())\n.distinct()\n.toList()\n.subscribe(yourListHere)\n```\n\nThis is more idiomatic, doesn't involve creating another Observable and never requires doing the `toBlocking` stuff.... which is kind of the point of Rx. You should only ever have 1 subscribe at the very end of your flow and it should just be the side-effect, no actual processing in it.\n"},{"date":"2014-11-06T17:29:44Z","author":"edenman","text":"MainActivity all happens on the main thread, as does the onClickHandler.\n\nI've worked around the problem in our app by no longer using `toBlocking` in our subscribe method, but I still think there might be an Rx bug here.  Android shouldn't interrupt unless there's a deadlock of some sort, and I'm afraid the nested toBlocking calls (discouraged though they may be) are causing the thread to stall.  Regardless, the workaround is easy, so I don't think this should be a 1.0 blocker.  Thanks for looking into it!\n"},{"date":"2014-11-06T17:38:51Z","author":"headinthebox","text":"You should really only ever call to blocking in command line test scripts but never in production code.\n\nIf you really need to end up blocking, you may as well push all the blocking backwardsvand write regular synchrounius code. \n"},{"date":"2014-11-06T17:40:31Z","author":"headinthebox","text":"Maybe we should mark toblocking as depricated (forever) such that you get a warning every time you use it. \n"},{"date":"2014-11-06T19:17:23Z","author":"edenman","text":"Deprecated seems wrong to me since it's never actually going to be removed.  I'm all in favor of updating the docs to reflect the recommended uses of toBlocking, though.  \n\nOr maybe deprecate `toBlocking()` and delegate to a new method called `areYouReallySureYouNeedToBlocking()` or something obnoxious like that?\n"},{"date":"2014-11-06T23:12:34Z","author":"Alexander--","text":"> You should really only ever call to blocking in command line test scripts but never in production code.\n\nNot everyone have their entire codebase under their control. Also in Android there are already plenty of ways to move tasks to background threads: all those legacy `Loader`s, `AsyncTask`s and `AbstractThreadedSyncAdapter`s requires certain data to be available directly without Observable shenanigans.\n\n> Does Android ever interrupt a thread based on user or system activity?\n\nI am not sure about this one, but FutureTask\/ExecutorService combo was working just fine before migrating to RxJava (so was the previous version of RxJava, before updating to rc8).\n"},{"date":"2014-11-06T23:35:04Z","author":"benjchristensen","text":"@edenman\n\n> Android shouldn't interrupt unless there's a deadlock of some sort, and I'm afraid the nested toBlocking calls (discouraged though they may be) are causing the thread to stall.\n\nCan you provide a reference to documentation about how Android does this? That would be helpful. If it does this then any sort of blocking would be vulnerable to interruption. \n\n> Not everyone have their entire codebase under their control.\n\nUnderstood, though I still suggest putting most of the processing into the Observable chain and not even having a `subscribe` step and just going direct to `toBlocking()` if you actually are just using it as an Iterable with higher-order functions. \n"},{"date":"2014-11-06T23:41:53Z","author":"benjchristensen","text":"If this doesn't happen on rc7 but does on rc8 then let's binary search what is causing it. Here is what changed: https:\/\/github.com\/ReactiveX\/RxJava\/releases\/tag\/v1.0.0-rc.8\n\nThis is the only change that may be related: https:\/\/github.com\/ReactiveX\/RxJava\/pull\/1793\/files\n\nNote how it now triggers the unsubscribe upwards before the onNext is emitted whereas before it was after.\n\nThis could theoretically result in work upstream canceling a Future which interrupts a thread if everything is happening on the same thread. \n"},{"date":"2014-11-07T00:44:27Z","author":"edenman","text":"Can't find any Android docs that describe what we're seeing.  [Here](http:\/\/developer.android.com\/training\/articles\/perf-anr.html)'s the docs on ANR (Application Not Responding) but we're seeing an actual crash.  \n\nMaybe worth seeing if it's rxjava itself that is interrupting the thread?\n"},{"date":"2014-11-07T05:57:00Z","author":"benjchristensen","text":"> Maybe worth seeing if it's rxjava itself that is interrupting the thread?\n\nYup, I pointed to a change in rc8 above that could potentially cause this. I'm trying to hunt down options. \n"},{"date":"2014-11-07T06:06:48Z","author":"benjchristensen","text":"Here are the two places I can see that may result in an interrupt:\n- https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/subscriptions\/Subscriptions.java#L102\n- https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/operators\/OnSubscribeToObservableFuture.java#L65\n\nThe first one is used by virtually all use of Schedulers to allow canceling work on a Scheduler. \n\nI still can't replicate an interrupt with `take` but conceptually I can see how an interrupt could happen.\n"},{"date":"2014-11-07T06:11:26Z","author":"benjchristensen","text":"I can replicate:\n\n``` java\n    @Test\n    public void testInterrupt() throws InterruptedException {\n        final AtomicReference<Object> exception = new AtomicReference<Object>();\n        final CountDownLatch latch = new CountDownLatch(1);\n        Observable.just(1).subscribeOn(Schedulers.computation()).take(1).subscribe(new Action1<Integer>() {\n\n            @Override\n            public void call(Integer t1) {\n                try {\n                    Observable.just(t1).toBlocking().single();\n                } catch (Exception e) {\n                    exception.set(e);\n                    e.printStackTrace();\n                } finally {\n                    latch.countDown();\n                }\n            }\n\n        });\n\n        latch.await();\n        assertNull(exception.get());\n    }\n```\n\n```\ncancelling ... and can interrupt\njava.lang.RuntimeException: Interrupted while waiting for subscription to complete.\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:475)\n    at rx.observables.BlockingObservable.single(BlockingObservable.java:349)\n    at rx.internal.operators.OperatorTakeTest$12.call(OperatorTakeTest.java:376)\n    at rx.internal.operators.OperatorTakeTest$12.call(OperatorTakeTest.java:1)\n    at rx.Observable$31.onNext(Observable.java:7209)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:104)\n    at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:70)\n    at rx.internal.operators.OnSubscribeRedo$2$1.onNext(OnSubscribeRedo.java:229)\n    at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:41)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:1)\n    at rx.Observable.unsafeSubscribe(Observable.java:7374)\n    at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.InterruptedException\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1302)\n    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:472)\n    ... 20 more\n```\n\nReverting https:\/\/github.com\/ReactiveX\/RxJava\/pull\/1793 does fix this.\n\nSo now to figure out if https:\/\/github.com\/ReactiveX\/RxJava\/pull\/1793 can be achieved in a different way, or if we need to solve the interruption issue.\n"},{"date":"2014-11-07T06:20:40Z","author":"benjchristensen","text":"Here is a simpler test:\n\n``` java\n    @Test\n    public void testInterrupt() throws InterruptedException {\n        final AtomicReference<Object> exception = new AtomicReference<Object>();\n        final CountDownLatch latch = new CountDownLatch(1);\n        Observable.just(1).subscribeOn(Schedulers.computation()).take(1).subscribe(new Action1<Integer>() {\n\n            @Override\n            public void call(Integer t1) {\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    exception.set(e);\n                    e.printStackTrace();\n                } finally {\n                    latch.countDown();\n                }\n            }\n\n        });\n\n        latch.await();\n        assertNull(exception.get());\n    }\n```\n"},{"date":"2014-11-07T07:00:07Z","author":"benjchristensen","text":"Ugh ... choosing whether to default to interrupting or not is a difficult one. It seems that perhaps we should not. Any insights on this?\n"},{"date":"2014-11-07T07:25:55Z","author":"benjchristensen","text":"I have submitted a possible fix but want to think about this more.\n\nI can't find an authoritative answer on whether we should default to interrupting or not when the scheduled future is canceled. I think we should change to not interrupting but want to be sure that's correct as we've had it set to interrupt all along.\n"},{"date":"2014-11-07T08:14:13Z","author":"headinthebox","text":"> but want to think about this more. \n\nsame here.\n"},{"date":"2014-11-07T11:43:09Z","author":"roman-mazur","text":"A quick note about `Thread` interruptions on Android. AFAIK application process is killed in case of ANRs (either automatically or after a user confirmation). So ANRs do not lead to thread interruptions.\n\nHowever, there is a case when I use `toBlocking` and get an interruption: sync adapter thread. \n\nOn Android we can create a component that will be plugged to the sync part of the framework. Basically Android framework spawns a new thread for you and invokes your code in that thread. Application sync is supposed to be finished when this thread finishes. In our sync adapter code we build a chain of observables that can perform some operations concurrently using other threads. So the sync adapter code invoked in the sync thread looks like `buildChainOfObservables().toBlocking().single();`.\nSync can be canceled (e.g. by user request, unchecking a checkbox in system settings, or when it takes too long). And a default implementation of cancelation request is this sync thread interruption.\n"},{"date":"2014-11-08T03:19:58Z","author":"benjchristensen","text":"@headinthebox A consideration here is that the place we are interrupting the threads is really just for unscheduling any scheduled actions from a Scheduler. I think we intend `subscription.isUnsubscribed()` to be the mechanism for something to gracefully stop. \n\nIt seems to me that we should not interrupt a thread automatically and that if a developer needs to do that their `Observable` should register a `Subscription` via `subscriber.add` that chooses to do so.\n\nWe can work around this particular `take` issue, but it makes me wonder if we would trigger this type of issue anywhere else. It seems that interrupting threads is a very nuanced thing that most code doesn't handle well and that we shouldn't be interrupting threads \"under the covers\".\n\nTherefore I suggest we change from `future.cancel(true)` to `future.cancel(false)` for the 2 places we capture a `Future` and cancel it when unsubscribing. \n"},{"date":"2014-11-08T03:23:02Z","author":"benjchristensen","text":"@roman-mazur Thanks for that information, it is useful information. If I understand correctly you are saying there are normal cases when Android can and will interrupt a thread and thus application code must account for this. Is this what you're saying?\n\nAs far as RxJava is concerned, I'm suggesting we eliminate the two places where RxJava is the culprit for interrupting the thread (despite #1832 working around the particular issue of using `single` that triggers the issue).\n"},{"date":"2014-11-08T06:38:31Z","author":"Alexander--","text":"> It seems to me that we should not interrupt a thread automatically\n\nWait, so you DO interrupt threads right now, don't you? Does that mean, that unsubscribing from Observale (in currently released version), during interruptable operation will interrupt it? Will operations, created with `async-utils` (e.g. via `Async.fromCallable()`) be interrupted? Or is it some internal mechanic for disposing of Schedulers only?\n\nIf former, it would be really cool to leave it be.\n\n> If I understand correctly you are saying there are normal cases when Android can and will interrupt a thread and thus application code must account for this. Is this what you're saying?\n\nI wouldn't call `AbstractThreadedSyncAdpter` a normal case. Interrupting worker thread is just an implementation detail, which can be changed by overriding single method. Also Sync Framework in general is rather special and restrictive environment, and interrupting threads isn't worst thing awaiting developer there (for example, failure to intercept any exceptions may result in Sync Adapter being completely banned from execution by OS).\n"},{"date":"2014-11-08T13:09:56Z","author":"roman-mazur","text":"@benjchristensen I would rather say that Android framework is unlikely to interrupt an application thread. The sync worker is the only known example. And interruption is a default behaviour that can be changed.\n\nBut note that I'm forced to use `toBlocking` within this thread because there is no other way to indicate that sync is finished.\nI wonder what happens when `toBlocking().single()` is interrupted. As far as I understand an error is propagated. Does it lead to un-subscriptions?\n"},{"date":"2014-11-08T15:55:36Z","author":"benjchristensen","text":"@roman-mazur \n\n> I wonder what happens when toBlocking().single() is interrupted. As far as I understand an error is propagated. Does it lead to un-subscriptions?\n\nIf it is interrupted while waiting on the single item we just fail right now. I suppose we could call `unsubscribe` upwards before throwing. \n\nThis is what currently happens:\n\n``` java\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Interrupted while waiting for subscription to complete.\", e);\n        }\n```\n"},{"date":"2014-11-08T16:03:10Z","author":"benjchristensen","text":"@Alexander-- \n\n> Or is it some internal mechanic for disposing of Schedulers only?\n\nRxJava core libraries only interrupt when unsubscribing a scheduled action on a `Scheduler` that is still running. This is in turn just leveraging the `Future.cancel` semantics of Java. RxJava does not actually ever call `Thread.interrupt`.\n\nThe async-utils are just utility methods on top of Schedulers so unless there is some effort to specifically prevent interrupt (nothing I can see while browsing the code) they will also be interrupted if they are still executing when unsubscribe is invoked. \n\n> unsubscribing from Observale (in currently released version), during interruptable operation will interrupt it?\n\nIf a Scheduler is not involved RxJava itself does nothing other than invoke `Subscription.unSubscribe` which flips a boolean and calls any registered callbacks. Thus, an `Observable` implementation can choose to register a `Subscription` that then interrupts and interruptible unit of work. \n\nI'm wondering if that is better for an Observable implementation (via `Observable.create`) to opt-in to interrupts rather than the current `Scheduler` interrupt mechanism which seems like it could be surprising. \n"}],"opened_by":"edenman","reopen":false,"closed_on":"2014-11-08T22:29:14Z","description":"Doesn't happen on rc7.  I can repro 100% of the time.  Happens on both KitKat and Lollipop so I don't think it's specific to any particular Android version.\n\n```\nFATAL EXCEPTION: RxCachedThreadScheduler-4\nProcess: com.mycompany.myapp.development, PID: 4413\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:50)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n        at java.lang.Thread.run(Thread.java:818)\nCaused by: rx.exceptions.OnErrorNotImplementedException: Interrupted while waiting for subscription to complete. \n        at rx.Observable$30.onError(Observable.java:7252)\n        at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:127)\n        at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:96)\n        at rx.internal.operators.OperatorMap$1.onError(OperatorMap.java:48)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)\n        at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)\n        at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitNext(SubjectSubscriptionManager.java:254)\n        at rx.subjects.BehaviorSubject.onNext(BehaviorSubject.java:166)\n        at rx.Observable$34.onNext(Observable.java:7437)\n        at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:104)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:610)\n        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:536)\n        at rx.internal.operators.OperatorSingle$1.onCompleted(OperatorSingle.java:75)\n        at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:72)\n        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)\n        at com.mycompany.servercall.ServerCall$1$1.call(ServerCall.java:56)\n        at com.mycompany.servercall.ServerCall$1$1.call(ServerCall.java:47)\n        at rx.Observable.unsafeSubscribe(Observable.java:7464)\n        at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)\n        ... 7 more \nCaused by: java.lang.RuntimeException: Interrupted while waiting for subscription to complete. \n        at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:474)\n        at rx.observables.BlockingObservable.single(BlockingObservable.java:348)\n        at com.mycompany.myapp.data.CachedThing.buildCachedThing(CachedThing.java:66)\n        at com.mycompany.myapp.data.CachedThing.<init>(CachedThing.java:28)\n        at com.mycompany.myapp.data.FilterFunc.call(FilterFunc.java:189)\n        at com.mycompany.myapp.data.FilterFunc.call(FilterFunc.java:175)\n        at com.mycompany.myapp.data.CachedThing.merge(CachedThing.java:60)\n        at com.mycompany.myapp.data.ResponseCache.update(ResponseCache.java:80)\n        at com.mycompany.myapp.data.TransformFunc.call(TransformFunc.java:105)\n        at com.mycompany.myapp.data.TransformFunc.call(TransformFunc.java:99)\n        at com.mycompany.servercall.CallState$3.map(CallState.java:79)\n        at com.mycompany.servercall.CallState$9.call(CallState.java:195)\n        at com.mycompany.servercall.CallState$9.call(CallState.java:193)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:54)\n        ... 22 more\nCaused by: java.lang.InterruptedException\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1279)\n        at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:202)\n        at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:471)\n        ... 35 more\nCaused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: .class \n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)\n        ... 22 more\n```\n\n`CachedThing.buildCachedThing` has this block of code that I think is the culprit:\n\n```\nList<SubThing> subThings = Observable.from(things) \/\/\n        .map(transformFunction) \/\/\n        .filter(not(isNullFunction)) \/\/\n        .distinct() \/\/\n        .toList() \/\/\n        .toBlocking() \/\/\n        .single();\n```\n\nI tried writing a testcase to repro but couldn't get it to fail.  I'm guessing there's something broken between the android runtime and rxjava's thread management, but I couldn't get any further than that.\n","id":"47036035","title":"\"Interrupted while waiting for subscription to complete.\" in 1.0.0-rc8","opened_on":"2014-10-28T14:58:17Z","closed_by":"benjchristensen"},{"number":"1791","reopenOn":null,"comments":[{"date":"2014-10-23T21:48:59Z","author":"benjchristensen","text":"Manually merged in https:\/\/github.com\/ReactiveX\/RxJava\/pull\/1793\n\nThank you @alexwen for submitting a bug report and then this fix!\n"}],"opened_by":"alexwen","reopen":false,"closed_on":"2014-10-23T21:48:27Z","description":"Noticed this behavior using rx-netty as internally it does a take(1) internally:\n\n```\n    AtomicLong inc = new AtomicLong(0);\n    Observable.OnSubscribe<Long> onSubscribe = subscriber -> {\n        final long emit = inc.getAndIncrement();\n        LOGGER.info(\"Emitting: {}\", emit);\n        subscriber.onNext(emit);\n        subscriber.onCompleted();\n    };\n\n    LOGGER.info(\"DONE: {}\", Observable.create(onSubscribe)\n                    .retryWhen(attempt -> attempt.zipWith(Observable.range(1, 4), (n, i) -> i))\n                    .toBlocking()\n                    .first()\n    );\n```\n\nThe test output is:\n    Emitting: 0\n    Emitting: 1\n    DONE: 0\n\nAs you can see the observable is subscribed to twice. This is because take, in combination with single, causes the retryWhen producer to request another item.\n","id":"46659229","title":"Observable#first causes retryWhen to trigger retry without an exception","opened_on":"2014-10-23T18:28:16Z","closed_by":"benjchristensen"},{"number":"1790","reopenOn":null,"comments":[{"date":"2014-10-23T21:40:04Z","author":"benjchristensen","text":"Hi @ylecaillez, would you mind providing a description of the issue and what your fix is? Also, can you do a pull request that doesn't modify the whitespace and javadoc formatting of the file?\n"},{"date":"2014-11-09T04:52:40Z","author":"benjchristensen","text":"Hi @ylecaillez, would you like to help get this cleaned up and merged?\n"},{"date":"2014-11-11T16:58:59Z","author":"ylecaillez","text":"Hi ! Sure. Please let me a bit more time because i'm quite busy those days. I should be able to clean things up for the end of this week. Best regards.\n"},{"date":"2014-11-11T17:08:40Z","author":"benjchristensen","text":"Thanks. \n"},{"date":"2014-11-29T04:39:24Z","author":"benjchristensen","text":"I manually merged this in https:\/\/github.com\/ReactiveX\/RxJava\/pull\/1903\n"}],"opened_by":"ylecaillez","reopen":false,"closed_on":"2014-11-29T04:39:24Z","description":"","id":"46637557","title":"Time marker is reset when schedule is immediate.","opened_on":"2014-10-23T15:23:25Z","closed_by":"benjchristensen"},{"number":"1756","reopenOn":null,"comments":[],"opened_by":"akarnokd","reopen":false,"closed_on":"2015-01-21T12:20:30Z","description":"While cleaning up, I found a bug caused by too eager delegation:\n\n```\n    public synchronized Object clone() {\n        return list.clone();\n    }\n```\n\nAdding a copy constructor and using that in clone should solve the problem. I'd do it but would conflict with the cleanup changes in the class.\n","id":"45837903","title":"SynchronizedQueue.clone may cause ClassCastException","opened_on":"2014-10-15T07:39:47Z","closed_by":"akarnokd"},{"number":"1724","reopenOn":null,"comments":[{"date":"2014-10-09T17:51:22Z","author":"benjchristensen","text":"Interesting ... so yes, `merge` almost gets the behavior we want, but it then allows concurrent execution and that means we can get things out of order which we can't allow. \n\nFiguring out what needs to be done...\n"},{"date":"2014-10-09T18:53:31Z","author":"headinthebox","text":"Nice catch.\n"},{"date":"2014-10-10T03:19:59Z","author":"benjchristensen","text":"Just merged a fix that I believe resolves this while making it work with backpressure.\n"}],"opened_by":"dmgd","reopen":false,"closed_on":"2014-10-10T03:18:16Z","description":"e.g. \nrange(1, 10).delay(1, SECONDS).subscribe(System.out::println) will result in two numbers being output each second for five seconds, rather than all ten after one second\n\nsample unit test below. more tests and one way of fixing it (just using merge instead of concat) @ https:\/\/github.com\/dmgd\/RxJava\/commit\/29f0b80ef1f8ffdcddcf14c1a97d0e6d221fb7fd\n\n```\n@Test\npublic void testDelayEmitsEverything() {\n    Observable<Integer> source = Observable.range(1, 5);\n    Observable<Integer> delayed = source.delay(500L, TimeUnit.MILLISECONDS, scheduler);\n    TestObserver<Integer> observer = new TestObserver<Integer>();\n    delayed.subscribe(observer);\n    scheduler.advanceTimeBy(500L, TimeUnit.MILLISECONDS);\n    observer.assertReceivedOnNext(asList(1, 2, 3, 4, 5));\n}\n```\n","id":"44926761","title":"delay on a range emits two at a time rather than everything at once","opened_on":"2014-10-05T19:52:45Z","closed_by":"benjchristensen"},{"number":"1717","reopenOn":null,"comments":[{"date":"2014-10-03T15:40:23Z","author":"benjchristensen","text":"Thanks for the report. I'll take a look. It may actually be related to combineLatest. ObserveOn may just be the thing that exposes it.\n"},{"date":"2014-10-03T16:22:56Z","author":"headinthebox","text":"We ran into this in an Rx debugger demo where the UI suddenly froze, so I guess the Android folks may run into it as well at some point; the code above was the smallest retro we could find.\n"},{"date":"2014-10-06T02:20:51Z","author":"benjchristensen","text":"Replicated with this unit test:\n\n``` java\n    @Test\n    public void testWithCombineLatestIssue1717() {\n        Observable<Long> timer = Observable.timer(0, 1, TimeUnit.MILLISECONDS)\n                .observeOn(Schedulers.newThread())\n                .doOnEach(new Action1<Notification<? super Long>>() {\n\n                    @Override\n                    public void call(Notification<? super Long> n) {\n                        System.out.println(n);\n                    }\n\n                });\n\n        TestSubscriber<Long> ts = new TestSubscriber<Long>();\n\n        Observable.combineLatest(timer, Observable.<Void> never(), new Func2<Long, Void, Long>() {\n\n            @Override\n            public Long call(Long t1, Void t2) {\n                System.out.println(\"t1: \" + t1);\n                return t1;\n            }\n\n        }).take(RxRingBuffer.SIZE*2).subscribe(ts);\n\n        ts.awaitTerminalEvent();\n        ts.assertNoErrors();\n    }\n```\n\nIt looks like `combineLatest` is not requesting more upwards.\n"},{"date":"2014-10-06T06:08:27Z","author":"benjchristensen","text":"Actually ... this test should never pass. \n\nSince the test is combining with `never` that will never emit and thus `combineLatest` will never emit anything.\n\nIt queues up 512 items from the timer, and then correctly waits for `never` to emit something, but it never does.\n\nModifying the test so it emits at least one value before hanging then allows it to push data through:\n\n``` java\n    @Test\n    public void testWithCombineLatestIssue1717() {\n        Observable<Long> timer = Observable.timer(0, 1, TimeUnit.MILLISECONDS)\n                .observeOn(Schedulers.newThread())\n                .doOnEach(new Action1<Notification<? super Long>>() {\n\n                    @Override\n                    public void call(Notification<? super Long> n) {\n                        System.out.println(n);\n                    }\n\n                });\n\n        TestSubscriber<Long> ts = new TestSubscriber<Long>();\n\n        Observable.combineLatest(timer, Observable.just(1).concatWith(Observable.<Integer>never()), new Func2<Long, Integer, Long>() {\n\n            @Override\n            public Long call(Long t1, Integer t2) {\n                return t1;\n            }\n\n        }).take(RxRingBuffer.SIZE*2).subscribe(ts);\n\n        ts.awaitTerminalEvent();\n        ts.assertNoErrors();\n    }\n```\n\nNote the `Observable.just(1).concatWith(Observable.<Integer>never())` code which will emit `1` and then never `onComplete`.\n\n@GeorgiKhomeriki @headinthebox Do you expect `combineLatest` to emit even when one of the `Observable`s never emits anything as `never()` does?\n"},{"date":"2014-10-06T06:09:42Z","author":"benjchristensen","text":"If `combineLatest` is supposed to emit, even when a value is not yet emitted, is it supposed to be `null`?\n"},{"date":"2014-10-06T06:16:40Z","author":"benjchristensen","text":"In 0.19.x before backpressure, this code just runs forever emitting values:\n\n``` java\n    @Test\n    public void testWithCombineLatestIssue1717() {\n        Observable<Long> timer = Observable.timer(0, 1, TimeUnit.MILLISECONDS)\n                .observeOn(Schedulers.newThread())\n                .doOnEach(new Action1<Notification<? super Long>>() {\n\n                    @Override\n                    public void call(Notification<? super Long> n) {\n                        System.out.println(n);\n                    }\n\n                });\n\n        TestSubscriber<Long> ts = new TestSubscriber<Long>();\n\n        Observable.combineLatest(timer, Observable.<Void> never(), new Func2<Long, Void, Long>() {\n\n            @Override\n            public Long call(Long t1, Void t2) {\n                System.out.println(\"t1: \" + t1);\n                return t1;\n            }\n\n        }).take(2000).subscribe(ts);\n\n        ts.awaitTerminalEvent();\n        ts.assertNoErrors();\n    }\n```\n\nThis code never prints anything in 0.19 as well (before backpressure):\n\n``` java\n    @Test\n    public void testWithCombineLatestIssue1717() {\n        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n        Observable.combineLatest(Observable.just(1), Observable.<Void> never(), new Func2<Integer, Void, Integer>() {\n\n            @Override\n            public Integer call(Integer t1, Void t2) {\n                System.out.println(\"t1: \" + t1 + \" t2: \" + t2);\n                return t1;\n            }\n\n        }).subscribe(ts);\n        ts.awaitTerminalEvent();\n    }\n```\n\nShould it emit anything when `Observable.never()` won't emit?\n"},{"date":"2014-10-06T06:18:29Z","author":"benjchristensen","text":"The introtorx.com site states:\n\n> Once both sequences have produced at least one value, the latest output from each sequence is passed to the resultSelector function every time either sequence produces a value.\n\nhttp:\/\/www.introtorx.com\/Content\/v1.0.10621.0\/12_CombiningSequences.html#CombiningMultipleSequences\n"},{"date":"2014-10-06T06:46:12Z","author":"GeorgiKhomeriki","text":"@benjchristensen There is a subtle difference here, because we have a side-effect in the `doOnEach` operator, before the `combineLatest`. I think this side-effect should execute every time the left observable (timer) emits a value. After that, the `combineLatest` can block the event from propagating further down the line since it never receives a value from the other Observable. So to answer your question, `combineLatest` should indeed not emit any values in this case, but the doOnEach should keep on printing forever.\n"},{"date":"2014-10-06T06:56:42Z","author":"headinthebox","text":"The example code is pretty nasty.\n\nI am still puzzled what is exactly going on but as @GeorgiKhomeriki  says, the trick is that there is a side-effect in the first input to a `combineLatest` that itself never produces a value (in the real use case, the other input is a stream that only receives very few values, and in our case few enough that the whole program froze). \n\nBefore back pressure, and without any `observeOn`, feeding stream `xs` into an `combineLatest` where the other input never produces was not an issue, `combineLatest` keeps the last value of `xs` and the side effects are happily executing as new values arrive.\n"},{"date":"2014-10-06T13:53:41Z","author":"benjchristensen","text":"I found what's happening, it's odd. `combineLatest` behaves differently before it gets values from all `Observable`s than it does after.\n\nBefore a value has been received from each `Observable` it does NOT obey backpressure and just acts like a `BehaviorSubject` dropping data and retaining only the last. \n\nAfter a value has been received from each `Observable` however it then expects to never drop data and emit all combinations. This means backpressure is needed to achieve this otherwise unbounded buffers are needed, as in 0.19 and earlier (https:\/\/github.com\/ReactiveX\/RxJava\/blob\/0.19.x\/rxjava-core\/src\/main\/java\/rx\/internal\/operators\/OnSubscribeCombineLatest.java#L131).\n\nThe reason why `observeOn` affects it the way it does is that `observeOn` expects to receive a request for more data and `combineLatest` never does that. It is a bug in `combineLatest` that it doesn't request more after dropping data. That's bug 1.\n\nBug 2 is that the `timer`\/`observeOn` relationship should result in a `MissingBackpressureException` being thrown because `timer` doesn't obey backpressure (by design). If `observeOn` exerts backpressure (as it does) and `timer` doesn't obey (as it won't) then an exception should be thrown. \n"},{"date":"2014-10-06T13:55:19Z","author":"headinthebox","text":"Juicy!\n"},{"date":"2014-10-06T13:56:21Z","author":"benjchristensen","text":"@headinthebox You said this:\n\n> since it only \"remembers\" the latest values in both input streams that is much too conservative\n\nThis is understood to only happen before it starts emitting. \n\nhttp:\/\/www.introtorx.com\/Content\/v1.0.10621.0\/12_CombiningSequences.html#CombineLatest\n\n> Once both sequences have produced at least one value, the latest output from each sequence is passed to the resultSelector function every time either sequence produces a value.\n\nIs the behavior I described above in my previous comment correct? In other words that it drops data while waiting for all to have a \"latest\" but once all have a \"latest\" that it will no longer drop?\n"},{"date":"2014-10-06T14:21:16Z","author":"headinthebox","text":"Yup, that's absolutely correct; there is a distinct phase change.\n\nI was confusingly describing the test case where one of the sides did not receive a value, I edited the comment to reflect that.\n"},{"date":"2014-10-06T15:10:29Z","author":"benjchristensen","text":"Thanks for the confirmation. I'll work on fixing the 2 items I identified.\n"},{"date":"2014-10-06T15:17:42Z","author":"headinthebox","text":"Like!\n"},{"date":"2014-10-06T20:34:05Z","author":"benjchristensen","text":"I have merged the fixes. \n"},{"date":"2014-10-06T21:15:31Z","author":"GeorgiKhomeriki","text":"I tried to build the latest `1.x` branch but the build failed on  `rx.internal.operators.OnSubscribeCombineLatestTest`. \n\n```\norg.mockito.exceptions.verification.NeverWantedButInvoked: \nobserver.onNext(<any>);\nNever wanted here:\n-> at rx.internal.operators.OnSubscribeCombineLatestTest.testSecondNeverProduces(OnSubscribeCombineLatestTest.java:463)\nBut invoked here:\n-> at rx.Observable$40.onNext(Observable.java:7542)\n\n    at rx.internal.operators.OnSubscribeCombineLatestTest.testSecondNeverProduces(OnSubscribeCombineLatestTest.java:463)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:86)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:49)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)\n    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:48)\n    at sun.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n    at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\n    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:105)\n    at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)\n    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:64)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:744)\n```\n"},{"date":"2014-10-06T21:34:58Z","author":"GeorgiKhomeriki","text":"Running the build a second time (with the --debug flag) failed on the following two tests:\n\n`rx.BackpressureTests (testSubscribeOnScheduling)`:\n\n```\njava.lang.RuntimeException: Unexpected onError events: 1\n    at rx.observers.TestSubscriber.assertNoErrors(TestSubscriber.java:170)\n    at rx.BackpressureTests.testSubscribeOnScheduling(BackpressureTests.java:251)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:86)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:49)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)\n    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:48)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n    at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\n    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:105)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)\n    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:64)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:744)\nCaused by: rx.exceptions.MissingBackpressureException\n    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:223)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(OperatorObserveOn.java:115)\n    at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)\n    at rx.BackpressureTests$10$1.request(BackpressureTests.java:480)\n    at rx.internal.operators.OperatorSubscribeOn$1$1$1$1$1.call(OperatorSubscribeOn.java:94)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:262)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\n    ... 3 more\n```\n\n`rx.CombineLatestTests(testCovarianceOfCombineLatest)`\n\n```\njava.lang.ClassCastException: java.lang.Integer cannot be cast to rx.CovarianceTest$Result\n    at rx.CombineLatestTests$2.call(CombineLatestTests.java:59)\n    at rx.observables.BlockingObservable$1.onNext(BlockingObservable.java:119)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:105)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:147)\n    at rx.internal.util.RxRingBuffer.accept(RxRingBuffer.java:316)\n    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.tick(OnSubscribeCombineLatest.java:152)\n    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.onNext(OnSubscribeCombineLatest.java:209)\n    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceRequestableSubscriber.onNext(OnSubscribeCombineLatest.java:252)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:41)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:30)\n    at rx.Observable.unsafeSubscribe(Observable.java:7569)\n    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.request(OnSubscribeCombineLatest.java:131)\n    at rx.Subscriber.setProducer(Subscriber.java:141)\n    at rx.Subscriber.setProducer(Subscriber.java:137)\n    at rx.internal.operators.OnSubscribeCombineLatest.call(OnSubscribeCombineLatest.java:68)\n    at rx.internal.operators.OnSubscribeCombineLatest.call(OnSubscribeCombineLatest.java:45)\n    at rx.Observable.subscribe(Observable.java:7658)\n    at rx.observables.BlockingObservable.forEach(BlockingObservable.java:97)\n    at rx.CombineLatestTests.testCovarianceOfCombineLatest(CombineLatestTests.java:43)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:86)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:49)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)\n    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:48)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n    at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\n    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:105)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)\n    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:64)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:744)\n```\n"},{"date":"2014-10-06T21:49:20Z","author":"benjchristensen","text":"> java.lang.ClassCastException: java.lang.Integer cannot be cast to rx.CovarianceTest$Result\n\nI have no idea what that's about. Never seen it. \n\n> java.lang.RuntimeException: Unexpected onError events: 1\n\nLooks like a non-deterministic test of some kind. It passes on my machine and Travis which means we're just getting lucky on scheduling.\n"},{"date":"2014-10-06T21:58:07Z","author":"GeorgiKhomeriki","text":"Not sure if this helps but I'm running the build on a MacBook Air (Mid 2013) with OS X 10.8.5.\n"},{"date":"2014-10-06T22:15:34Z","author":"benjchristensen","text":"I have run `testSubscribeOnScheduling` several hundred thousand times in loops and can't replicate it. Can you see anything that would cause the failure?\n"},{"date":"2014-10-06T22:29:02Z","author":"GeorgiKhomeriki","text":"Something really strange is happening. When I ran the build a third time, it succeeded. Then after running `.\/gradlew clean` and rebuilding, it failed on 6 tests:\n\n```\nRefCountTests. testConnectDisconnectConnectAndSubjectState\nZipTests. testCovarianceOfZip\nZipTests. testZipObservableOfObservables\nOnSubscribeCacheTest. testWithAsyncSubjectAndRepeat\nOnSubscribeCacheTest. testWithReplaySubjectAndRepeat\nOnSubscribeCombineLatestTest. combineSimple\n```\n\nIs there some relation between these tests and the latest changes? Would you like me to send you the test reports?\n"},{"date":"2014-10-06T22:36:29Z","author":"benjchristensen","text":"Those tests are not related.\n"},{"date":"2014-10-07T14:44:45Z","author":"GeorgiKhomeriki","text":"Today neither me nor @headinthebox were able to reproduce this failing build. I'm sure I wasn't hallucinating yesterday, and I still have the test reports saved if you're interested :-)\n"},{"date":"2014-10-07T16:20:24Z","author":"benjchristensen","text":"I have no idea what was going on for you, but I'm not going to spend time chasing after them.\n\nPlease re-open this issue if the 1.0.0-rc.5 release does not fix the combineLatest issues for you.\n"}],"opened_by":"GeorgiKhomeriki","reopen":false,"closed_on":"2014-10-07T16:20:24Z","description":"The following program stops printing numbers around 511 where the expected behaviour is that it runs forever.\n\n``` scala\n\nimport java.util.concurrent.TimeUnit\n\nimport rx.lang.scala.Observable\nimport rx.lang.scala.schedulers.NewThreadScheduler\n\nimport scala.concurrent.duration.Duration\n\nobject CombineLatestTest {\n  def main(args: Array[String]) {\n\n    var left = Observable.timer(Duration(0, TimeUnit.MILLISECONDS), Duration(1, TimeUnit.MILLISECONDS))\n\n    left.observeOn(NewThreadScheduler()).doOnEach(println(_)).combineLatest(Observable.never).subscribe()\n\n    readLine()\n  }\n}\n\n```\n\nWithout the `observeOn` it works as expected.\n","id":"44800194","title":"combineLatest back-pressure bug","opened_on":"2014-10-03T12:56:23Z","closed_by":"benjchristensen"},{"number":"1702","reopenOn":null,"comments":[{"date":"2014-10-01T01:09:01Z","author":"benjchristensen","text":"Thanks for the report. I'll take a look.\n"},{"date":"2014-10-10T03:20:58Z","author":"benjchristensen","text":"Fixed (I hope) in #1736 \n"},{"date":"2015-01-23T17:46:04Z","author":"akarnokd","text":"Hi. Fixed in 1.x branch via #2471. Can you verify the fix works for your case?\n"}],"opened_by":"DylanSale","reopen":false,"closed_on":"2014-10-10T03:20:58Z","description":"There is an issue in TrampolineScheduler on 0.20.4 where it can  throw a NullPointerException in InnerCurrentThreadScheduler `enqueue(Action0 action, long execTime)`\n\n``` java\n        private Subscription enqueue(Action0 action, long execTime) {\n            if (innerSubscription.isUnsubscribed()) {\n                return Subscriptions.empty();\n            }\n            PriorityQueue<TimedAction> queue = QUEUE.get();\n            final TimedAction timedAction = new TimedAction(action, execTime, COUNTER_UPDATER.incrementAndGet(TrampolineScheduler.this));\n            queue.add(timedAction);\n\n            if (wip.getAndIncrement() == 0) {\n                do {\n                    queue.poll().action.call();\n                } while (wip.decrementAndGet() > 0);\n                return Subscriptions.empty();\n            } else {\n                \/\/ queue wasn't empty, a parent is already processing so we just add to the end of the queue\n                return Subscriptions.create(new Action0() {\n\n                    @Override\n                    public void call() {\n                        PriorityQueue<TimedAction> _q = QUEUE.get();\n                        if (_q != null) {\n                            _q.remove(timedAction);\n                        }\n                    }\n\n                });\n            }\n        }\n```\n\nThe Exception happens on `queue.poll().action.call();`.\nFrom what I can tell, the queue is empty, and poll is returning null.\n\nThis is happening inside a nested `observable.redo().timeout().redo()` chain (the `redo().timeout()` happens earlier in the application, it isn't just one after the other like that), if that helps. I'm not in a position to create a simple replication example however.\n\nMy current theory is: One of the redos could be unsubscribing, calling `_q.remove`, while the `wip` loop is running (perhaps unsubscribe is happening on another thread?), causing the queue to become empty, and the next loop of the `wip` loop returns `null`. I think the `queue.poll()` call should check for null. \n","id":"43998067","title":"TrampolineScheduler NullPointerException","opened_on":"2014-09-26T03:58:31Z","closed_by":"benjchristensen"},{"number":"1699","reopenOn":null,"comments":[{"date":"2014-10-02T23:55:52Z","author":"benjchristensen","text":"This may be fixed in #1712 \n\nKeeping this open until confirmed with 1.0.0-rc.4\n"},{"date":"2014-10-07T18:33:59Z","author":"benjchristensen","text":"This appears to be fixed after passing our production canary tests.\n\nThanks @mattrjacobs \n"},{"date":"2014-10-07T18:35:51Z","author":"headinthebox","text":"Phew.\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2014-10-07T18:33:59Z","description":"There is a hang we found when upgrading from 0.19 to 0.20. It is very non-obvious as we passed all our normal production tests for 24+ hours but found this in the TEST environment with a certain use case.\n\nWe have not yet identified the cause but this has held up adoption of 0.20 in the Netflix API. This in turn holds up 1.0 from being considered production worthy.\n\n\/cc @mattrjacobs and @abersnaze \n","id":"43657271","title":"Unknown Hang in Netflix API with 0.20.x","opened_on":"2014-09-23T17:16:21Z","closed_by":"benjchristensen"},{"number":"1689","reopenOn":null,"comments":[{"date":"2014-09-18T09:45:14Z","author":"novemberox","text":"The same issue occurs if we replace `doOnEach(System.out::println)` with `startWith(Observable.empty())`.\n"},{"date":"2014-09-19T15:44:37Z","author":"zsxwing","text":"Since THROW_ON_ODD will throw IllegalArgumentException when `i` is 1, onNext should be called only twice: Option(1) and Option(IllegalArgumentException). So `assertEquals(0, count.get())` will fail.\n\nActually you don't need to implement a new operator. You can use `onErrorReturn`, like:\n\n``` groovy\no.map(i -> new Option<Integer>(i)).onErrorReturn(e -> new Option<Integer>(e))\n```\n"},{"date":"2014-09-19T17:38:32Z","author":"novemberox","text":"I wouldn't use custom operator if `.map(i -> new Option<Integer>(i)).onErrorReturn(e -> new Option<Integer>(e))` work.\n\nI redesigned my application architecture so now I don't have this issue. However I don't know if this situation is or is not bug.\n"},{"date":"2014-09-19T20:07:46Z","author":"benjchristensen","text":"There is no guarantee how this will behave as you are attempting something which breaks the Rx contract by trying to send `onNext` after a terminal event `onError`. Any operator along the way has the right to unsubscribe up and filter out further elements once a terminal event is received. See here: https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/operators\/OperatorDoOnEach.java#L76 \n\nIn other words, `onNext -> onError -> onNext` is invalid, so there is no guarantee you'll ever see the `onNext` after an `onError`. Even `materialize()` which makes the `onError` into a `Notification` will terminate once it receives the `onError` since that is a terminal event: https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/operators\/OperatorMaterialize.java#L47\n"},{"date":"2014-09-20T17:25:04Z","author":"novemberox","text":"Thanks for clarification. As I wrote before I found other design solution for building UI with Rx, I should share it. Our community lacks few chapters of best practices IRL development.\n\nCorrect me if I'm wrong, but Rx contract doesn't say anything about signal propagation if subscriber has unsubscribe. Will all the `flatMaps`\/`maps`\/``youNameIt` will be executed until subscriber? Currently `OperatorMap` on each `onNext` call doesn't check `Subscriber.isUnsubscribed()`, can it change or should I assume that it might change?\n"},{"date":"2014-10-01T00:52:10Z","author":"benjchristensen","text":"`OperatorMap` is synchronous and just passes the subscription through, so it is not involved in producing new values, it's just part of the chain. This is why it doesn't need to check `isUnsubscribed`. The only places where that is needed are the places where values are produced. This is either the original source from `Observable.OnSubscribe` or inside an operator that acts asynchronously such as `observeOn`.\n\nNote here how the child `o` is passed through to the parent via the constructor: https:\/\/github.com\/ReactiveX\/RxJava\/blob\/1.x\/src\/main\/java\/rx\/internal\/operators\/OperatorMap.java#L39\n\nThis means when the child unsubscribes it is affecting the parent directly, there is no decoupling. \n\nAny operator can check `isUnsubscribed` if it wants, but it is not necessary on most because of how the `Subscriber` IS the `Subscription` and is chained through. \n\nThe Rx contract for `unsubscribe` states the following:\n\n> 4.4. Assume a best effort to stop all outstanding work on Unsubscribe\n> \n> When unsubscribe is called on an observable subscription, the observable sequence will make a best effort attempt to stop all outstanding work. This means that any queued work that has not been started will not start.\n> \n> Any work that is already in progress might still complete as it is not always safe to abort work that is in progress. Results from this work will not be signaled to any previously subscribed observer instances.\n\nThere are some operators however that do make guarantees. For example `take` guarantees to not deliver any further values after `n` are taken. This means after it unsubscribes, even if it receives more events it will discard them. That is the contract of the `take` operator, NOT of `unsubscribe`.\n"},{"date":"2014-10-07T23:46:20Z","author":"benjchristensen","text":"Anything further on this?\n"},{"date":"2014-10-08T13:11:25Z","author":"novemberox","text":"Thanks for that great explanation. I think we're done with it.\n"}],"opened_by":"novemberox","reopen":false,"closed_on":"2014-10-08T13:20:50Z","description":"I have failing test:\nfinal AtomicInteger count = new AtomicInteger(3);\n\n```\n    Observable.range(0, count.get())\n            .map(THROW_ON_ODD)\n            .map(i -> i) \/\/ #1\n            .flatMap(Observable::just) \/\/ #2\n            \/\/.doOnNext(System.out::println) \/\/ #3\n            .doOnEach(System.out::println) \/\/ #4\n            .lift(OPTION_WRAP())\n            .subscribe(\n                    op -> {\n                        System.out.println(op.toString());\n                        count.decrementAndGet();\n                    },\n                    e -> System.out.println(\"It never will be printed\" + e.getClass().getSimpleName()),\n                    () -> System.out.println(\"end\")\n            );\n\n    assertEquals(0, count.get());\n```\n\nAll the magic is in `lift` in which I wanted to have error wrapping using something similar to com.google.common.base.Optional<T>. So when `onError` is emitted I wrap it to `error result` and when `onNext` is emmited I wrap it `valid result`. Whole test source is here: https:\/\/gist.github.com\/novemberox\/e2b1b4e289ac45162847\n\nProblem is with line marked as #3 and #4, if any of those is not commented test fails. Order of lines #1-4 doesn't matter, result is always the same. Since `doOnXXX` is side effect that shouldn't affect core observable I think is a bug.\n\n---\n\nYou might ask me while I'm trying to treat error as valid data. Common thing is to have some action triggered from UI that would trigger some IO action and display result back to the UI. \n\nI wanted have my UI to be expresed more as FRP so when UI is created I want to have few Subjects that would emit data events like text change or button clicked this way I can do all my business logic it that very moment. \n\nHowever that is not working at all with Rx paradigm that after `onError` nothing should be emitted. This paradigm doesn't work well with UI, because I want to be able do IO at every button click event if it fails, my UI can handle both error and result nicely.\n","id":"42915032","title":"OperatorDoOnEach breakes latter subscribtions after error wrapping lift","opened_on":"2014-09-16T18:21:04Z","closed_by":"benjchristensen"},{"number":"1688","reopenOn":null,"comments":[{"date":"2014-09-16T09:12:03Z","author":"davidmoten","text":"I think I see what to do to fix. I'll make a PR. If someone is already working on it let me know and I'll stop.\n"},{"date":"2014-10-14T16:56:00Z","author":"benjchristensen","text":"Pull request is merged.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2014-10-14T16:56:00Z","description":"Given `o.publish().refCount()` on an infinite synchronous source `o`, [line 93](https:\/\/github.com\/ReactiveX\/RxJava\/blob\/0.20.x\/rxjava-core\/src\/main\/java\/rx\/internal\/operators\/OnSubscribeRefCount.java#L93) in `OnSubscribeRefCount` never completes thus `emitting` is never false and disconnect cannot happen.\n\nHere's a unit test failing on 0.20.4:\n\n``` java\npackage au.gov.amsa.ais.rx;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\nimport org.junit.Test;\n\nimport rx.Observable;\nimport rx.Observable.OnSubscribe;\nimport rx.Observable.Operator;\nimport rx.Subscriber;\nimport rx.observers.Subscribers;\nimport rx.schedulers.Schedulers;\n\npublic class RefCountTest {\n\n    @Test(timeout=3000)\n    public void testRefCountUnsubscribeForSynchronousSource() throws InterruptedException {\n        final CountDownLatch latch = new CountDownLatch(1);\n        Observable<Long> o = synchronousInterval().lift(detectUnsubscription(latch));\n        Subscriber<Long> sub = Subscribers.empty();\n        o.publish().refCount().subscribeOn(Schedulers.computation()).subscribe(sub);\n        sub.unsubscribe();\n        assertTrue(latch.await(3, TimeUnit.SECONDS));\n    }\n\n    private Operator<Long, Long> detectUnsubscription(final CountDownLatch latch) {\n        return new Operator<Long,Long>(){\n            @Override\n            public Subscriber<? super Long> call(Subscriber<? super Long> subscriber) {\n                latch.countDown();\n                return Subscribers.from(subscriber);\n            }};\n    }\n\n    private Observable<Long> synchronousInterval() {\n        return Observable.create(new OnSubscribe<Long>() {\n\n            @Override\n            public void call(Subscriber<? super Long> subscriber) {\n                while (!subscriber.isUnsubscribed()) {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                    }\n                    subscriber.onNext(1L);\n                }\n            }});\n    }\n}\n\n```\n","id":"42841454","title":"RefCount unsubscribe never happens for infinite synchronous source","opened_on":"2014-09-16T03:34:32Z","closed_by":"benjchristensen"},{"number":"1685","reopenOn":null,"comments":[{"date":"2014-09-12T23:28:48Z","author":"vadims","text":"The following example hangs\n\n``` java\n    ReplaySubject<Object> subject = ReplaySubject.create();\n\n    Observable.error(new RuntimeException(\"oops\"))\n        .materialize()\n        .delay(1, TimeUnit.SECONDS)\n        .dematerialize()\n        .subscribe(subject);\n\n    subject.subscribe();\n    subject.materialize().toBlocking().first();\n\n    System.out.println(\"Done\");\n```\n\nwhere as \n\n``` java\n    ReplaySubject<Object> subject = ReplaySubject.create();\n\n    Observable.error(new RuntimeException(\"oops\"))\n        .materialize()\n        .delay(1, TimeUnit.SECONDS)\n        .dematerialize()\n        .subscribe(subject);\n\n    subject.subscribe(n -> {}, e -> {});\n    subject.materialize().toBlocking().first();\n\n    System.out.println(\"Done\");\n```\n\ndoes not. \n"},{"date":"2014-09-26T08:28:04Z","author":"akarnokd","text":"The plain `subscribe()` has an onError handler which throws an `OnErrorNotImplementedException` and disrupts the event delivery inside the `PublishSubject`.\n"},{"date":"2014-09-26T13:50:08Z","author":"vadims","text":"Is that by design?\n"},{"date":"2014-10-02T23:54:18Z","author":"vadims","text":"@benjchristensen? \n\nWe're trying to see if we need to stop using subscribe() without an onError handler due to this behavior even when we don't need to handle the error notification.\n"},{"date":"2014-10-03T15:44:45Z","author":"benjchristensen","text":"Yes, it is by design that if an error handler is not provided, but an error occurs it will throw `OnErrorNotImplementedException`. We never swallow errors automatically.\n\nIf you want to swallow an error prior to the subscribe you can do something like this:\n\n``` java\nstream.onErrorResumeNext(t -> Observable.empty()).subscribe();\n```\n\nThe `subscribe` overloads that don't take an error handler assume you are handling the error cases in the stream, or that errors \"won't happen\". \n"},{"date":"2014-10-03T15:46:26Z","author":"benjchristensen","text":"The hang may be that you're not seeing the `OnErrorNotImplementedException` be thrown due to the scheduling happening on delay: https:\/\/github.com\/ReactiveX\/RxJava\/issues\/1682\n\nI haven't confirmed, but you should definitely see an exception be thrown somewhere.\n"},{"date":"2014-10-10T04:27:04Z","author":"benjchristensen","text":"This one was kind of tricky ... I have to catch the error and wait until all subscribers receive the `onError` and then allow it to be thrown so that all subscribers are released.\n\nGreat bug. Thanks for reporting this.\n"}],"opened_by":"vadims","reopen":false,"closed_on":"2014-10-10T04:29:43Z","description":"","id":"42593975","title":"OnErrorNotImplementedException disrupts Subject event delivery ","opened_on":"2014-09-12T03:46:40Z","closed_by":"benjchristensen"},{"number":"1682","reopenOn":"2014-10-15T18:34:12Z","comments":[{"date":"2014-10-10T05:32:12Z","author":"benjchristensen","text":"I've been researching this and there isn't a whole lot of choice in what to do when an Exception is thrown on a random `Scheduler.Worker` thread beyond catching and printing the error using `System.err`.\n\nI can't throw the exception anywhere else as the whole issue here is an unhandled exception being thrown.\n\nThus, I'm going to catch the exceptions in `ScheduledAction` and `e.printStackTrace()` them with a warning about exceptions being thrown.\n\nThis is an edge case that an app should not allow ... and the reason why Observables propagate errors as events ... to avoid this very case, so seeing these types of messages in log output signals a \"bad thing\" that should be resolved. \n\nThis would NOT be good for system performance to allow these types of errors to be logged, but I feel this is far better to yell and scream about bad code rather than silently swallowing errors as it does now.\n"},{"date":"2014-10-10T05:37:00Z","author":"benjchristensen","text":"An error such as this will be printed:\n\n```\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:46)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: rx.exceptions.OnErrorNotImplementedException\n    at rx.Observable$36.onError(Observable.java:7387)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:128)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:144)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:177)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$0(OperatorObserveOn.java:161)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:153)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)\n    ... 7 more\nCaused by: java.lang.RuntimeException\n    at rx.exceptions.ErrorsOverAsyncBoundaries.testSubscriberOnErrorFails(ErrorsOverAsyncBoundaries.java:43)\n```\n"},{"date":"2014-10-10T05:43:15Z","author":"benjchristensen","text":"I have merged the change. If anyone can suggest a better approach that would be great, please let me know here.\n"},{"date":"2014-10-10T05:46:17Z","author":"headinthebox","text":"Best of the worst.\n"},{"date":"2014-10-14T11:57:15Z","author":"dlew","text":"The added logging is nice, but why not continue throwing the error if it's fatal (like `OnErrorNotImplemented`)? Minus `observeOn` your program would crash because you aren't handling the exception - it wouldn't just log the exception.\n"},{"date":"2014-10-14T16:33:26Z","author":"benjchristensen","text":"@dlew how would you solve this differently? The error is occurring on a separate thread, so the most violent death that can occur is killing that thread inside the ThreadPoolExecutor. The error can not propagate to the `main` thread and thus does not kill the JVM.\n\nThe `Throwable` gets caught inside `java.util.concurrent.FutureTask`:\n\n``` java\n    public void run() {\n        if (state != NEW ||\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                         null, Thread.currentThread()))\n            return;\n        try {\n            Callable<V> c = callable;\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    setException(ex); \/\/  <------------- THIS IS WHERE THE EXCEPTION GOES\n                }\n                if (ran)\n                    set(result);\n            }\n        } finally {\n            \/\/ runner must be non-null until state is settled to\n            \/\/ prevent concurrent calls to run()\n            runner = null;\n            \/\/ state must be re-read after nulling runner to prevent\n            \/\/ leaked interrupts\n            int s = state;\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n```\n\nOne can use `ThreadPoolExecutor.afterExecute` to extract the caught error, but rethrowing only causes the `ThreadPoolExecutor` to kill the thread, not the JVM since it can't propagate to the `main` thread (the nature of async): http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/concurrent\/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable,%20java.lang.Throwable)\n\nThe only alternative I can think of is to reverse schedule events up the Observable chain, like having an `onError` on the `Observable.OnSubscribe` and having a `Scheduler` on the producing side, not just the consuming side. That however is a crazy amount of overhead and infrastructure for a degenerate case. \n\nIf you can submit a pull request that offers a better solution I'd appreciate that.\n"},{"date":"2014-10-14T16:56:42Z","author":"dlew","text":"Thanks, I understand the problem a lot better now. I'll have to think on it; not sure there is a good solution.\n"},{"date":"2014-10-14T18:10:31Z","author":"abersnaze","text":"I know this isn't possible for even 1.0 but could `Subscription schedule(Action0 action)` be changed to\n`Observable<Void> schedule(Action0 action)`. That way the caller can get both the ability to subscribe to get the subscription and notification of completion or failure.\n"},{"date":"2014-10-14T20:37:29Z","author":"benjchristensen","text":"A calling thread could not get a reference, as `void onNext` is the signature the caller invokes. It is on the wrong side of the thread where the exception is caught, scheduled from inside the `onNext`. The calling (parent) thread has already left by the time the child thread throws the exception. \n\nThere is no issue catching the exception on the child thread, it's what to do with it that is the question. \n"},{"date":"2014-10-15T07:42:04Z","author":"mttkay","text":"There is a related discussion here: https:\/\/github.com\/ReactiveX\/RxJava\/issues\/969\n\nI haven't checked in a while, but IIRC part of the issue was that some operators like ObserveOn weren't forwarding errors?\n"},{"date":"2014-10-15T07:53:27Z","author":"benjchristensen","text":"ObserveOn propagates errors downstream. We just can't send them upstream across thread boundaries. \n"},{"date":"2014-10-15T17:06:27Z","author":"loganj","text":"It would be great if we could add another plugin that gets called in place of the `printStackTrace`.  Similar to `RxJavaErrorHandler`, but only for otherwise unhandled errors.\n"},{"date":"2014-10-15T17:10:20Z","author":"benjchristensen","text":"Would you prefer that over this:\n\n> Thread.getDefaultUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n\nI've never that so have no idea how it behaves especially with thread pools. \n"},{"date":"2014-10-15T18:03:02Z","author":"loganj","text":"No, you're right, we can just use the built-in handler mechanism directly.\n\nWe go directly `Thread.getDefaultUncaughtExceptionHandler()` today, but that's probably wrong.  That handler is the global last-resort handler for all threads.  It looks like what we really want is `Thread.currentThread().getUncaughtExceptionHandler()`.\n\nI'll get a PR together.\n"},{"date":"2014-10-15T18:35:58Z","author":"benjchristensen","text":"That sounds good, since then we are free to add listeners at any of the 3 levels, but just registering the default global listener (most likely) will still work and it will propagate to it.\n\nhttp:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Thread.UncaughtExceptionHandler.html\n\n> When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler's uncaughtException method, passing the thread and the exception as arguments. If a thread has not had its UncaughtExceptionHandler explicitly set, then its ThreadGroup object acts as its UncaughtExceptionHandler. If the ThreadGroup object has no special requirements for dealing with the exception, it can forward the invocation to the default uncaught exception handler.\n\nThanks for bringing this to my attention @loganj I honestly wasn't even aware of this capability in the JVM and my use cases don't generally result in uncaught exceptions so I hadn't ever gone looking for it.\n"},{"date":"2014-10-16T03:10:30Z","author":"loganj","text":"No problem, we're really good at making exceptions happen.\n\nI'm basically done, but not sure if I should I apply the same handling to Schedulers that don't use ScheduledAction.  ExecutorScheduler _seems_ to need it.  What about ImmediateScheduler and TrampolineScheduler?  Do people rely on their current throwing behavior?  Is that behavior contractual?\n"},{"date":"2014-10-16T03:13:10Z","author":"benjchristensen","text":"I have not tried this issue on TrampolineScheduler but that may be okay as it's all on the same thread. ExecutorScheduler probably does need this, but let's get it solved for `ScheduledAction` first and then we can go fix that one in a separate PR.\n"},{"date":"2014-10-16T16:20:34Z","author":"benjchristensen","text":"I have confirmed this fix is working nicely after the changes by @loganj in #1766 \n"}],"opened_by":"benjchristensen","reopen":true,"closed_on":"2014-10-16T16:20:34Z","description":"ScheduledAction (used by `observeOn` and other things doing scheduling) swallows errors because `FutureTask.run()` swallows errors inside a `Future`.\n\nThis means something like `OnErrorNotImplemented` on the `Subscriber` side of an `observeOn` will throw and be swallowed and everything will fail silently.\n\nThe following code fails silently:\n\n``` java\nObservable.error(new RuntimeException()).observeOn(Schedulers.computation()).subscribe();\n```\n","id":"42488537","title":"ScheduledAction Swallows Errors","opened_on":"2014-09-11T04:48:09Z","closed_by":"benjchristensen"},{"number":"1677","reopenOn":null,"comments":[{"date":"2014-09-09T14:22:59Z","author":"spodila","text":"Replacing subscrinbeOn() with observeOn() shows the same hang.\n"},{"date":"2014-09-11T11:53:51Z","author":"zsxwing","text":"Which version you are using? Is it because #1656?\n"},{"date":"2014-09-11T16:27:42Z","author":"spodila","text":"On rxjava-0.20.4\n\nWhich release is #1656 in?\n"},{"date":"2014-09-12T10:49:49Z","author":"zsxwing","text":"Found a concurrent issue in `ReplaySubject.BufferUntilSubscriber`. `buffered.buffer` may receive some messge between `buffered.buffer` is drained and `state.setObserverRef`. If no further messages after `state.setObserverRef`, the messages in `buffered.buffer` will be swallowed. Here is a commit to fix it using lock: https:\/\/github.com\/zsxwing\/RxJava\/commit\/158f53131d341d0c9d6f990b451a6c1d0893c017\n\nStill investigating a lockless fix.\n\nAlso found takeUntil is still not fixed. Done it in #1686.\n"},{"date":"2014-09-13T09:20:28Z","author":"zsxwing","text":"Fixed in #1686\n"},{"date":"2014-09-14T13:52:25Z","author":"zsxwing","text":"BTW, you should not call `PublishSubject.onCompleted` in different threads.\n"},{"date":"2014-09-15T05:06:37Z","author":"spodila","text":"Is that an RxJava requirement? I do not see any such constraints mentioned in the JavaDocs for the method.\n"},{"date":"2014-09-15T05:26:55Z","author":"zsxwing","text":"> Is that an RxJava requirement? I do not see any such constraints mentioned in the JavaDocs for the method.\n\nRight. When you call `PublishSubject.onCompleted`, `PublishSubject` is regarded as an `Observer`. As per Rx Design Guild (http:\/\/go.microsoft.com\/fwlink\/?LinkID=205219), \n\n> 4.2. Assume observer instances are called in a serialized fashion\n\nPublishSubject will expect that the events should be serialized.\n"},{"date":"2014-09-15T19:09:35Z","author":"spodila","text":"Based on this, for correctness, I changed the test case to synchronize on 's' around \"s.onCompleted()\". I can confirm that problem 2 persists after that as well. However, I can't be totally sure if this is a valid test case. I feel that the counter should give the same number as NITERS in the code. Maybe less, but never greater. When it fails, it shows counter to be 1 greater than the expected, NITERS. If you have an insight into this part of the test case, let me know.\n\nHowever, I am not able to reproduce problem 1 (hang), with or without the synchronized block. I can't tell why it is not reproducible anymore. So, effectively this test case doesn't seem to reproduce anymore the original intention of this issue.\n"},{"date":"2014-09-16T01:49:12Z","author":"zsxwing","text":"> When it fails, it shows counter to be 1 greater than the expected, NITERS.\n\nThe bug in `takeUntil` I fixed in #1686 may emit more `onCompleted` events and make `toList` emit more `onNext` events. Sorry that I cannot confirm it because I cannot reproduce it in my machine.\n"},{"date":"2014-10-10T04:35:16Z","author":"benjchristensen","text":"I am unable to replicate this issue on 1.0.0-rc.5 while running the above code in a tight loop for several minutes.\n\nAlso Sharma, the easy and idiomatic way to serialize access to the Subject is like this:\n\n``` java\nfinal PublishSubject<Object> s = PublishSubject.create();\nfinal Observer<Object> _s = new SerializedObserver<Object>(s);\n```\n\nI think this is common enough I'm going to add a `SerializedSubject` wrapper.\n"}],"opened_by":"spodila","reopen":false,"closed_on":"2014-10-10T04:38:12Z","description":"This test case brings out two problems, seemingly due to concurrency bugs. They don't happen every time, but do happen if you repeat running it a handful of times. \n1. The Observable sequence hangs and eventually times out. Assert fail gets called for innerLatch.\n2. We get one more onNext() than expected. The last line assertEquals() fails with expected=250 and actual=251.\n\nProblem 1 happens easily if you repeat the test, say, 10 times. Problem 2 is rare. Although, I am not completely sure if my expectation for problem 2 is correct. \n\n``` java\n@Test\n    public void testParallelBatch() throws Exception {\n        final AtomicLong counter = new AtomicLong();\n        final Integer[] numbers = new Integer[5000];\n        for(int i=0; i<numbers.length; i++)\n            numbers[i] = i+1;\n        final int NITERS=250;\n        final CountDownLatch latch = new CountDownLatch(NITERS);\n        for(int iters=0; iters<NITERS; iters++) {\n            final CountDownLatch innerLatch = new CountDownLatch(1);\n            final PublishSubject s = PublishSubject.create();\n            Observable.from(numbers)\n                    .takeUntil(s)\n                    .window(50)\n                    .flatMap(new Func1<Observable<Integer>, Observable<Integer>>() {\n                        @Override\n                        public Observable<Integer> call(Observable<Integer> integerObservable) {\n                            return integerObservable\n                                    .subscribeOn(Schedulers.computation())\n                                    .map(new Func1<Integer, Integer>() {\n                                        @Override\n                                        public Integer call(Integer integer) {\n                                            if (integer >= 5) {\n                                                s.onCompleted();\n                                            }\n                                            \/\/ do some work\n                                            Math.pow(Math.random(), Math.random());\n                                            return integer * 2;\n                                        }\n                                    });\n                        }\n                    })\n                    .toList()\n                    .doOnNext(new Action1<List<Integer>>() {\n                        @Override\n                        public void call(List<Integer> integers) {\n                            counter.incrementAndGet();\n                            latch.countDown();\n                            innerLatch.countDown();\n                        }\n                    })\n                    .subscribe();\n            if(!innerLatch.await(10, TimeUnit.SECONDS))\n                Assert.fail(\"Failed inner latch wait, iteration \" + iters);\n        }\n        if(!latch.await(15, TimeUnit.SECONDS))\n            Assert.fail(\"Incomplete! Went through \" + latch.getCount() + \" iterations\");\n        else\n            Assert.assertEquals(NITERS, counter.get());\n    }\n```\n","id":"42253644","title":"Occasionally hanging sequence of takeUntil()+window()+flatMap()","opened_on":"2014-09-08T23:05:11Z","closed_by":"benjchristensen"},{"number":"1676","reopenOn":null,"comments":[{"date":"2014-10-10T04:57:30Z","author":"benjchristensen","text":"In 0.19 an NPE could happen if the Iterable was null: https:\/\/github.com\/ReactiveX\/RxJava\/blob\/0.19.x\/rxjava-core\/src\/main\/java\/rx\/internal\/operators\/OnSubscribeFromIterable.java#L39\n\nThis is fixed in 1.0: https:\/\/github.com\/ReactiveX\/RxJava\/blob\/v1.0.0-rc.5\/src\/main\/java\/rx\/internal\/operators\/OnSubscribeFromIterable.java#L43\n"},{"date":"2014-10-10T15:41:20Z","author":"zsxwing","text":"I feel a null `Iterable` is usually a programming error.I think throwing an NullPointerException in the constructor of `OnSubscribeFromIterable` is better. RxJava should not hide such error, so that people can find their mistake quickly.\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2014-10-10T04:57:30Z","description":"A report from RxJava 0.19.x:\n\n```\nCaused by: java.lang.NullPointerException\n        at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:39)\n        at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:29)\n        at rx.Observable$2.call(Observable.java:159)\n```\n","id":"42223236","title":"NPE in OnSubscribeFromIterable","opened_on":"2014-09-08T17:47:14Z","closed_by":"benjchristensen"},{"number":"1663","reopenOn":null,"comments":[{"date":"2014-09-23T22:12:55Z","author":"benjchristensen","text":"``` java\n    public <R> Observable<R> compose(Transformer<? super T, R> transformer) {\n        return transformer.call(this);\n    }\n\n    \/**\n     * Transformer function used by {@link #compose}.\n     * @warn more complete description needed\n     *\/\n    public static interface Transformer<T, R> extends Func1<Observable<? extends T>, Observable<R>> {\n        \/\/ cover for generics insanity\n    }\n\n```\n\nThis is what it is right now ... it's not right.\n"},{"date":"2014-09-23T22:13:21Z","author":"benjchristensen","text":"Either @headinthebox or @benjchristensen will buy a beer for whoever solves this!\n"},{"date":"2014-09-24T06:56:21Z","author":"akarnokd","text":"This compiles for me in Eclipse 4.4:\n\n```\nObservable<EurekaInstance> v = Observable.\n    create((Subscriber<? super EurekaInstance> subscriber) -> {\n\/\/ ...\n    });\nObservable<EurekaInstance> q = v.subscribeOn(Schedulers.io())\n    .compose((Observable<? extends EurekaInstance> o) -> o.map(t -> t));\nObservable<EurekaInstance> r = q.repeatWhen(a -> a.flatMap(\n    n -> Observable.timer(30, TimeUnit.SECONDS))); \/\/ repeat after 30 second delay;\n\nreturn r;\n```\n\nThe sad thing is that the types need to be reinforced at more places and the chain split into several parts.\n"},{"date":"2014-09-24T15:46:35Z","author":"zsxwing","text":"@benjchristensen could you try #1701?\n"},{"date":"2014-10-02T23:56:18Z","author":"benjchristensen","text":"This may be fixed via #1701 ... keeping open until fully confirming in systems using 1.0.0-rc.4\n"},{"date":"2014-10-10T20:33:59Z","author":"benjchristensen","text":"This is still hard to use ... I haven't figured this out for example:\n\n``` java\n\n    @Test\n    public void testComposeWithDeltaLogic() {\n        List<Movie> list1 = Arrays.asList(new Movie(), new HorrorMovie(), new ActionMovie());\n        List<Movie> list2 = Arrays.asList(new ActionMovie(), new Movie(), new HorrorMovie(), new ActionMovie());\n        Observable<List<Movie>> movies = Observable.just(list1, list2);\n        movies.compose(deltaTransformer);\n\n    }\n\n    static Transformer<Observable<? extends List<? super Movie>>, Observable<? super Movie>> deltaTransformer = new Transformer<Observable<? extends List<? super Movie>>, Observable<? super Movie>>() {\n\n        @Override\n        public Observable<? extends Observable<? super Movie>> call(Observable<? extends Observable<? extends List<? super Movie>>> movieList) {\n            return movieList\n                    .startWith(new ArrayList<Movie>())\n                    .buffer(2, 1)\n                    .skip(1)\n                    .flatMap(calculateDelta);\n        }\n\n\n    };\n\n\n    static Func1<List<List<Movie>>, Observable<Movie>> calculateDelta = new Func1<List<List<Movie>>, Observable<Movie>>() {\n\n        public Observable<Movie> call(List<List<Movie>> listOfLists) {\n            if (listOfLists.size() == 1) {\n                return Observable.from(listOfLists.get(0));\n            } else {\n                \/\/ diff the two\n                List<Movie> newList = listOfLists.get(1);\n                List<Movie> oldList = new ArrayList<Movie>(listOfLists.get(0));\n\n                Set<Movie> delta = new LinkedHashSet<Movie>();\n                delta.addAll(newList);\n                \/\/ remove all that match in old\n                delta.removeAll(oldList);\n\n                \/\/ filter oldList to those that aren't in the newList\n                oldList.removeAll(newList);\n\n                \/\/ for all left in the oldList we'll create DROP events\n                for (Movie old : oldList) {\n                    delta.add(new Movie());\n                }\n\n                return Observable.from(delta);\n            }\n        };\n    };\n```\n"},{"date":"2014-10-10T20:34:21Z","author":"benjchristensen","text":"If we can't get `compose` working easily I think we should remove it from 1.0 and only bring it back if we can eventually get the generics happy.\n"},{"date":"2014-10-14T03:13:22Z","author":"benjchristensen","text":"@akarnokd @zsxwing What do you think about this method signature?\n"},{"date":"2014-10-14T05:49:14Z","author":"zsxwing","text":"The following codes can work:\n\n``` java\n    @Test\n    public void testComposeWithDeltaLogic() {\n        List<Movie> list1 = Arrays.asList(new Movie(), new HorrorMovie(), new ActionMovie());\n        List<Movie> list2 = Arrays.asList(new ActionMovie(), new Movie(), new HorrorMovie(), new ActionMovie());\n        Observable<List<Movie>> movies = Observable.just(list1, list2);\n        movies.compose(deltaTransformer);\n\n    }\n\n    static Transformer<List<Movie>, Movie> deltaTransformer = new Transformer<List<Movie>, Movie>() {\n\n        @Override\n        public Observable<? extends Movie> call(Observable<? extends List<Movie>> o) {\n            Observable<List<Movie>> movieList = (Observable<List<Movie>>)o;\n            return movieList\n                    .startWith(new ArrayList<Movie>())\n                    .buffer(2, 1)\n                    .skip(1)\n                    .flatMap(calculateDelta);\n        }\n\n    };\n\n\n    static Func1<List<List<Movie>>, Observable<Movie>> calculateDelta = new Func1<List<List<Movie>>, Observable<Movie>>() {\n\n        public Observable<Movie> call(List<List<Movie>> listOfLists) {\n            if (listOfLists.size() == 1) {\n                return Observable.from(listOfLists.get(0));\n            } else {\n                \/\/ diff the two\n                List<Movie> newList = listOfLists.get(1);\n                List<Movie> oldList = new ArrayList<Movie>(listOfLists.get(0));\n\n                Set<Movie> delta = new LinkedHashSet<Movie>();\n                delta.addAll(newList);\n                \/\/ remove all that match in old\n                delta.removeAll(oldList);\n\n                \/\/ filter oldList to those that aren't in the newList\n                oldList.removeAll(newList);\n\n                \/\/ for all left in the oldList we'll create DROP events\n                for (Movie old : oldList) {\n                    delta.add(new Movie());\n                }\n\n                return Observable.from(delta);\n            }\n        };\n    };\n```\n"},{"date":"2014-10-14T05:56:30Z","author":"zsxwing","text":"So the problem of `Transformer` is that `Observable<? extends List<Movie>> o` is hard to use. Cannot assign `Observable<? extends List<Movie>>` to `Observable<List<Movie>>` is painful in Java. I cannot find any way to fix it.\n"},{"date":"2014-10-14T07:39:56Z","author":"akarnokd","text":"In the operators `publish` and `replay` the signatures are of `Func1<? super Observable<T>, ? extends Observable<R>> selector`, so no nested variance. The same happens in `multicast`. The rationale is that the first `? super Observable<T>` must be exact because the function is applied to the exact `Observable<T>` whereas the type of R comes from outside already and may carry its own variance.\n"},{"date":"2014-10-14T09:13:33Z","author":"zsxwing","text":"@akarnokd  so we should remove `Transformer` and change the signature to `public <R> Observable<R> compose(Func1<? super Observable<T>, ? extends Observable<R>> transformer)`?\n"},{"date":"2014-10-14T09:44:21Z","author":"akarnokd","text":"I guess in `lift` the use of `Operator` is a good way to convey the intent and meaning of the callback function to set it apart from regular stream processing. So if compose differs from publish and replay in a similar way, then lets keep it.\n"},{"date":"2014-10-14T16:39:24Z","author":"benjchristensen","text":"The reason for `Operator` in `lift` was to simplify the complex generics and allow the nested variance ... which works in that case. \n\nFor `compose` it has proven near impossible to use in any use case I've tried to use it for which means it's not very useful in its current state.\n"},{"date":"2014-10-14T17:54:29Z","author":"davidmoten","text":"I've been using compose of late and +1 for `Func1` as parameter instead\nof `Transformer`.  Is just a hassle especially for pre lambda code.\nOn 15 Oct 2014 05:39, \"Ben Christensen\" notifications@github.com wrote:\n\n> The reason for Operator in lift was to simplify the complex generics and\n> allow the nested variance ... which works in that case.\n> \n> For compose it has proven near impossible to use in any use case I've\n> tried to use it for which means it's not very useful in its current state.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/issues\/1663#issuecomment-59075941.\n"},{"date":"2014-10-14T18:58:46Z","author":"benjchristensen","text":"How would `Transformer` vs `Func` be any different? It's just a named `Func` to allow the nested variance, just like `Operator`.\n"},{"date":"2014-10-15T17:31:22Z","author":"vadims","text":"We're using compose and it's very convenient!\n\n``` java\n  public static <T> Observable.Transformer<Optional<T>, T> ifAbsentThrow(Func0<RuntimeException> absentCase) {\n    return source -> source.map(optional -> {\n      if (optional.isPresent()) {\n        return optional.get();\n      }\n      throw absentCase.call();\n    });\n  }\n\n    userQueryObservables.findByUsername(username)\n        .compose(ifAbsentThrow(() -> new UsernameNotFoundException(username)))\n        .flatMap(user -> ...)\n```\n"},{"date":"2014-10-15T17:38:58Z","author":"benjchristensen","text":"Would you recommend any signature changes based on your usage?\n"},{"date":"2014-10-15T19:19:17Z","author":"vadims","text":"We've hit the issue described above in a couple of places, so we had to suppress the unchecked warning.\n\nHave you considered creating a `CovariantTransformer` (for lack of a better name)?\n\n``` java\n    @SuppressWarnings(\"unchecked\")\n    public <R> Observable<R> compose(Transformer<T, ? extends R> transformer) {\n        return (Observable<R>) transformer.call(this);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <R> Observable<R> compose(CovariantTransformer<? super T, ? extends R> transformer) {\n        return (Observable<R>) transformer.call(this);\n    }\n\n    public static interface Transformer<T, R> extends Func1<Observable<T>, Observable<? extends R>> {\n    }\n\n    public static interface CovariantTransformer<T, R> extends Func1<Observable<? extends T>, Observable<? extends R>> {\n    }\n```\n\nthen your example above would be:\n\n``` java\n    @Test\n    public void testComposeWithDeltaLogic() {\n        List<Movie> list1 = Arrays.asList(new Movie(), new HorrorMovie(), new ActionMovie());\n        List<Movie> list2 = Arrays.asList(new ActionMovie(), new Movie(), new HorrorMovie(), new ActionMovie());\n        Observable<List<Movie>> movies = Observable.just(list1, list2);\n        movies.compose(deltaTransformer);\n\n    }\n\n    static Transformer<List<Movie>, Movie> deltaTransformer = new Transformer<List<Movie>, Movie>() {\n\n        @Override\n        public Observable<? extends Movie> call(Observable<List<Movie>> movieList) {\n            return movieList\n                .startWith(new ArrayList<Movie>())\n                .buffer(2, 1)\n                .skip(1)\n                .flatMap(calculateDelta);\n        }\n    };\n\n\n    static Func1<List<List<Movie>>, Observable<Movie>> calculateDelta = new Func1<List<List<Movie>>, Observable<Movie>>() {\n\n        public Observable<Movie> call(List<List<Movie>> listOfLists) {\n            if (listOfLists.size() == 1) {\n                return Observable.from(listOfLists.get(0));\n            } else {\n                \/\/ diff the two\n                List<Movie> newList = listOfLists.get(1);\n                List<Movie> oldList = new ArrayList<Movie>(listOfLists.get(0));\n\n                Set<Movie> delta = new LinkedHashSet<Movie>();\n                delta.addAll(newList);\n                \/\/ remove all that match in old\n                delta.removeAll(oldList);\n\n                \/\/ filter oldList to those that aren't in the newList\n                oldList.removeAll(newList);\n\n                \/\/ for all left in the oldList we'll create DROP events\n                for (Movie old : oldList) {\n                    delta.add(new Movie());\n                }\n\n                return Observable.from(delta);\n            }\n        };\n    };\n```\n\nIn `CovarianceTest` only one test case needed to be updated to use `CovariantTransformer`, the rest still use `Transformer` with the updated signature:\n\n``` java\n    @Test\n    public void testCovarianceOfCompose() {\n        Observable<HorrorMovie> movie = Observable.just(new HorrorMovie());\n        Observable<Movie> movie2 = movie.compose(new CovariantTransformer<Movie, Movie>() {\n\n            @Override\n            public Observable<? extends Movie> call(Observable<? extends Movie> t1) {\n                return Observable.just(new Movie());\n            }\n\n        });\n    }\n```\n"},{"date":"2014-10-15T21:02:48Z","author":"benjchristensen","text":"> Have you considered creating a CovariantTransformer (for lack of a better name)?\n\nI haven't and it concerns me somewhat because of type erasure and impact on dynamic languages as they would not be able to disambiguate between the two. \n\nAre these issues just weaknesses with Java or are we doing something wrong?\n"},{"date":"2014-10-16T01:06:21Z","author":"vadims","text":"What about #1762?\n"},{"date":"2014-10-16T03:32:03Z","author":"benjchristensen","text":"#1762 seems to work better. The following code using Java 8 compiles with #1762 but not with what is in trunk:\n\n``` java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport rx.Observable;\n\npublic class ComposeExample2 {\n\n    public static void main(String[] args) {\n        List<Movie> list1 = Arrays.asList(new Movie(), new HorrorMovie(), new ActionMovie());\n        List<Movie> list2 = Arrays.asList(new ActionMovie(), new Movie(), new HorrorMovie(), new ActionMovie());\n        Observable<List<Movie>> movies = Observable.just(list1, list2);\n        Observable<Movie> compose = movies.compose(ComposeExample2::transform);\n        compose.subscribe(System.out::println);\n    }\n\n    public static Observable<Movie> transform(Observable<List<Movie>> movieList) {\n        return movieList\n                .startWith(new ArrayList<Movie>())\n                .buffer(2, 1)\n                .skip(1)\n                .flatMap(ComposeExample2::calculateDelta);\n    }\n\n    public static Observable<Movie> calculateDelta(List<List<Movie>> listOfLists) {\n        if (listOfLists.size() == 1) {\n            return Observable.from(listOfLists.get(0));\n        } else {\n            \/\/ diff the two\n            List<Movie> newList = listOfLists.get(1);\n            List<Movie> oldList = new ArrayList<Movie>(listOfLists.get(0));\n\n            Set<Movie> delta = new LinkedHashSet<Movie>();\n            delta.addAll(newList);\n            \/\/ remove all that match in old\n            delta.removeAll(oldList);\n\n            \/\/ filter oldList to those that aren't in the newList\n            oldList.removeAll(newList);\n\n            \/\/ for all left in the oldList we'll create DROP events\n            for (Movie old : oldList) {\n                delta.add(new Movie());\n            }\n\n            return Observable.from(delta);\n        }\n    };\n\n    \/*\n     * Most tests are moved into their applicable classes such as [Operator]Tests.java\n     *\/\n\n    static class Media {\n    }\n\n    static class Movie extends Media {\n    }\n\n    static class HorrorMovie extends Movie {\n    }\n\n    static class ActionMovie extends Movie {\n    }\n\n    static class Album extends Media {\n    }\n\n    static class TVSeason extends Media {\n    }\n\n    static class Rating {\n    }\n\n    static class CoolRating extends Rating {\n    }\n\n    static class Result {\n    }\n\n    static class ExtendedResult extends Result {\n    }\n\n}\n```\n\nThank you @vadims \n"},{"date":"2014-10-16T07:48:24Z","author":"davidmoten","text":"Problem is the obvious candidate is a Func1 and the method cannot be passed\na Func1. I think it's unnecessary slowdown for confirming what the\nsignature of Transformer is and yes it's a Func1 under the covers. So\nhaving used it I'd categorise it as more obfuscation then help. It also\nprecludes reuse of Func1s.\nOn 15 Oct 2014 07:58, \"Ben Christensen\" notifications@github.com wrote:\n\n> How would Transformer vs Func be any different? It's just a named Func to\n> allow the nested variance, just like Operator.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/ReactiveX\/RxJava\/issues\/1663#issuecomment-59097684.\n"},{"date":"2014-10-16T14:26:37Z","author":"benjchristensen","text":"@davidmoten Are you saying you'd prefer this:\n\n``` java\n    public <R> Observable<R> compose(Func1<? super Observable<T>, ? extends Observable<? extends R>> transformer) {\n        \/\/ Casting to Observable<R> is type-safe because we know Observable is covariant.\n        return (Observable<R>) transformer.call(this);\n    }\n```\n\nIf we went that way then code like this:\n\n``` java\n    private static Transformer<? super String, String> appendWorldTransformer() {\n        return o -> o.map(s -> s + \" world!\").finallyDo(() -> {\n            System.out.println(\"  some side-effect\");\n        });\n    }\n```\n\nwould need to change to this:\n\n``` java\n    private static Func1<Observable<? super String>, Observable<? extends String>> appendWorldTransformer() {\n        return o -> o.map(s -> s + \" world!\").finallyDo(() -> {\n            System.out.println(\"  some side-effect\");\n        });\n    }\n```\n\nIs that what you're suggesting?\n\nIn Java 8 a method like this works with either signature:\n\n``` java\n    public static Observable<Movie> transform(Observable<List<Movie>> movieList) {\n        return movieList\n                .startWith(new ArrayList<Movie>())\n                .buffer(2, 1)\n                .skip(1)\n                .flatMap(ComposeExample2::calculateDelta);\n    }\n```\n\nOriginally the reason for the `Transformer` cover type was that we couldn't get the nested generics to work. The second reason is to make using it easier to use ... as figuring out nested variance is REALLY hard.\n\nI still can't figure out how to make this code work using `Func1`:\n\n``` java\n        Observable<Movie> movie2 = movie.compose(new Func1<Observable<Movie>, Observable<? extends Movie>>() {\n\n            @Override\n            public Observable<? extends Movie> call(Observable<Movie> t1) {\n                return Observable.just(new Movie());\n            }\n\n\n        });\n```\n\nHere is the error:\n\n```\nThe method compose(Func1<? super Observable<CovarianceTest.HorrorMovie>,? extends \nObservable<? extends R>>) in the type Observable<CovarianceTest.HorrorMovie> is not \napplicable for the arguments (new Func1<Observable<CovarianceTest.Movie>,Observable<? extends \nCovarianceTest.Movie>>(){})\n```\n\nSo if we're going to use `Func1` can you please propose a modification of #1762 that works?\n"},{"date":"2014-10-16T16:11:46Z","author":"benjchristensen","text":"Take a look at https:\/\/github.com\/ReactiveX\/RxJava\/pull\/1770#issuecomment-59387333 for example of code that needs to be made easy to write with `compose`.\n"},{"date":"2014-10-16T16:26:52Z","author":"benjchristensen","text":"I don't have a strong preference to using `Func1` or `Transformer` but I do want code that is usable by people without fighting for several minutes to figure out which incantation of super and extend they need to sprinkle in their signatures.\n\nThe type of code we should be able to easily write is shown above in https:\/\/github.com\/ReactiveX\/RxJava\/issues\/1663#issuecomment-59309638\n"},{"date":"2014-10-16T16:27:56Z","author":"benjchristensen","text":"I'd like to make a decision on this soon and move forward. The best option I've seen so far is https:\/\/github.com\/ReactiveX\/RxJava\/pull\/1762\n"},{"date":"2014-10-17T03:27:43Z","author":"benjchristensen","text":"Anyone have a better alternative than #1762 that makes the code examples above work? If not I'm proceeding with it.\n"},{"date":"2014-10-17T05:36:05Z","author":"davidmoten","text":"Re the`Func1` or `Transformer`, I'd suggest that the `Func1` be used for the `compose` signature and whatever gets resolved for `Transformer` is essentially a helper class for this method (that might have a corresponding overload but I suspect we won't be able to do that?). I'll have a look at #1762 hopefully in a few hours.\n"},{"date":"2014-10-17T05:44:47Z","author":"benjchristensen","text":"> that might have a corresponding overload but I suspect we won't be able to do that\n\nNo that can't be done because of type erasure.\n\n> I'd suggest that the Func1 be used for the compose signature and whatever gets resolved for Transformer is essentially a helper class for this method\n\nOne of the reasons we didn't do that for `lift` is because it is not discoverable and means the main public API that gets documented doesn't work correctly for co\/contra-variance.\n\nThe other reason is that doing that seems to break some of the co\/contra-variance use cases, such as this one:\n\n![screen shot 2014-10-16 at 10 44 07 pm](https:\/\/cloud.githubusercontent.com\/assets\/813492\/4674902\/fc5cb904-5585-11e4-8bb7-55da8c8e5512.png)\n"},{"date":"2014-10-17T05:53:32Z","author":"benjchristensen","text":"Just to be clear ... as I said earlier in the thread, if we can achieve co\/contra-variance on the unit tests and make the example code (https:\/\/github.com\/ReactiveX\/RxJava\/issues\/1663#issuecomment-59309638) work using just `Func1` I'm open to that as I don't like cover types. We spent a lot of time on `lift` though and determined we needed a cover type for the same reasons. `compose` and `lift` are similar in purpose and signature.\n"},{"date":"2014-10-18T22:40:15Z","author":"benjchristensen","text":"I went with @vadims proposal as I have not seen anything else achieve the desired combination of usage simplicity and support for co\/contra-variance. It was merged in https:\/\/github.com\/ReactiveX\/RxJava\/pull\/1776.\n\nI am not releasing the next version for at least 24 hours so if anyone wishes to debate this further that is the window of time to offer an alternative that works with the committed unit tests and the Java 8 code shown above (https:\/\/github.com\/ReactiveX\/RxJava\/issues\/1663#issuecomment-59309638).\n\nThank you everyone for your help in figuring this out and looking at various alternative. (Yet again I am reminded of how little I like working with co\/contra-variant generics in Java.)\n"},{"date":"2014-10-19T14:52:10Z","author":"zsxwing","text":"@benjchristensen could you take a look at #1778?\n"},{"date":"2014-10-19T19:04:40Z","author":"benjchristensen","text":"I will later today.\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2014-10-18T22:40:15Z","description":"The generics still don't work on `compose`.\n\n``` java\n    public Observable<EurekaInstance> getInstanceEvents(String appName) {\n        return Observable.\n                create((Subscriber<? super EurekaInstance> subscriber) -> {\n                    try {\n                        logger.info(\"Fetching instance list for app: \" + appName);\n                        Application app = DiscoveryManager.getInstance().getDiscoveryClient().getApplication(appName);\n                        if (app == null) {\n                            subscriber.onError(new RuntimeException(\"App not found: \" + appName));\n                            return;\n                        }\n                        System.out.println(\"App: \" + app);\n                        List<InstanceInfo> instancesForApp = app.getInstances();\n                        if (instancesForApp != null) {\n                            logger.info(\"Received instance list for app: \" + appName + \" = \" + instancesForApp.size());\n                            for (InstanceInfo instance : instancesForApp) {\n                                subscriber.onNext(EurekaInstance.create(instance));\n                            }\n                            subscriber.onCompleted();\n                        } else {\n                            subscriber.onError(new RuntimeException(\"Failed to retrieve instances for appName: \" + appName));\n                        }\n                    } catch (Throwable e) {\n                        subscriber.onError(e);\n                    }\n                })\n                .subscribeOn(Schedulers.io())\n                .compose(o -> o.map(t -> t)) \/\/ this won't let me do anything\n                .repeatWhen(a -> a.flatMap(n -> Observable.timer(30, TimeUnit.SECONDS))); \/\/ repeat after 30 second delay\n    }\n```\n","id":"41896323","title":"Observable.compose Generics","opened_on":"2014-09-04T05:27:51Z","closed_by":"benjchristensen"},{"number":"1585","reopenOn":null,"comments":[{"date":"2014-08-14T21:39:29Z","author":"benjchristensen","text":"The exception is getting thrown but `FutureTask` is swallowing it. It's not obvious to me as to what needs to change to make the ExecutorScheduler throw outside the Callable\/FutureTask. Will need to spend more time.\n"},{"date":"2014-08-15T06:58:57Z","author":"dvtomas","text":"OK, thank you. Any progress on this issue will be greatly appreciated.\n"},{"date":"2014-10-07T23:11:57Z","author":"benjchristensen","text":"Related to https:\/\/github.com\/ReactiveX\/RxJava\/issues\/1682\n"},{"date":"2014-10-10T05:48:57Z","author":"benjchristensen","text":"@dvtomas I have finished #1682. There isn't much that can be done other than output logs to System.err if exceptions are allowed to propagate without anything catching them (as your examples do) but at least now they won't fail silently. \n\nCan you please review #1682 and let me know if you have any better suggestions?\n\nHere is an example:\n\n``` java\n        Observable.interval(100, TimeUnit.MILLISECONDS).map(i -> {\n            throw new RuntimeException(\"fail!\");\n        }).subscribe();\n\n        Thread.sleep(1000);\n```\n\nnow outputs\n\n```\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:50)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: rx.exceptions.OnErrorNotImplementedException: fail!\n    at rx.Observable$36.onError(Observable.java:7387)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:128)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)\n    at rx.internal.operators.OperatorMap$1.onError(OperatorMap.java:48)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)\n    at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:118)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)\n    ... 7 more\nCaused by: java.lang.RuntimeException: fail!\n    at ErrorsTest.lambda$0(ErrorsTest.java:10)\n    at ErrorsTest$$Lambda$1\/1406718218.call(Unknown Source)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:54)\n    ... 10 more\nCaused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: Long.class\n    at rx.exceptions.OnErrorThrowable.addValueAsLastCause(OnErrorThrowable.java:98)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)\n    ... 10 more\n```\n"},{"date":"2014-10-13T16:32:05Z","author":"dvtomas","text":"I have had a look at #1682. I haven't tested it because it seems that rxjava-scala RCs haven't been released to Maven yet.\n\nMy original use case was that I have some observables I know should never fail. If they do, it means that some unhandled exception has been thrown in my code, and it is definitely a bug that should be resolved. In the same spirit as a bug in ordinary code results in an exception being thrown and thus immediate feedback to the developer, I have expected an exception in reactive code to do the same. \n\nNow that I see all the troubles with this issue, I think I'll change my approach to subscribing to observables. I'll just implement a special error handler for handling these \"never-failing\" observables, and pass it to them during subscribing. This handler could log the error, or try to somehow pass it to the main thread where it could be raised, or anything else. So, for me, your improvement with stack trace print will be a huge help especially during the transition to the handle-everything approach, but other than that I'll just work around this issue with this special handler.\n\nSo, as far as I am concerned, I'm happy with your fix and current state of affairs.\n\nThank you, regards, @dvtomas\n"},{"date":"2014-10-13T16:40:12Z","author":"benjchristensen","text":"Thanks for the feedback. \n"},{"date":"2014-12-29T23:09:01Z","author":"jondwillis","text":"@benjchristensen I have numerous occurrences of this crash throughout my application. However, I am finding it extremely difficult to hunt down the source of these crashes, since the stack trace does not lead back to my client code. Do you have any tips for tracking the source down, given that I have a pretty large codebase that is using schedulers, intervals, observeOns, etc., all over the place? \n"},{"date":"2014-12-30T06:43:21Z","author":"benjchristensen","text":"I responded to your question in the issue you opened: https:\/\/github.com\/ReactiveX\/RxJava\/issues\/2293#issuecomment-68334278\n"}],"opened_by":"dvtomas","reopen":false,"closed_on":"2014-10-13T16:40:12Z","description":"Hi all,\nthis one (and probably some other similar bugs) has been biting me badly last couple of weeks.\n\nRxScala 0.20.0-RC5. Let's have\n\n``` scala\nimport rx.lang.scala.Observable\nimport scala.concurrent.duration._\ndef fail(o: Observable[Long]) = o.map(x ⇒ if (x > 1) throw new RuntimeException(\"Bang!\"))\n```\n\nthen\n\n``` scala\nfail(Observable.items(1, 2, 3)).subscribe(println(_))\n```\n\nthrows a RuntimeException as expected, but\n\n``` scala\nfail(Observable.interval(100.milli)).subscribe(println(_))\nThread.sleep(1000)\n```\n\ndoes not. I'd expect it to throw an exception as well, albeit probably in a different thread.\n\nThank you, best regards, \n    Tomáš Dvořák\n","id":"40298243","title":"Exception not thrown from interval with blank onError","opened_on":"2014-08-14T20:56:37Z","closed_by":"benjchristensen"},{"number":"1571","reopenOn":null,"comments":[{"date":"2014-09-13T16:33:36Z","author":"siggijons","text":"I had a problem with this to when using the `TestObserver` to test errors.\nI'm using mockito so I worked this around creating my TestObservers like this:\n\n```\n    @SuppressWarnings(\"unchecked\")\n    public static <T> TestObserver<T> createTestObserver()\n    {\n        Observer<T> delegate = mock(Observer.class);\n        return new TestObserver<T>(delegate);\n    }\n```\n"},{"date":"2014-10-10T03:30:19Z","author":"benjchristensen","text":"Opening discussion about confusion between `EmptyObserver` and `Observers.empty()`: https:\/\/github.com\/ReactiveX\/RxJava\/issues\/1741\n"},{"date":"2014-10-10T03:44:50Z","author":"benjchristensen","text":"It will no longer throw an exception when a delegate is not provided. That was a mistake.\n"},{"date":"2014-10-10T09:13:35Z","author":"mttkay","text":":+1: \n"}],"opened_by":"mttkay","reopen":false,"closed_on":"2014-10-10T03:44:23Z","description":"I noticed that TestObserver was changed to always delegate calls, by default to the `EMPTY` Observer.\n\nHowever, the EMPTY Observer does not define `onError`, so any attempt to use TestObserver with an observable that's supposed to fail in a unit test crashes the test with a `OnErrorNotImplementedException`\n\nI wonder why this change was done? It adds complexity and surprise to something that should be void of behavior (mocks should record things, not perform logic IMHO)\n","id":"40054645","title":"TestObserver always delegates to EMPTY, throws exception","opened_on":"2014-08-12T13:30:12Z","closed_by":"benjchristensen"},{"number":"1566","reopenOn":null,"comments":[{"date":"2014-08-12T03:27:51Z","author":"benjchristensen","text":"Related to https:\/\/github.com\/Netflix\/RxJava\/pull\/1548\n"},{"date":"2014-08-14T19:57:30Z","author":"benjchristensen","text":"Done in https:\/\/github.com\/Netflix\/RxJava\/pull\/1583\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2014-08-14T19:57:30Z","description":"This code throws `MissingBackpressureException`:\n\n``` java\n        Observable<Integer> o1 = Observable.from(1, 1).concatWith(Observable.just(-1).repeat());\n        Observable<Integer> o2 = Observable.from(2, 2, 2, 2);\n        Observable.zip(o1, o2, (a, b) -> a + b).forEach(System.out::println);\n```\n\nIt should emit `3, 3, 1, 1` and end correctly.\n","id":"40021664","title":"Repeat\/Concat\/Zip Backpressure","opened_on":"2014-08-12T03:27:25Z","closed_by":"benjchristensen"},{"number":"1546","reopenOn":null,"comments":[{"date":"2014-09-23T17:31:53Z","author":"benjchristensen","text":"This is a bug, but it's been a bug for a while and doesn't affect public APIs so moving from 1.0 to 1.x milestone.\n"},{"date":"2014-10-17T13:23:59Z","author":"akarnokd","text":"What happens is that take(10) shuts down the emitter thread as soon as it receives the 10th Observable so the downstream receives random amount of data before the emitter checks again its client for unsubscription. Changing it to buffer(10) gives the required 10 items and doesn't hang.\n\n``` java\n        hotStream().buffer(10).take(5).flatMap(w -> {\n            return Observable.from(w).startWith(999999999);\n        }).toBlocking().forEach(System.out::println);\n```\n"},{"date":"2014-10-17T13:34:03Z","author":"akarnokd","text":"The hang happens because the flatMap never receives an onCompleted from the emitter and thus unable to release the latch in the blocking forEach.\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2014-11-06T06:07:05Z","description":"The following example should always have 10 items, including in the last window, but it non-deterministically has less, as if the unsubscribe from `take` is happening immediately and not letting it finish. \n\n``` java\npublic class WindowExample {\n\n    public static void main(String args[]) {\n        \/\/ buffer 10 items at a time (using 999999999 to mark start of output)\n        hotStream().window(10).take(10).flatMap(w -> w.startWith(999999999)).toBlocking().forEach(System.out::println);\n    }\n\n    \/**\n     * This is an artificial source to demonstrate an infinite stream that bursts intermittently\n     *\/\n    public static Observable<Integer> hotStream() {\n        return Observable.create((Subscriber<? super Integer> s) -> {\n            while (!s.isUnsubscribed()) {\n                \/\/ burst some number of items\n                for (int i = 0; i < Math.random() * 20; i++) {\n                    s.onNext(i);\n                }\n                try {\n                    \/\/ sleep for a random amount of time\n                    \/\/ NOTE: Only using Thread.sleep here as an artificial demo.\n                    Thread.sleep((long) (Math.random() * 1000));\n                } catch (Exception e) {\n                    \/\/ do nothing\n                }\n            }\n        }).subscribeOn(Schedulers.newThread()); \/\/ use newThread since we are using sleep to block\n    }\n\n}\n```\n","id":"39432192","title":"Window Unsubscribes Early?","opened_on":"2014-08-04T15:36:50Z","closed_by":"benjchristensen"},{"number":"1536","reopenOn":null,"comments":[{"date":"2014-08-05T21:07:40Z","author":"benjchristensen","text":"Anyone able to reproduce this? I haven't been able to. \n"},{"date":"2014-08-13T04:12:48Z","author":"benjchristensen","text":"I let `testStackOverflowIsThrown` run in a loop for 20+ minutes without issue.\n"},{"date":"2014-08-14T05:43:29Z","author":"benjchristensen","text":"Another CloudBees hang: https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1485\/console\n"},{"date":"2014-08-14T16:01:48Z","author":"benjchristensen","text":"Happened again here: https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1489\/consoleText\n\nBut this looks like it has more logs:\n\n```\nrx.exceptions.ExceptionsTest STANDARD_OUT\n    2571\n\nrx.exceptions.OnNextValueTest > addOnNextValueExceptionNotAddedWithBadString STANDARD_OUT\n    On Error: java.lang.IllegalArgumentException: Failure while handling\n        at rx.exceptions.OnNextValueTest$2.call(OnNextValueTest.java:101)\n        at rx.exceptions.OnNextValueTest$2.call(OnNextValueTest.java:98)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:54)\n        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:41)\n        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:30)\n        at rx.Observable$2.call(Observable.java:173)\n        at rx.Observable$2.call(Observable.java:166)\n        at rx.Observable.subscribe(Observable.java:8287)\n        at rx.Observable.subscribe(Observable.java:8156)\n        at rx.exceptions.OnNextValueTest.addOnNextValueExceptionNotAddedWithBadString(OnNextValueTest.java:97)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:606)\n        at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n        at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n        at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n        at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n        at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n        at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:80)\n        at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:47)\n        at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)\n        at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)\n        at sun.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:606)\n        at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n        at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n        at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n        at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n        at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\n        at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:103)\n        at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:606)\n        at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n        at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n        at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)\n        at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at java.lang.Thread.run(Thread.java:744)\n    Caused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: BadToString.class\n        at rx.exceptions.OnErrorThrowable.addValueAsLastCause(OnErrorThrowable.java:98)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)\n        ... 47 more\n\n\nrx.exceptions.OnNextValueTest > addOnNextValueExceptionAdded STANDARD_OUT\n    On Error: java.lang.IllegalArgumentException: Failure while handling\n        at rx.exceptions.OnNextValueTest$1.call(OnNextValueTest.java:87)\n        at rx.exceptions.OnNextValueTest$1.call(OnNextValueTest.java:84)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:54)\n        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:41)\n        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:30)\n        at rx.Observable$2.call(Observable.java:173)\n        at rx.Observable$2.call(Observable.java:166)\n        at rx.Observable.subscribe(Observable.java:8287)\n        at rx.Observable.subscribe(Observable.java:8156)\n        at rx.exceptions.OnNextValueTest.addOnNextValueExceptionAdded(OnNextValueTest.java:83)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:606)\n        at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n        at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n        at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n        at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n        at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n        at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:80)\n        at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:47)\n        at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)\n        at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)\n        at sun.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:606)\n        at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n        at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n        at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n        at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n        at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\n        at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:103)\n        at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:606)\n        at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n        at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n        at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)\n        at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at java.lang.Thread.run(Thread.java:744)\n    Caused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: BadToString.class\n        at rx.exceptions.OnErrorThrowable.addValueAsLastCause(OnErrorThrowable.java:98)\n        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)\n        ... 47 more\n\nBuild timed out (after 40 minutes). Marking the build as aborted.\n```\n"},{"date":"2014-08-18T20:36:16Z","author":"benjchristensen","text":"I can't replicate this and no one has reported this in prod\/dev usage, only Cloudbees, so I'm moving this to 1.0 and not blocking 0.20 on this.\n"},{"date":"2015-02-05T17:42:11Z","author":"akarnokd","text":"What happens is that a StackOverflowError is thrown but the check for it close (the stack is still next to full) so the attempt to report it may again cause another StackOverflowError. So instead of causing an actual StackOverflow, we could just throw one similar to how ThreadDeath is tested. Btw. `assertFalse(isComputerOn())`?\n"},{"date":"2015-09-03T08:23:37Z","author":"akarnokd","text":"I haven't seen this failure a long time so closing.\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2015-09-03T08:23:37Z","description":"Three builds have hung around the same place, near here:\n- rx.exceptions.ExceptionsTest > testStackOverflowIsThrown STANDARD_OUT\n- rx.exceptions.ExceptionsTest STANDARD_OUT\n\nThe logs can be seen at:\n- https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1456\/console\n- https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1432\/console\n- https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1461\/console\n\nI have tried to replicate in the `ExceptionsTest` code but have not succeeded.\n","id":"39116619","title":"Non-deterministic Hang - ExceptionsTest?","opened_on":"2014-07-30T17:29:00Z","closed_by":"akarnokd"},{"number":"1533","reopenOn":null,"comments":[{"date":"2014-07-30T05:22:43Z","author":"cloudbees-pull-request-builder","text":"[RxJava-pull-requests #1456](https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1456\/) ABORTED\n"},{"date":"2014-07-30T05:32:54Z","author":"benjchristensen","text":"I can not yet replicate the hang that's happening on the builds.\n\nIt has happened around this area twice:\n- https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1456\/console\n- https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1432\/console\n"},{"date":"2014-07-30T05:45:07Z","author":"cloudbees-pull-request-builder","text":"[RxJava-pull-requests #1457](https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1457\/) SUCCESS\nThis pull request looks good\n"},{"date":"2014-07-30T05:46:42Z","author":"benjchristensen","text":"Forcing the build again shows that this change is successful and that unfortunately it is indeed a non-deterministic hang somewhere.\n"},{"date":"2014-07-30T08:29:37Z","author":"headinthebox","text":"Amb (http:\/\/www-formal.stanford.edu\/jmc\/basis1\/node7.html#SECTION00025000000000000000) with back pressure is intrinsically hard. If you would do it on iterable you'd need to add a thread.\n\nGlancing at the code, I would request just a single item from each source initially.\n"},{"date":"2014-07-30T15:11:16Z","author":"benjchristensen","text":"@headinthebox I don't understand the complexity of backpressure on this. It is pretty straight forward to implement here. Whatever the child requests, we propagate to each of the parent `Observable`s and whichever one emits first wins and continues in the \"reactive pull\" relationship with the child. All the others are unsubscribed and emissions ignored. This means the `request(n)` count has a 1:1 relationship with whichever the winner is. What am I missing?\n"},{"date":"2014-07-30T15:32:35Z","author":"benjchristensen","text":"@zsxwing can you please review the various changes I've made to prevent race conditions and memory leaks?\n"},{"date":"2014-07-30T15:33:34Z","author":"cloudbees-pull-request-builder","text":"[RxJava-pull-requests #1459](https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1459\/) FAILURE\nLooks like there's a problem with this pull request\n"},{"date":"2014-07-30T15:35:47Z","author":"benjchristensen","text":"Ha ... I accidentally didn't commit the chunk of the file including the imports ... re-committing :-)\n"},{"date":"2014-07-30T15:54:53Z","author":"cloudbees-pull-request-builder","text":"[RxJava-pull-requests #1460](https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1460\/) SUCCESS\nThis pull request looks good\n"},{"date":"2014-07-30T16:31:14Z","author":"benjchristensen","text":"Rebased to collapse my 3 commits. Forced commit. Merging.\n\nThanks @zsxwing for the reviews and your initial work on this.\n"},{"date":"2014-07-30T17:23:40Z","author":"cloudbees-pull-request-builder","text":"[RxJava-pull-requests #1461](https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1461\/) ABORTED\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2014-07-30T16:31:18Z","description":"Building on top of https:\/\/github.com\/Netflix\/RxJava\/pull\/1516\n","id":"39059773","title":"Amb + Backpressure","opened_on":"2014-07-30T04:41:21Z","closed_by":"benjchristensen"},{"number":"1525","reopenOn":null,"comments":[{"date":"2014-08-08T19:43:36Z","author":"benjchristensen","text":"Thanks for the report @nitsanw \n"},{"date":"2014-10-07T23:04:41Z","author":"benjchristensen","text":"I just deleted the file since we aren't using it since we use the JCTools code instead.\n"}],"opened_by":"nitsanw","reopen":false,"closed_on":"2014-10-07T23:04:18Z","description":"https:\/\/github.com\/Netflix\/RxJava\/blob\/master\/rxjava-core\/src\/main\/java\/rx\/internal\/util\/MpscPaddedQueue.java#L124\n","id":"38885083","title":"Bug in Mpsc queue, should compare head to tail, not itself in peekNode","opened_on":"2014-07-28T12:26:20Z","closed_by":"benjchristensen"},{"number":"1522","reopenOn":null,"comments":[{"date":"2014-07-26T15:40:19Z","author":"benjchristensen","text":"Thanks for the report, I'll take a look soon.\n"},{"date":"2014-07-26T15:46:36Z","author":"zsxwing","text":"@benjchristensen I'm working on it. Looks a bug in takeLast\n"},{"date":"2014-08-08T19:44:27Z","author":"benjchristensen","text":"This test is passing now.\n"}],"opened_by":"davidmoten","reopen":false,"closed_on":"2014-08-08T19:44:27Z","description":"This test hangs with 0.20.0-RC3 I'm supposing because of `OperatorFilter`:\n\n``` java\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport rx.Observable;\nimport rx.functions.Functions;\n\npublic class BackpressureTest {\n\n    @Test\n    public void testDoesNotHang() {\n\n        Assert.assertEquals(0, Observable\n                .empty()\n                .count()\n                .filter(Functions.alwaysFalse())\n                .toList()\n                .toBlocking().single().size());\n    }\n\n}\n\n```\n","id":"38812983","title":"OperatorFilter failure","opened_on":"2014-07-26T08:19:21Z","closed_by":"benjchristensen"},{"number":"1516","reopenOn":null,"comments":[{"date":"2014-07-25T12:45:50Z","author":"cloudbees-pull-request-builder","text":"[RxJava-pull-requests #1437](https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1437\/) SUCCESS\nThis pull request looks good\n"},{"date":"2014-07-30T04:41:37Z","author":"benjchristensen","text":"Please take a look at https:\/\/github.com\/Netflix\/RxJava\/pull\/1533 which builds on top of your change.\n"},{"date":"2014-07-30T16:32:47Z","author":"zsxwing","text":"Close as done in #1533 \n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2014-07-30T16:32:47Z","description":"For #1475\n","id":"38725417","title":"Amb with backpressure support","opened_on":"2014-07-25T12:39:01Z","closed_by":"zsxwing"},{"number":"1507","reopenOn":null,"comments":[{"date":"2014-07-24T14:01:28Z","author":"cloudbees-pull-request-builder","text":"[RxJava-pull-requests #1433](https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1433\/) SUCCESS\nThis pull request looks good\n"},{"date":"2014-07-31T15:22:00Z","author":"cloudbees-pull-request-builder","text":"[RxJava-pull-requests #1463](https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/1463\/) SUCCESS\nThis pull request looks good\n"},{"date":"2014-08-01T09:57:41Z","author":"davidmoten","text":"isn't that potentially more than required? The number required is exactly `skip * (n-1) + count` isn't it?\n"},{"date":"2014-08-01T11:08:47Z","author":"zsxwing","text":"The number of the first request is `count + skip * (n - 1)`. The number of other requests should be `skip * n`.\nAssume we receive two request n1 and n2, then we should request `count + skip * (n1 + n2 - 1)` totally. When we receive the request n2, because we already requested `count + skip * (n1 - 1)`, we should request the remain number: `count + skip * (n1 + n2 - 1) - (count + skip * (n1 - 1)) = skip * n2`.\n"},{"date":"2014-08-01T11:15:50Z","author":"davidmoten","text":"Gotcha, thanks\nOn 1 Aug 2014 21:08, \"Shixiong Zhu\" notifications@github.com wrote:\n\n> The number of the first request is count + skip \\* (n - 1). The number of\n> other requests should be skip \\* n.\n> Assume we receive two request n1 and n2, then we should request count +\n> skip \\* (n1 + n2 - 1) totally. When we receive the request n2, because we\n> already request count + skip \\* (n1 - 1), we should request the remain\n> number: count + skip \\* (n1 + n2 - 1) - count + skip \\* (n1 - 1) = skip \\* n2\n> .\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/Netflix\/RxJava\/pull\/1507#issuecomment-50873059.\n"},{"date":"2014-08-11T22:19:18Z","author":"benjchristensen","text":"Thank you.\n"}],"opened_by":"zsxwing","reopen":false,"closed_on":"2014-08-11T22:19:11Z","description":"For #1479\n","id":"38633220","title":"BufferWithSize with Backpressure Support","opened_on":"2014-07-24T13:54:40Z","closed_by":"benjchristensen"},{"number":"1485","reopenOn":null,"comments":[{"date":"2014-08-08T19:53:23Z","author":"benjchristensen","text":"Currently non-deterministically broken so marking as bug to be done in 0.20\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2014-08-12T19:36:38Z","description":"The parallel operator needs to be updated to properly support backpressure.\n","id":"38493808","title":"Backpressure: parallel","opened_on":"2014-07-23T05:03:25Z","closed_by":"benjchristensen"},{"number":"1450","reopenOn":null,"comments":[{"date":"2014-07-25T21:09:38Z","author":"benjchristensen","text":"Thanks for this report. Fix coming ...\n"}],"opened_by":"atychyna","reopen":false,"closed_on":"2014-07-25T21:10:22Z","description":"See code snippet bellow. Basically in `BlockingOperatorToIterator.toIterator()` method \"lifted\" subscriber ignores exception in `onError(..)` method what makes iterator's `hasNext(..)` method to wait forever for a notification that never arrives.\n\n``` java\nIterable<String> strings = Observable.create(new Observable.OnSubscribe<String>() {\n    @Override\n    public void call(Subscriber<? super String> subscriber) {\n        throw new RuntimeException(\"intentional\");\n    }\n}).toBlocking().toIterable();\nfor (String string : strings) {\n    \/\/ never reaches here\n}\n```\n","id":"37996326","title":"BlockingOperatorToIterator hanging when exception is thrown from OnSubscribe.call(..)","opened_on":"2014-07-16T15:50:16Z","closed_by":"benjchristensen"},{"number":"1429","reopenOn":null,"comments":[{"date":"2014-07-25T20:40:04Z","author":"benjchristensen","text":"Thanks for the report. Fixed and merged.\n"}],"opened_by":"tomrozb","reopen":false,"closed_on":"2014-07-25T20:39:51Z","description":"Just reporting. HEAD fc86f8c3\n\n Class `rx.internal.util.RxRingBufferWithoutUnsafeTest`\n`testConcurrency`\n\n```\njava.lang.AssertionError: expected:<94390> but was:<94389>\n    at org.junit.Assert.fail(Assert.java:93)\n    at org.junit.Assert.failNotEquals(Assert.java:647)\n    at org.junit.Assert.assertEquals(Assert.java:128)\n    at org.junit.Assert.assertEquals(Assert.java:472)\n    at org.junit.Assert.assertEquals(Assert.java:456)\n    at rx.internal.util.RxRingBufferWithoutUnsafeTest.testConcurrency(RxRingBufferWithoutUnsafeTest.java:166)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.internal.runners.statements.FailOnTimeout$StatementThread.run(FailOnTimeout.java:62)\n```\n\n Class `rx.internal.util.RxRingBufferSpmcTest`\n`testConcurrency`\n\n```\njava.lang.AssertionError: expected:<0> but was:<530>\n    at org.junit.Assert.fail(Assert.java:93)\n    at org.junit.Assert.failNotEquals(Assert.java:647)\n    at org.junit.Assert.assertEquals(Assert.java:128)\n    at org.junit.Assert.assertEquals(Assert.java:472)\n    at org.junit.Assert.assertEquals(Assert.java:456)\n    at rx.internal.util.RxRingBufferSpmcTest.testConcurrency(RxRingBufferSpmcTest.java:164)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.internal.runners.statements.FailOnTimeout$StatementThread.run(FailOnTimeout.java:62)\n```\n","id":"37655126","title":"RxRingBuffer test fails","opened_on":"2014-07-11T12:17:59Z","closed_by":"benjchristensen"},{"number":"1370","reopenOn":null,"comments":[{"date":"2014-06-17T20:29:04Z","author":"headinthebox","text":"We will bring back `Observable.create` just as it was before. But yes, `apply` and `create` are not the same.\n"},{"date":"2014-07-25T20:11:12Z","author":"benjchristensen","text":"@headinthebox Anything to do here?\n"}],"opened_by":"tindzk","reopen":false,"closed_on":"2014-07-25T20:44:12Z","description":"Reading the deprecation notice a developer may assume that `Observable.apply` and `Observable.create` may be equivalent. However, when changing the following example to `Observable[Unit] {...}`, the unsubscription code does not get called anymore.\n\n``` scala\ndef collision = Observable.create[Unit] { obs =>\n  val sub: Subscription = accelerometerObservable.filter(_.x < -2).subscribe(_ => {\n    obs.onNext()\n  })\n\n  Subscription {\n    sub.unsubscribe\n  }\n}\n```\n\nInstead, the developer would have to write:\n\n``` scala\ndef collision = Observable[Unit] { obs =>\n  val sub: Subscription = accelerometerObservable.filter(_.x < -2).subscribe(_ => {\n    obs.onNext()\n  })\n\n  obs.add(Subscription {\n    sub.unsubscribe\n  })\n}\n```\n\nUnfortunately, we figured out this solution only after reading the sources. The documentation should mention this way of running arbitrary code upon unsubscription.\n","id":"35924212","title":"rx.lang.scala.Observable: Misleading deprecation notice.","opened_on":"2014-06-17T19:43:16Z","closed_by":"headinthebox"},{"number":"1360","reopenOn":null,"comments":[{"date":"2014-06-14T17:02:38Z","author":"niqo01","text":"I forgot the nice share Crashlytics feature: http:\/\/crashes.to\/s\/a5ab97ddcfc for complete details\n"},{"date":"2014-06-14T18:25:42Z","author":"niqo01","text":"See #1354 \n"},{"date":"2014-06-15T07:38:04Z","author":"Bananeweizen","text":"You may want to comment on #1361, which should fix that issue.\n"},{"date":"2014-07-09T02:19:13Z","author":"dpsm","text":"@niqo01 this should be fixed since 0.19.2. Do you still have the issue? @benjchristensen keep an eye on this issue since we might want to close once we confirm the issue is fixed.\n"},{"date":"2014-07-25T20:06:44Z","author":"benjchristensen","text":"The `observeOn` operator is changed significantly in 0.20, so can anyone review and confirm whether this is still fixed in 0.20.0-RC3 or later?\n"},{"date":"2014-07-25T22:00:27Z","author":"niqo01","text":"@dpsm I don't know how to reproduce myself, the only way I see is to deliver an update in production and wait and see our crash report tools. I ll update to 0.20, release and let you know if I see it again.\n"},{"date":"2014-08-08T20:50:29Z","author":"benjchristensen","text":"pollQueue in `observeOn` has a null check and based on https:\/\/github.com\/Netflix\/RxJava\/pull\/1361 and then work in 0.20 I think this is fixed. Please open a new ticket if the issue returned in 0.20 somehow.\n"}],"opened_by":"niqo01","reopen":false,"closed_on":"2014-08-08T20:50:29Z","description":"One of my production user got the following `NullPointerException`:\nEnvironment:\n- rxjava-android: 0.19.0\n- Android: 4.4.2\n- Device: GT-I9505\n\n```\njava.lang.NullPointerException\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:135)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:61)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$1.call(OperatorObserveOn.java:121)\n       at rx.android.schedulers.HandlerThreadScheduler$InnerHandlerThreadScheduler$1.run(HandlerThreadScheduler.java:77)\n       at android.os.Handler.handleCallback(Handler.java:733)\n       at android.os.Handler.dispatchMessage(Handler.java:95)\n       at android.os.Looper.loop(Looper.java:157)\n       at android.app.ActivityThread.main(ActivityThread.java:5356)\n       at java.lang.reflect.Method.invokeNative(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:515)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1265)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1081)\n       at dalvik.system.NativeStart.main(NativeStart.java)\n```\n","id":"35732121","title":"NPE in OperatorObserveOn RxJava 0.19","opened_on":"2014-06-14T16:58:17Z","closed_by":"benjchristensen"},{"number":"1349","reopenOn":null,"comments":[{"date":"2014-06-11T11:12:56Z","author":"samuelgruetter","text":"Good catch, thanks for pointing it out. The implementation uses `timespan.unit.convert`, which is wrong, because it might do rounding. Appears several times in Observable.scala.\n"},{"date":"2014-06-11T19:07:15Z","author":"headinthebox","text":"Which is why I proposed to have `public final Observable<List<T>> buffer(long timespan, long timeshift, TimeUnit unit)` take _two_ time units. One for the `timespan`, one for the `timeshift`. Having just one is like having `exchangeRate(decimal from, decimal to, Currency unit)`.\n"},{"date":"2014-07-25T19:51:28Z","author":"benjchristensen","text":"Is someone going to fix anything about this and what is considered the right fix? \n\nIn RxScala it's fine to pursue new signatures, but in Java we have already debated this and decided to stay with the Java contention of a single TimeUnit for the method.\n"},{"date":"2014-07-25T20:47:14Z","author":"headinthebox","text":"I'll double check all uses of timespan in the scala bindings.\n"},{"date":"2014-08-18T20:37:31Z","author":"benjchristensen","text":"@headinthebox Can this get finished today or should I release 0.20 without this?\n"},{"date":"2014-09-23T21:56:40Z","author":"benjchristensen","text":"Opened issue on new RxScala project: https:\/\/github.com\/ReactiveX\/RxScala\/issues\/14\n"}],"opened_by":"lJoublanc","reopen":false,"closed_on":"2014-09-23T21:56:41Z","description":"I'm on 0.16. The following code will throw an IllegalArgumentException:\n\n```\nscala> val obs = Observable.interval(100 milliseconds).buffer(3 seconds, 500 milliseconds)\nobs: rx.lang.scala.Observable[Seq[Long]] = rx.lang.scala.JavaConversions$$anon$1@6f6b1731\n\nscala> obs.subscribe{x =>println(x)}\nrx.exceptions.OnErrorNotImplementedException\n    at rx.Observable$25.onError(Observable.java:6805)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:124)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:93)\n    at rx.Observable$2.call(Observable.java:280)\n    at rx.Observable$2.call(Observable.java:268)\n    at rx.Observable.subscribe(Observable.java:7076)\n    at rx.Observable.protectivelyWrapAndSubscribe(Observable.java:5396)\n    at rx.Observable.subscribe(Observable.java:6796)\n    at rx.lang.scala.Observable$class.subscribe(Observable.scala:132)\n    at rx.lang.scala.JavaConversions$$anon$1.subscribe(JavaConversions.scala:53)\n    at .<init>(<console>:14)\n    at .<clinit>(<console>)\n    at .<init>(<console>:7)\n    at .<clinit>(<console>)\n    at $print(<console>)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at scala.tools.nsc.interpreter.IMain$ReadEvalPrint.call(IMain.scala:734)\n    at scala.tools.nsc.interpreter.IMain$Request.loadAndRun(IMain.scala:983)\n    at scala.tools.nsc.interpreter.IMain.loadAndRunReq$1(IMain.scala:573)\n    at scala.tools.nsc.interpreter.IMain.interpret(IMain.scala:604)\n    at scala.tools.nsc.interpreter.IMain.interpret(IMain.scala:568)\n    at scala.tools.nsc.interpreter.ILoop.reallyInterpret$1(ILoop.scala:756)\n    at scala.tools.nsc.interpreter.ILoop.interpretStartingWith(ILoop.scala:801)\n    at scala.tools.nsc.interpreter.ILoop.command(ILoop.scala:713)\n    at scala.tools.nsc.interpreter.ILoop.processLine$1(ILoop.scala:577)\n    at scala.tools.nsc.interpreter.ILoop.innerLoop$1(ILoop.scala:584)\n    at scala.tools.nsc.interpreter.ILoop.loop(ILoop.scala:587)\n    at scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply$mcZ$sp(ILoop.scala:878)\n    at scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply(ILoop.scala:833)\n    at scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply(ILoop.scala:833)\n    at scala.tools.nsc.util.ScalaClassLoader$.savingContextLoader(ScalaClassLoader.scala:135)\n    at scala.tools.nsc.interpreter.ILoop.process(ILoop.scala:833)\n    at scala.tools.nsc.MainGenericRunner.runTarget$1(MainGenericRunner.scala:83)\n    at scala.tools.nsc.MainGenericRunner.process(MainGenericRunner.scala:96)\n    at scala.tools.nsc.MainGenericRunner$.main(MainGenericRunner.scala:105)\n    at scala.tools.nsc.MainGenericRunner.main(MainGenericRunner.scala)\nCaused by: java.lang.IllegalArgumentException\n    at java.util.concurrent.ScheduledThreadPoolExecutor.scheduleAtFixedRate(ScheduledThreadPoolExecutor.java:562)\n    at rx.schedulers.ExecutorScheduler.schedulePeriodically(ExecutorScheduler.java:75)\n    at rx.operators.ChunkedOperation$TimeBasedChunkCreator.<init>(ChunkedOperation.java:579)\n    at rx.operators.OperationBuffer$7.onSubscribe(OperationBuffer.java:360)\n    at rx.Observable$1.call(Observable.java:235)\n    at rx.Observable$1.call(Observable.java:231)\n    at rx.Observable$2.call(Observable.java:272)\n    ... 35 more\n```\n\nLooking at the implementation of the scheduler, the error is raised when the argument is less than zero. So there appears to be a problem causing the `timeshift` to be rounded down. If you change the `timeshift` to 1 second or larger, it works fine.\n","id":"35374554","title":"RxScala: buffer(timespan,timeshift) raises IllegalArgumentException for timeshift < 1 second","opened_on":"2014-06-10T11:57:00Z","closed_by":"benjchristensen"},{"number":"1341","reopenOn":null,"comments":[{"date":"2014-06-11T11:32:46Z","author":"samuelgruetter","text":"Looks like there's nothing we can do here (https:\/\/issues.scala-lang.org\/browse\/SI-2383). But maybe swap order: initialValue as first arg, selector as second?\n"},{"date":"2014-06-11T18:57:44Z","author":"headinthebox","text":"I was hoping to make type inference flow such that we don't need to write a type for the lambda parater. Swapping them will not help with that.\n"},{"date":"2014-07-24T05:13:38Z","author":"benjchristensen","text":"I actually don't remember where we got that signature from in Java core.\n"},{"date":"2014-07-24T05:13:54Z","author":"benjchristensen","text":"Is there anything more to do for this, or should we close it?\n"},{"date":"2014-07-24T08:57:02Z","author":"headinthebox","text":"Keep it open. Still experimenting to make this not require a type.\n"},{"date":"2014-08-18T20:37:39Z","author":"benjchristensen","text":"@headinthebox Can this get finished today or should I release 0.20 without this?\n"},{"date":"2014-09-23T21:57:33Z","author":"benjchristensen","text":"Moved to https:\/\/github.com\/ReactiveX\/RxScala\/issues\/15\n"}],"opened_by":"headinthebox","reopen":false,"closed_on":"2014-09-23T21:57:33Z","description":"It seems we cannot swap and curry the arguments of \n\n```\ndef publish[U >: T, R](selector: Observable[U] => Observable[R], initialValue: U): Observable[R] \n```\n\nsince that causes ambiguity with \n\n```\ndef publish[U >: T](initialValue: U): ConnectableObservable[U]\n```\n\nInterestingly .NET does not have `publish` with a function and initial value.\n","id":"35287553","title":"RxScala: Publish","opened_on":"2014-06-09T14:11:59Z","closed_by":"benjchristensen"},{"number":"1322","reopenOn":"2014-06-23T16:11:14Z","comments":[{"date":"2014-06-20T16:56:32Z","author":"DavidMGross","text":"Tagging folks who can likely help with some of this:\n- @akarnokd: `Observable` (`cache`)\n- @benjchristensen: `Exceptions`, `MpscPaddedQueue`, `Notification`, `ExecutorScheduler`, `OperatorGroupByUntil`, `BufferUntilSubscriber`, `NotificationLite`, `Observable` (`cache`, `multicast`)\n- @jbripley: `NewThreadWorker`, `ScheduledAction`\n- @samuelgruetter: `Notification`\n\nSome of this has gone \"internal\/\", and therefore may not need as much javadoc attention, but the rest need a look.\n"},{"date":"2014-06-20T17:23:49Z","author":"headinthebox","text":"`toList` looks OK to me.\n"},{"date":"2014-06-20T17:30:26Z","author":"headinthebox","text":"`multicast` is pretty crazy; it is really a helper function for other forms of multicasting like `publish` and `publishLast` so I don't think it is super important (or even possible:-) to improve the description. I even doubt people are using the raw version outside the core library.\n"},{"date":"2014-06-20T17:34:40Z","author":"headinthebox","text":"for `Subscriber.add` you can say `The subscription to add` (copy & paste from `CompositeSubscription`).\n"},{"date":"2014-06-20T17:40:04Z","author":"headinthebox","text":"For `Subscribers` you can copy and paste the doc comments from `Subscriptions`, i.e. something like:\n\n```\n\/**\n * Helper methods and utilities for creating and working with {@link Subscriber} objects\n *\/\n```\n"},{"date":"2014-06-20T17:41:28Z","author":"headinthebox","text":"For `observers\/Observers.java` same as `Subscribers`, helper methods.\n"},{"date":"2014-06-20T17:44:30Z","author":"headinthebox","text":"`Subject.java` something like \"Represents an object that is both an observable sequence as well as an observer\". Good catch, surprised this has been without a doc comment for so long.\n"},{"date":"2014-06-20T17:49:18Z","author":"headinthebox","text":"`subscriptions\/MultipleAssignmentSubscription.java`, `set` --> \"sets the underlying subscription\", `get` --> \"retrieves the underlying subscription\". We should also mention that is multipleassignmentsubscription is already unsubscribed, setting a new subscription causes it to be immediately to be unsubscribed.\n"},{"date":"2014-06-20T20:42:49Z","author":"DavidMGross","text":"On `Subscriber.add` the description of the function says that it registers an unsubscribe callback; does the `subscription` passed in as a parameter need to be initialized in any particular way to serve as a callback? How does that subscription detect the unsubscribe callback? Or is the description incomplete, and this function does more than register an unsubscribe callback?\n"},{"date":"2014-06-20T22:20:39Z","author":"headinthebox","text":"That's just sloppy language, identifying a subscription with `public void unsubscribe()`.\n"},{"date":"2014-07-24T16:55:52Z","author":"benjchristensen","text":"Closing this out as it's been quiet a while. @DavidMGross If any remaining issues need assistance, open specific issues for each item and assign to the applicable person.\n"},{"date":"2014-07-24T17:25:52Z","author":"DavidMGross","text":"New issues for remaining javadoc-related needs: #1508 #1509 #1510 #1511 #1512 \n"}],"opened_by":"DavidMGross","reopen":true,"closed_on":"2014-07-24T16:55:52Z","description":"I've gone through those parts of the source code that are reflected in the rxjava-core javadocs and flagged those parts of the javadoc comments that are missing or that need attention.  In those areas where I felt confident enough to fill in the gaps myself, I have done so, but that still leaves some gaps unfilled.  If you are the implementer or if you have the necessary expertise, could you review the files on this list for missing javadocs?\n\nI've flagged the areas that need help with \"@warn\" tags.  That tag is not part of the javadoc standard, so it triggers a javadoc compilation warning.  Please remove those tags from the areas that you fix.\n\n<s>subscriptions\/MultipleAssignmentSubscription.java\n  [set() and get()]<\/s>\n\n<s>subjects\/Subject.java\n  [class description]<\/s>\n\n<s>subjects\/TestSubject.java\n  [all javadocs missing except class description which seems copy-pasted]<\/s>\n\n<s>observers\/Observers.java\n  [class description]<\/s>\n\n<s>observers\/Subscribers.java\n  [class description]<\/s>\n\n<s>observers\/TestSubscriber.java\n  [awaitTerminalEvent(), awaitTerminalEventAndUnsubscribeOnTimeout(), getLastSeenThread()]<\/s>\n\nexceptions\/Exceptions.java\n  [<del>all javadocs missing<\/del><ins>class description & propagage()<\/ins>]\n\n<s>exceptions\/OnErrorThrowable.java\n  [class description, getValue(), OnNextValue inner class]<\/s>\n\nNotification.java\n  [createOnCompleted()]\n\nObservable.java\n  [cache(), multicast(), <s>toList()<\/s>]\n\n<s>Subscriber.java\n  [add()]<\/s>\n","id":"34978073","title":"Missing javadoc comments","opened_on":"2014-06-04T16:44:26Z","closed_by":"benjchristensen"},{"number":"1259","reopenOn":null,"comments":[{"date":"2014-05-24T19:26:17Z","author":"akarnokd","text":"This works:\n\n``` java\npublic class RecursiveDeadlock {\n    public static void main(String[] args) throws Exception {\n        BehaviorSubject<Integer> delay = BehaviorSubject.create(0);\n\n        Observable<Integer> nats = delay.observeOn(Schedulers.newThread())\n                .doOnEach(Observers.create(n -> delay.onNext(n + 1), \n                        Throwable::printStackTrace, \n                        () -> System.out.println(\"Done\")));\n\n        nats.subscribe(System.out::println, Throwable::printStackTrace, () -> System.out.println(\"DONE\"));\n\n        Thread.sleep(1000);\n    }\n}\n```\n\nPrints a few thousand numbers before terminating. This doesn't terminate but prints continuously:\n\n``` java\n    public static void main(String[] args) throws Exception {\n        BehaviorSubject<Integer> delay = BehaviorSubject.create(0);\n\n        Observable<Integer> nats = delay.observeOn(Schedulers.trampoline())\n                .doOnEach(Observers.create(n -> delay.onNext(n + 1), \n                        Throwable::printStackTrace, \n                        () -> System.out.println(\"Done\")));\n\n        nats.subscribe(System.out::println, Throwable::printStackTrace, () -> System.out.println(\"DONE\"));\n\n        Thread.sleep(1000);\n    }\n```\n\nNote the use of `Schedulers.trampoline()` which should be the equivalent of `CurrentThreadScheduler.Instance`.\n"},{"date":"2014-05-24T19:45:18Z","author":"headinthebox","text":"(tried the other schedulers as well, sorry for leaving different ones in the samples)\n\nBut this does not work\n\n```\nBehaviorSubject<Integer> delay = BehaviorSubject.create(0);\n        Observable<Integer> nats = delay.observeOn(Schedulers.trampoline()).doOnNext(n -> delay.onNext(n + 1));\n        nats.subscribe(System.out::println, Throwable::printStackTrace, () -> System.out.println(\"DONE\"));\n        System.in.read();\n```\n"},{"date":"2014-05-24T20:08:39Z","author":"akarnokd","text":"This prints a bunch of numbers for me (using master) but can't terminate it with pressing Enter because it runs in the main thread and the `read()` call is never reached.\n"},{"date":"2014-05-24T20:27:02Z","author":"headinthebox","text":"I'm using 18.3\n"},{"date":"2014-05-24T20:33:17Z","author":"akarnokd","text":"Could be either the sequence gap bug or a reentrancy problem with BehaviorSubject.\n"},{"date":"2014-06-01T04:56:18Z","author":"benjchristensen","text":"@akarnokd Are you digging into this already?\n\nIs this important to get into 0.19.0, or can it come in a 0.19.x release?\n"},{"date":"2014-06-01T06:55:20Z","author":"akarnokd","text":"I never experienced the issue with master. @headinthebox can you test your case with master?\n"},{"date":"2014-07-24T07:23:55Z","author":"benjchristensen","text":"This works for me:\n\n``` java\n        BehaviorSubject<Integer> delay = BehaviorSubject.create(0);\n        Observable<Integer> nats = delay.observeOn(Schedulers.trampoline()).doOnNext(n -> delay.onNext(n + 1));\n        nats.subscribe(System.out::println);\n```\n\nso does this:\n\n``` java\n        BehaviorSubject<Integer> delay = BehaviorSubject.create(0);\n        Observable<Integer> nats = delay.observeOn(Schedulers.newThread()).doOnNext(n -> delay.onNext(n + 1));\n        nats.toBlocking().forEach(System.out::println);\n```\n"},{"date":"2014-07-24T07:24:11Z","author":"benjchristensen","text":"Closing out as it looks solved ... reopen if it is still an issue with 0.20.\n"}],"opened_by":"headinthebox","reopen":false,"closed_on":"2014-07-24T07:24:11Z","description":"In RxJava\/RxScala, the following example prints 0 and then is dead:\n\n``` scala\nval delay = BehaviorSubject(0)\nval nats = delay.observeOn(rx.lang.scala.schedulers.NewThreadScheduler())\n                    .doOnEach(n => delay.onNext(n+1))\nnats.subscribe(n => println(n))\n```\n\nWhereas in Rx.NET the equivalent program works just fine, and prints `0, 1, 2, ...`\n\n``` C#\nvar delay = new BehaviorSubject<int>(0);\nvar nats = delay.ObserveOn(CurrentThreadScheduler.Instance).Do(n => delay.OnNext(n+1))\nnats.Subscribe(Console.WriteLine);\n```\n","id":"34240539","title":"Deadlock with recursive chain","opened_on":"2014-05-24T19:12:57Z","closed_by":"benjchristensen"},{"number":"1251","reopenOn":null,"comments":[{"date":"2014-06-01T05:00:34Z","author":"benjchristensen","text":"@zsxwing Can you get these in soon before 0.19? Otherwise we can pick them up in 0.19.1.\n\nBy the way, `mergeMap` was created as an alias after discussion with you when we created `concatMap` and `switchMap`. The idea was to have \"map\" functions for each of `merge`, `concat`, and `switch`, but that `flatMap` is the term everyone uses for `mergeMap` so both would exist.\n\nIt seems you feel differently now? Should we deprecate `mergeMap` in rxjava-core and remove it when we hit 1.0RC?\n"},{"date":"2014-06-01T08:04:43Z","author":"headinthebox","text":"Totally inconsistent I know, but I like to have all the aliases in RxJava core, but for the Scala bindings it feels more natural to only have `flatMap` and drop the `mergeMap` alias. But as I say, this is totally irrational ;-) and I would be OK to have all. \n"},{"date":"2014-06-02T04:42:07Z","author":"zsxwing","text":"> @zsxwing Can you get these in soon before 0.19? Otherwise we can pick them up in 0.19.1.\n\n@benjchristensen this one will not be a breaking change in RxScala. So both are good to me.\n"},{"date":"2014-06-02T05:02:19Z","author":"headinthebox","text":"@zsxwing Any preference? We can always add `mergeMap` later, but once we put it in as an alias for `flatMap` it is in forever.\n"},{"date":"2014-06-02T08:33:05Z","author":"jbripley","text":"Speaking as a user of RxScala and Scala, I would say just to have flatMap, since that's what a Scala user would expect. Anything inherit in the missing mergeMap functions that would make that confusing?\n"},{"date":"2014-06-02T14:58:58Z","author":"zsxwing","text":"@headinthebox I mean now there is only a `flatMap` method in RxScala, so we can add other methods to RxScala at any time without breaking anything. Never mind. Already sent a PR to add them, #1304\n"}],"opened_by":"headinthebox","reopen":false,"closed_on":"2014-06-02T16:02:22Z","description":"Bindings for `mergeMap` and `concatMap` are missing in RxScala.\n\nMy proposal is to merge `mergeMap` and `flatMap`.\n","id":"34132204","title":"RxScala mergeMap and concatMap bindings missing","opened_on":"2014-05-22T23:50:03Z","closed_by":"benjchristensen"},{"number":"614","reopenOn":null,"comments":[{"date":"2013-12-12T21:40:12Z","author":"headinthebox","text":"Saw errors in those in my tests yesterday as well. \n"},{"date":"2014-01-02T20:52:00Z","author":"benjchristensen","text":"Fixed and merged.\n"}],"opened_by":"abersnaze","reopen":false,"closed_on":"2014-01-02T20:52:01Z","description":"The merge operation passes calls to the actual observer through an instance of SynchronizedObserver but merge delay error doesn't.  This is causing overlapping calls to onNext and all sorts of concurrency bugs in our server.\n","id":"24210399","title":"Merge delay error doesn't synchronize onNext calls","opened_on":"2013-12-12T21:36:45Z","closed_by":"benjchristensen"},{"number":"577","reopenOn":null,"comments":[{"date":"2013-12-06T23:59:50Z","author":"mattrjacobs","text":"In English:\n\n2 CompositeSubscriptions (denoted using last 2 letters of memory address): 00 and 60\n1 MultipleAssignmentSubscription : 80\n\nThread 7:\nComposite-00.add\nMultipleAssignment-80.unsubscribe\n\nThread 8:\nComposite-60.add\nMultipleAssignment-80.unsubscribe\nComposite-00.unsubscribe\n\nSo I believe there are 2 bugs here - a circular reference between subscriptions and a deadlock when unsubscribes happen on circular subscriptions\n"},{"date":"2013-12-07T00:03:56Z","author":"mattrjacobs","text":"Also, based on our codebase, rolling back to 0.14.10 did not exhibit the problem (yet).  We also believe that the Scheduler.schedule(Action1) method is the one creating the MultipleAssignmentSubscription (The only other places are OperationRetry and OperationSwitch).\n"},{"date":"2013-12-08T11:47:07Z","author":"akarnokd","text":"Generally, unsubscribing should not happen while holding locks, especially inside these subscription instances. I'll take a look at them.\n"},{"date":"2013-12-09T06:07:33Z","author":"mattrjacobs","text":"Thanks for the really quick work, @akarnokd.  Once we've got the next release of RxJava into our codebase, we'll let you know if the issue is resolved.  \n"},{"date":"2013-12-10T23:04:14Z","author":"benjchristensen","text":"Should be fixed in https:\/\/github.com\/Netflix\/RxJava\/pull\/593\n"}],"opened_by":"mattrjacobs","reopen":false,"closed_on":"2013-12-10T23:04:14Z","description":"Here's the relevant thread dump:\n\n\"RxComputationThreadPool-8\":\n    at rx.subscriptions.CompositeSubscription.unsubscribe(CompositeSubscription.java:100)\n    - waiting to lock <0x00007f2a2846be00> (a rx.subscriptions.CompositeSubscription)\n    at rx.subscriptions.MultipleAssignmentSubscription.unsubscribe(MultipleAssignmentSubscription.java:43)\n    - locked <0x00007f2a26de2a80> (a rx.subscriptions.MultipleAssignmentSubscription)\n    at rx.subscriptions.CompositeSubscription.add(CompositeSubscription.java:92)\n    - locked <0x00007f2a2846be60> (a rx.subscriptions.CompositeSubscription)\n    at rx.concurrency.ExecutorScheduler$4.run(ExecutorScheduler.java:128)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n    at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:166)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:724)\n\"RxComputationThreadPool-7\":\n    at rx.subscriptions.MultipleAssignmentSubscription.unsubscribe(MultipleAssignmentSubscription.java:40)\n    - waiting to lock <0x00007f2a26de2a80> (a rx.subscriptions.MultipleAssignmentSubscription)\n    at rx.subscriptions.CompositeSubscription.add(CompositeSubscription.java:92)\n    - locked <0x00007f2a2846be00> (a rx.subscriptions.CompositeSubscription)\n    at rx.concurrency.ExecutorScheduler$4.run(ExecutorScheduler.java:128)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n    at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:166)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\n","id":"23893849","title":"Deadlock in 0.15.x between MultipleAssignmentSubscription and CompositeSubscription","opened_on":"2013-12-06T23:55:57Z","closed_by":"benjchristensen"},{"number":"429","reopenOn":null,"comments":[{"date":"2013-10-12T06:22:16Z","author":"zsxwing","text":"I think this is not a bug. I suppose you want to do something like this:\n\n<pre>\ncreate a chunk --> sleep 100ms --> emit the chunk -> create a new chunk\n<\/pre>\n\nHowever, as `emit the chunk` and `create a new chunk` may run in different threads, their order is not determined. So if you use `buffer(100, 100, TimeUnit.MILLISECONDS)`, somethink like this may happen:\n\n<pre>\ncreate a chunk --> sleep 100ms --> create a new chunk -> emit the old chunk\n<\/pre>\n\nSo before the old chunk is emited, the old and new chunks will both receive any results after `create a new chunk`.\n\nI think this is not a bug because `TimeBasedChunks` is a `OverlappingChunks`, which allows such indeterminacy.\n"},{"date":"2013-12-06T01:21:54Z","author":"benjchristensen","text":"What's the status of this being a bug or not? @headinthebox Can you confirm?\n"},{"date":"2014-01-02T21:57:42Z","author":"benjchristensen","text":"If I change `.buffer(100, 100, TimeUnit.MILLISECONDS)` to `.buffer(100, TimeUnit.MILLISECONDS)` then I don't see overlaps when I run it many times. \n\nWith `100, 100` I could agree that it is a valid race-condition, but I'm also testing with `100, 101` and seeing it and that doesn't make sense.\n\n`.buffer(100, 101, TimeUnit.MILLISECONDS)`\n\nWith that I see this:\n\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[9, 10]\nDuplicate for 9\n```\n\nThat is not expected, so I tend to agree that we have a bug.\n\nThe second buffer starting at `101` should not have a value emitted during the first `100ms`.\n"},{"date":"2014-01-16T07:14:35Z","author":"Acardiac","text":"> If I change .buffer(100, 100, TimeUnit.MILLISECONDS) to .buffer(100, TimeUnit.MILLISECONDS) then I don't see overlaps when I run it many times.\n\n And if you change it to .buffer(42, TimeUnit.MICROSECONDS), then some items will be dropped.\n\nsee also #756 \n\n> That is not expected, so I tend to agree that we have a bug.\n\n+1\n"},{"date":"2014-05-08T16:59:52Z","author":"akarnokd","text":"This bug should be resolved in the latest release.\n"},{"date":"2014-05-20T05:36:24Z","author":"benjchristensen","text":"This test now passes:\n\n``` java\n    @Test\n    public void testDuplicate() throws Exception {\n        final Set<Integer> unique = new HashSet<Integer>();\n        Observable.create(new OnSubscribe<Integer>() {\n            @Override\n            public void call(final Subscriber<? super Integer> t1) {\n                final Future<?> t = Executors.newSingleThreadExecutor().submit(new Runnable() {\n                    @Override\n                    public void run() {\n                        int count = 0;\n                        for (int i = 0; i < 11; i++) {\n                            t1.onNext(count++);\n                            try {\n                                Thread.sleep(10);\n                            } catch (InterruptedException e) {\n                            }\n                        }\n                    }\n                });\n\n                t1.add(Subscriptions.from(t));\n            }\n        })\n        .buffer(100, 100, TimeUnit.MILLISECONDS) \n        .subscribe(new Action1<List<Integer>>() {\n            @Override\n            public void call(List<Integer> t1) {\n                if (t1.isEmpty()) \n                    return;\n\n                System.out.println(t1.toString());\n                for (Integer i : t1) {\n                    synchronized (unique) {\n                        if (unique.contains(i)) {\n                            System.out.println(\"Duplicate for \" + i);\n                        }\n                        Assert.assertFalse(unique.contains(i));\n                        unique.add(i);\n                    }\n                }\n            }\n        });\n\n        Thread.sleep(10000);\n\n    }\n```\n\nIt emits:\n\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[10]\n```\n"}],"opened_by":"elandau","reopen":false,"closed_on":"2014-05-20T05:36:24Z","description":"This seems to be isolated to the first chunk.\n\n```\n    @Test\n    public void testDuplicate() throws Exception {\n        final Set<Integer> unique = new HashSet<Integer>();\n        Observable.create(new OnSubscribeFunc<Integer>() {\n            @Override\n            public Subscription onSubscribe(final Observer<? super Integer> t1) {\n                final Future<?> t = Executors.newSingleThreadExecutor().submit(new Runnable() {\n                    @Override\n                    public void run() {\n                        int count = 0;\n                        for (int i = 0; i < 11; i++) {\n                            t1.onNext(count++);\n                            try {\n                                Thread.sleep(10);\n                            } catch (InterruptedException e) {\n                            }\n                        }\n                    }\n                });\n\n                return new Subscription() {\n                    @Override\n                    public void unsubscribe() {\n                        t.cancel(true);\n                    }\n                };\n            }\n        })\n        .buffer(100, 100, TimeUnit.MILLISECONDS) \n        .subscribe(new Action1<List<Integer>>() {\n            @Override\n            public void call(List<Integer> t1) {\n                if (t1.isEmpty()) \n                    return;\n\n                LOG.info(t1.toString());\n                for (Integer i : t1) {\n                    synchronized (unique) {\n                        if (unique.contains(i)) {\n                            LOG.error(\"Duplicate for \" + i);\n                        }\n                        Assert.assertFalse(unique.contains(i));\n                        unique.add(i);\n                    }\n                }\n            }\n        });\n\n        Thread.sleep(10000);\n\n    }\n```\n","id":"20787452","title":"buffer() using TimeBasedChunks results in duplicates being sent onNext","opened_on":"2013-10-10T04:58:53Z","closed_by":"benjchristensen"},{"number":"428","reopenOn":null,"comments":[{"date":"2013-10-10T04:19:09Z","author":"benjchristensen","text":"Can you provide a unit test to demonstrate the issue? Here are existing unit tests for buffer: https:\/\/github.com\/Netflix\/RxJava\/blob\/master\/rxjava-core\/src\/main\/java\/rx\/operators\/OperationBuffer.java#L372\n\nAlso, what Future are you referring to? Are you using custom schedulers?\n"},{"date":"2013-10-10T04:37:30Z","author":"elandau","text":"I'm unable to run the unit tests in eclipse for some reason.  Here's a unit test from my project.   While we're on the subject of buffer() it would be nice if the observer was not called with an empty list.  \n\n```\n    @Test\n    public void testInterrupted() throws Exception {\n        Observable.create(new OnSubscribeFunc<Integer>() {\n            @Override\n            public Subscription onSubscribe(final Observer<? super Integer> t1) {\n                final Future<?> t = Executors.newSingleThreadExecutor().submit(new Runnable() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(10000);\n                        } catch (InterruptedException e) {\n                        }\n                    }\n                });\n\n                return new Subscription() {\n                    @Override\n                    public void unsubscribe() {\n                        t.cancel(true);\n                    }\n                };\n            }\n        })\n        .buffer(1000, TimeUnit.MILLISECONDS, 10) \n        .subscribe(new Action1<List<Integer>>() {\n            @Override\n            public void call(List<Integer> t1) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    \/\/ This should be called\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        Thread.sleep(10000);\n\n    }\n```\n"},{"date":"2013-10-10T04:40:28Z","author":"elandau","text":"Regarding the Future, no, i'm not using a custom scheduler.   Subscriptions.create(final Future<?> f) calls cancel on the future when it is unsubscribed. \n"},{"date":"2013-10-10T04:45:18Z","author":"benjchristensen","text":"Yes, that's what a Subscription of a Future is supposed to do. \n"},{"date":"2013-10-10T04:49:12Z","author":"benjchristensen","text":"Thanks for submitting the unit test, I'll try it out.\n\n> While we're on the subject of buffer() it would be nice if the observer was not called with an empty list.\n\nYou're using time, so it will emit every 1000ms whatever is buffered, even if it's empty.\n"}],"opened_by":"elandau","reopen":false,"closed_on":"2013-10-16T06:36:53Z","description":"In TimeAndSizeBasedChunks.emitChunk, if emitChunk is called from the scheduled action in createChunk (i.e from the timeout thread), calling subscription.unsubscribe() ends up calling cancel() on the future which sets the thread's interrupted state to true.  This state has an adverse effect on any blocking call performed in that thread.  \n","id":"20785988","title":"buffer() using TimeAndSizeBasedChunks incorrectly forces thread into interrupted state","opened_on":"2013-10-10T03:53:37Z","closed_by":"benjchristensen"},{"number":"383","reopenOn":null,"comments":[{"date":"2013-09-14T10:04:22Z","author":"samuelgruetter","text":"Output of failed `rx.operators.OperationNext$UnitTest.testOnErrorViaHasNext`:\n\n```\njava.lang.AssertionError: should not have received exception\n    at org.junit.Assert.fail(Assert.java:93)\n    at rx.operators.OperationNext$UnitTest.testOnErrorViaHasNext(OperationNext.java:252)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:80)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:47)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)\n    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)\n    at sun.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n    at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\n    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:103)\n    at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)\n    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:724)\n```\n"},{"date":"2013-09-14T15:43:19Z","author":"benjchristensen","text":"> Build 278: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\n> Build 276: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\n> Build 237: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\n> Build 185: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\n\nThe CurrentThreadScheduler tests that are testing delay functionality are very non-deterministic. The assertions either need to change to allow for that, or we need to change to using artificial time (though these particular tests are purposefully testing the real implementation, so using artificial time would someone defeat the purpose).\n\n> Build 251: rx.concurrency.TestSchedulers.testSchedulingWithDueTime\n\nThis is similar, it's asserting something scheduled on a background thread. I haven't dug into what needs to change.\n\n> Build 277: rx.operators.OperationConcat$UnitTest.testConcatConcurrentWithInfinity\n\nNot sure at a quick glance what the issue here is.\n\n---\n\nI don't have time this morning to fix these but will do so at some point (their intermittent failures annoy me too).\n"},{"date":"2013-09-19T05:15:52Z","author":"benjchristensen","text":"Another here: https:\/\/netflixoss.ci.cloudbees.com\/job\/RxJava-pull-requests\/293\/\n"},{"date":"2013-09-20T15:51:39Z","author":"samuelgruetter","text":"another local failure:\n\n```\nrx.operators.OperationNext$UnitTest > testOnErrorViaHasNext FAILED\n    java.lang.AssertionError at OperationNext.java:252\n```\n"},{"date":"2013-09-23T07:21:30Z","author":"samuelgruetter","text":"and yet another (in `rx.operators.SynchronizedObserver$UnitTest`):\n\n```\njava.lang.AssertionError: expected:<1> but was:<0>\n    at org.junit.Assert.fail(Assert.java:93)\n    at org.junit.Assert.failNotEquals(Assert.java:647)\n    at org.junit.Assert.assertEquals(Assert.java:128)\n    at org.junit.Assert.assertEquals(Assert.java:472)\n    at org.junit.Assert.assertEquals(Assert.java:456)\n    at rx.operators.SynchronizedObserver$UnitTest.testMultiThreadedWithNPEinMiddle(SynchronizedObserver.java:250)\n...\n```\n"},{"date":"2013-09-23T09:12:41Z","author":"zsxwing","text":"`rx.concurrency.CurrentThreadScheduler$UnitTest` failed several times in my machine today:\n\n<pre>\norg.mockito.exceptions.verification.VerificationInOrderFailure: \nVerification in order failure\nWanted but not invoked:\naction0.call();\n-> at rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions(CurrentThreadScheduler.java:191)\nWanted anywhere AFTER following interaction:\naction0.call();\n-> at rx.Scheduler$4.call(Scheduler.java:184)\n    at rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions(CurrentThreadScheduler.java:191)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:80)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:47)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)\n    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)\n    at sun.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n    at $Proxy2.processTestClass(Unknown Source)\n    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:103)\n    at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)\n    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n    at java.lang.Thread.run(Thread.java:662)\n<\/pre>\n"},{"date":"2013-09-25T18:13:58Z","author":"samuelgruetter","text":"again `rx.operators.OperationNext$UnitTest.testOnErrorViaHasNext`\n"},{"date":"2013-10-03T17:21:47Z","author":"petermd","text":"wrt\n\nrx.operators.OperationNext$UnitTest.testOnErrorViaHasNext\n\nI don't think the test is necessarily flaky. rather that the Iterable returned by next() is inconsistent. if you trigger an exception during Iterable.next() then the Iterable.hasNext() will revert to returning 'true'. This can fail the test if the \n\nassertFalse(it.hasNext());\n\nruns after the it.next() on the async thread. \n\nso you can't really fix the test, you can either make the test thread delay a little longer and definitely fail, or remove the assert and accept that the behavior of hasNext() is unreliable after next() completes (either with a value or exception) since its unusual that you'd be checking the Iterable from a different thread.\n\nalso might be worth noting that the wiki suggests the Iterable should return a single 'null' value if the Observable completes without any value (https:\/\/github.com\/Netflix\/RxJava\/wiki\/Blocking-Observable-Operators#next) but I can't see any test or implementation for this case - am I misunderstanding this?\n"},{"date":"2013-10-03T17:32:34Z","author":"abersnaze","text":"Then the hasNext should block until either the onNext or onComplete has been called.\n"},{"date":"2013-10-03T18:12:35Z","author":"petermd","text":"not sure in which case you mean? the hasNext() in the failing test is called after the onNext\/onComplete has occurred (the async thread has called next() and it has thrown an exception)\n\nor do you mean in the case where the Observable completes without an onNext?\n"},{"date":"2013-11-01T14:58:33Z","author":"zsxwing","text":"The following error happened in my machine today:\n\n<pre>\njava.lang.AssertionError: expected:<39.0> but was:<100.0>\n    at org.junit.Assert.fail(Assert.java:93)\n    at org.junit.Assert.failNotEquals(Assert.java:647)\n    at org.junit.Assert.assertEquals(Assert.java:443)\n    at org.junit.Assert.assertEquals(Assert.java:512)\n    at rx.operators.OperationGroupBy$UnitTest.testUnsubscribe(OperationGroupBy.java:546)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:80)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:47)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)\n    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)\n    at sun.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n    at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\n    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:103)\n    at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)\n    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)\n    at java.lang.Thread.run(Thread.java:695)\n<\/pre>\n\nI reviewed `rx.operators.OperationGroupBy.UnitTest.testUnsubscribe()` and found the following assumption was wrong:\n\n``` java\n\/\/ sentEvents will go until 'eventCounter' hits 20 and then unsubscribes\n            \/\/ which means it will also send (but ignore) the 19\/20 events for the other group\n            \/\/ It will not however send all 100 events.\n            assertEquals(39, sentEventCounter.get(), 10);\n            \/\/ gave it a delta of 10 to account for the threading\/unsubscription race condition which can vary depending on a machines performance, thread-scheduler, etc\n```\n\nActually, since we can not control when to run a thread, `sentEventCounter` can be 100 in some scenario.\n"},{"date":"2013-11-05T21:28:24Z","author":"abersnaze","text":"I fixed one flaky test by moving the decrement of the latch in to the observer.\n\n``` java\n                 .map(new Func1<String, String>() {\n                     public String call(String arg0) {\n+                        throw new IllegalArgumentException(\"any error\");\n-                        try {\n-                            throw new IllegalArgumentException(\"any error\");\n-                        } finally {\n-                            latch.countDown();\n-                        }\n                     }\n                 });\n\n+        \/\/ wait for the call to get to the observer before decrementing the latch\n+        doAnswer(new Answer() {\n+            @Override\n+            public Object answer(InvocationOnMock invocation) throws Throwable {\n+                latch.countDown();\n+                return null;\n+            }\n+        }).when(stringObserver).onError(any(Throwable.class));\n         m.subscribe(stringObserver);\n         latch.await();\n```\n"},{"date":"2013-11-06T01:46:24Z","author":"zsxwing","text":"@abersnaze Thanks. I added your patch to PR #461. Is it OK? Could you take a look?\n"},{"date":"2013-12-08T13:16:06Z","author":"samuelgruetter","text":"Just had another instance of this:\n\n```\njava.lang.NullPointerException\n    at rx.operators.OperationConcatTest.testConcatConcurrentWithInfinity(OperationConcatTest.java:324)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    ...\n```\n"},{"date":"2014-01-08T08:31:32Z","author":"samuelgruetter","text":"Another test which also seems to be flaky:\n\n```\nrx.schedulers.NewThreadSchedulerTest.testMixOfDelayedAndNonDelayedActions\n\norg.mockito.exceptions.verification.VerificationInOrderFailure: \nVerification in order failure\nWanted but not invoked:\naction0.call();\n-> at rx.schedulers.AbstractSchedulerTests.testMixOfDelayedAndNonDelayedActions(AbstractSchedulerTests.java:317)\nWanted anywhere AFTER following interaction:\naction0.call();\n-> at rx.Scheduler$4.call(Scheduler.java:194)\n\n    at rx.schedulers.AbstractSchedulerTests.testMixOfDelayedAndNonDelayedActions(AbstractSchedulerTests.java:317)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    ...\n```\n\nThis was with version 0.16.0.\n"},{"date":"2014-01-09T13:37:02Z","author":"zsxwing","text":"For the `rx.schedulers.NewThreadSchedulerTest.testMixOfDelayedAndNonDelayedActions`, as `AbstractSchedulerTests.testMixOfDelayedAndNonDelayedActions` uses the real time to schedule the actions, it's non-deterministic. When the CPUs are busy, the test may fail. Can we enlarge the time?\n\n``` java\n                scheduler.schedule(first);\n                scheduler.schedule(second, 300, TimeUnit.MILLISECONDS);\n                scheduler.schedule(third, 100, TimeUnit.MILLISECONDS);\n                scheduler.schedule(fourth);\n                scheduler.schedule(new Action0() {\n\n                    @Override\n                    public void call() {\n                        latch.countDown();\n                    }\n                }, 400, TimeUnit.MILLISECONDS);\n```\n"},{"date":"2014-05-20T05:32:16Z","author":"benjchristensen","text":"Closing as this has become an epic dumping ground ... most issues have been solved. The only one I'm still aware of is a new one, the `pivot` operator.\n"}],"opened_by":"samuelgruetter","reopen":false,"closed_on":"2014-05-20T05:32:16Z","description":"It looks like there are some flaky unit tests:\n\nOn my machine, this test failed today (but only once):\n\n```\nrx.operators.OperationNext$UnitTest.testOnErrorViaHasNext\n```\n\nOn cloudbees, these tests seem to be flaky:\n\n```\nBuild #278: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\nBuild #276: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\nBuild #237: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\nBuild #185: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\nBuild #251: rx.concurrency.TestSchedulers.testSchedulingWithDueTime\nBuild #277: rx.operators.OperationConcat$UnitTest.testConcatConcurrentWithInfinity\n```\n\nEdit: also\n\n```\nBuild #290: rx.operators.OperationConcat$UnitTest.testConcatConcurrentWithInfinity \n```\n","id":"19494210","title":"Flaky unit tests","opened_on":"2013-09-14T10:01:08Z","closed_by":"benjchristensen"},{"number":"313","reopenOn":"2013-07-29T15:41:54Z","comments":[{"date":"2013-12-06T01:09:57Z","author":"benjchristensen","text":"If this is still an issue can you provide a unit test?\n"},{"date":"2014-02-19T12:55:22Z","author":"EmteZogaf","text":"I wrote a unit test. An Observable of asynchronous child Observables is calling onError after emitting the child Observables.\n\nI created 2 branches:\n- https:\/\/github.com\/EmteZogaf\/RxJava\/tree\/mergeDelayErrorNotDelayingParentOnError having the unit test added and is failing.\n- https:\/\/github.com\/EmteZogaf\/RxJava\/tree\/mergeDelayErrorFix having the unit test and my proposed fix added and is succeeding.\n"},{"date":"2014-05-20T05:31:19Z","author":"benjchristensen","text":"Under what circumstances can the parent emit an error? The use cases you provide seem contrived, as `mergeDelayError` is a static method and therefore there is not a parent `Observable` to emit an error.\n\n``` java\nObservable.mergeDelayError(o1, o2, o3).subscribe()\n```\n\nIn that code there are 3 `Observable` instances being merged, but no parent to emit an error.\n"},{"date":"2014-07-24T05:26:27Z","author":"benjchristensen","text":"Reviewing this again ... the signature where this could be an issue is:\n\n``` java\npublic final static <T> Observable<T> mergeDelayError(Observable<? extends Observable<? extends T>> source)\n```\n"},{"date":"2014-07-24T16:44:19Z","author":"benjchristensen","text":"Marking to be included in 1.0 work.\n"},{"date":"2014-07-24T23:40:58Z","author":"EmteZogaf","text":"I'm sorry for this late reply. I haven't looked into this issue for a while as our project using RxJava is running without any problems. But I will try to update to the new version next month and use base RxJava only without any customizations we made to it back then. If this is still an issue I'll report here.\n"},{"date":"2014-09-23T21:59:42Z","author":"benjchristensen","text":"Marking as 1.x as this doesn't require a signature change so can be fixed without holding up 1.0\n"}],"opened_by":"EmteZogaf","reopen":true,"closed_on":"2014-11-06T06:37:38Z","description":"Shouldn't all onError calls including a possible onError call of the parent observable being delayed till all child observables have successfully finished emitting items or called onError themselves?\n\nTo get my desired behaviour I changed the code so now the onError method adds the error to the error queue and calls the onCompleted method which already does the propagation of received errors.\n","id":"17345758","title":"Operation mergeDelayError(Observable<Observable<T>>) does not delay onError of parent observable","opened_on":"2013-07-29T15:40:11Z","closed_by":"benjchristensen"},{"number":"277","reopenOn":null,"comments":[{"date":"2013-05-23T00:14:57Z","author":"prabirshrestha","text":"This issues was raised when `finally` PR was being sent. https:\/\/github.com\/Netflix\/RxJava\/pull\/196#issuecomment-15026180\n\nHere is the C# equivalent code I just checked with.\n\n``` c#\nusing System;\nusing System.Reactive.Linq;\n\nvar members = new[] { 1, 2, 3, 4, 5 }.ToObservable();\n\nmembers\n    .Finally(() => Console.WriteLine(\"Finally\"))\n    .Subscribe(Console.WriteLine \/* next *\/, Console.WriteLine \/* exception *\/, () => Console.WriteLine(\"Sequence Completed\"));\n```\n\nOutput:\n\n```\n1\n2\n3\n4\n5\nSequence Completed\nFinally\n```\n\nCurrent behavior is correct.\n"},{"date":"2013-05-23T00:18:58Z","author":"benjchristensen","text":"Great. Thank you for confirming with C# code.\n"}],"opened_by":"benjchristensen","reopen":false,"closed_on":"2013-05-31T03:51:35Z","description":"Looks like `finallyDo` is behaving wrong:\n\n``` groovy\npackage rx.lang.groovy.examples\nimport rx.Observable\n\nclass Testing {\n\n    static class myActionClass implements rx.util.functions.Action0 {\n        void call() { println('Finally'); }\n     }\n\n    static main(args) {\n\n\n\n        def myAction = new myActionClass();\n        def numbers = Observable.toObservable([1, 2, 3, 4, 5]);\n\n        numbers.finallyDo(myAction).subscribe(\n          [ onNext: { println(it); },\n            onCompleted:{ println(\"Sequence complete\"); },\n            onError:{ println(\"Error encountered\"); } ]\n        );\n\n    }\n\n}\n```\n\n```\nOutput:\n\n1\n2\n3\n4\n5\nSequence complete\nFinally\n```\n\nI believe \"Finally\" should happen before \"Sequence Completed\"\n","id":"14649105","title":"Finally Happens after onCompleted","opened_on":"2013-05-22T22:29:56Z","closed_by":"benjchristensen"}]